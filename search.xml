<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>View的绘制流程学习</title>
    <url>/2021/04/13/View%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>View</p>
<blockquote>
<p>This class represents the basic building block for user interface components. A View occupies a rectangular area on the screen and is responsible for drawing and event handling. View is the base class for /widgets/, which are used to create interactive UI components (buttons, text fields, etc.).</p>
</blockquote>
<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>首先是View这个类的继承层次：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">View</span> <span class="keyword">implements</span> <span class="title">Drawable</span>.<span class="title">Callback</span>, <span class="title">KeyEvent</span>.<span class="title">Callback</span>,<span class="title">AccessibilityEventSource</span></span></span><br></pre></td></tr></table></figure>
<p>可以看到是一个普通类，实现了3个接口。</p>
<p>View.java文件代码共有27000多行，乍一看很吓人，但其中注释也占了很大部分，仔细看来主要分成以下方面</p>
<ul>
<li><p>构造函数</p>
</li>
<li><p>绘制相关</p>
</li>
<li><p>各种getter/setter</p>
</li>
<li><p>事件处理相关</p>
</li>
</ul>
<p>这篇首先看看构造函数以及绘制相关的源码</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>View这个类的构造函数一共有四个，方法签名分别是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">View</span><span class="params">(Context context)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">View</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">View</span><span class="params">(Context context, <span class="meta">@Nullable</span>  AttributeSet attrs,  <span class="keyword">int</span> defStyleAttr)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">View</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs, <span class="keyword">int</span> defStyleAttr,  <span class="keyword">int</span> defStyleRes)</span></span></span><br></pre></td></tr></table></figure>

<p>其中第2第3个方法的实现都只是调用了第4个方法，而第4个方法又会首先调用第1个方法，因此先看下第1个方法，即单参数的构造方法实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">View</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">        mResources = context != <span class="keyword">null</span> ? context.getResources() : <span class="keyword">null</span>;</span><br><span class="line">        mViewFlags = SOUND_EFFECTS_ENABLED | HAPTIC_FEEDBACK_ENABLED | FOCUSABLE_AUTO;</span><br><span class="line">        <span class="comment">// Set some flags defaults</span></span><br><span class="line">        mPrivateFlags2 =</span><br><span class="line">                (LAYOUT_DIRECTION_DEFAULT &lt;&lt; PFLAG2_LAYOUT_DIRECTION_MASK_SHIFT) |</span><br><span class="line">                (TEXT_DIRECTION_DEFAULT &lt;&lt; PFLAG2_TEXT_DIRECTION_MASK_SHIFT) |</span><br><span class="line">                (PFLAG2_TEXT_DIRECTION_RESOLVED_DEFAULT) |</span><br><span class="line">                (TEXT_ALIGNMENT_DEFAULT &lt;&lt; PFLAG2_TEXT_ALIGNMENT_MASK_SHIFT) |</span><br><span class="line">                (PFLAG2_TEXT_ALIGNMENT_RESOLVED_DEFAULT) |</span><br><span class="line">                (IMPORTANT_FOR_ACCESSIBILITY_DEFAULT &lt;&lt; PFLAG2_IMPORTANT_FOR_ACCESSIBILITY_SHIFT);</span><br><span class="line">        mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop();</span><br><span class="line">        setOverScrollMode(OVER_SCROLL_IF_CONTENT_SCROLLS);</span><br><span class="line">        mUserPaddingStart = UNDEFINED_PADDING;</span><br><span class="line">        mUserPaddingEnd = UNDEFINED_PADDING;</span><br><span class="line">        mRenderNode = RenderNode.create(getClass().getName(), <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!sCompatibilityDone &amp;&amp; context != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> targetSdkVersion = context.getApplicationInfo().targetSdkVersion;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Older apps may need this compatibility hack for measurement.</span></span><br><span class="line">            sUseBrokenMakeMeasureSpec = targetSdkVersion &lt;= Build.VERSION_CODES.JELLY_BEAN_MR1;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Older apps expect onMeasure() to always be called on a layout pass, regardless</span></span><br><span class="line">            <span class="comment">// of whether a layout was requested on that View.</span></span><br><span class="line">            sIgnoreMeasureCache = targetSdkVersion &lt; Build.VERSION_CODES.KITKAT;</span><br><span class="line"></span><br><span class="line">            Canvas.sCompatibilityRestore = targetSdkVersion &lt; Build.VERSION_CODES.M;</span><br><span class="line">            Canvas.sCompatibilitySetBitmap = targetSdkVersion &lt; Build.VERSION_CODES.O;</span><br><span class="line">            Canvas.setCompatibilityVersion(targetSdkVersion);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// In M and newer, our widgets can pass a “hint” value in the size</span></span><br><span class="line">            <span class="comment">// for UNSPECIFIED MeasureSpecs. This lets child views of scrolling containers</span></span><br><span class="line">            <span class="comment">// know what the expected parent size is going to be, so e.g. list items can size</span></span><br><span class="line">            <span class="comment">// themselves at 1/3 the size of their container. It breaks older apps though,</span></span><br><span class="line">            <span class="comment">// specifically apps that use some popular open source libraries.</span></span><br><span class="line">            sUseZeroUnspecifiedMeasureSpec = targetSdkVersion &lt; Build.VERSION_CODES.M;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Old versions of the platform would give different results from</span></span><br><span class="line">            <span class="comment">// LinearLayout measurement passes using EXACTLY and non-EXACTLY</span></span><br><span class="line">            <span class="comment">// modes, so we always need to run an additional EXACTLY pass.</span></span><br><span class="line">            sAlwaysRemeasureExactly = targetSdkVersion &lt;= Build.VERSION_CODES.M;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Prior to N, layout params could change without requiring a</span></span><br><span class="line">            <span class="comment">// subsequent call to setLayoutParams() and they would usually</span></span><br><span class="line">            <span class="comment">// work. Partial layout breaks this assumption.</span></span><br><span class="line">            sLayoutParamsAlwaysChanged = targetSdkVersion &lt;= Build.VERSION_CODES.M;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Prior to N, TextureView would silently ignore calls to setBackground/setForeground.</span></span><br><span class="line">            <span class="comment">// On N+, we throw, but that breaks compatibility with apps that use these methods.</span></span><br><span class="line">            sTextureViewIgnoresDrawableSetters = targetSdkVersion &lt;= Build.VERSION_CODES.M;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Prior to N, we would drop margins in LayoutParam conversions. The fix triggers bugs</span></span><br><span class="line">            <span class="comment">// in apps so we target check it to avoid breaking existing apps.</span></span><br><span class="line">            sPreserveMarginParamsInLayoutParamConversion =</span><br><span class="line">                    targetSdkVersion &gt;= Build.VERSION_CODES.N;</span><br><span class="line"></span><br><span class="line">            sCascadedDragDrop = targetSdkVersion &lt; Build.VERSION_CODES.N;</span><br><span class="line"></span><br><span class="line">            sHasFocusableExcludeAutoFocusable = targetSdkVersion &lt; Build.VERSION_CODES.O;</span><br><span class="line"></span><br><span class="line">            sAutoFocusableOffUIThreadWontNotifyParents = targetSdkVersion &lt; Build.VERSION_CODES.O;</span><br><span class="line"></span><br><span class="line">            sUseDefaultFocusHighlight = context.getResources().getBoolean(</span><br><span class="line">                    com.android.internal.R.bool.config_useDefaultFocusHighlight);</span><br><span class="line"></span><br><span class="line">            sThrowOnInvalidFloatProperties = targetSdkVersion &gt;= Build.VERSION_CODES.P;</span><br><span class="line"></span><br><span class="line">            sCanFocusZeroSized = targetSdkVersion &lt; Build.VERSION_CODES.P;</span><br><span class="line"></span><br><span class="line">            sAlwaysAssignFocus = targetSdkVersion &lt; Build.VERSION_CODES.P;</span><br><span class="line"></span><br><span class="line">            sAcceptZeroSizeDragShadow = targetSdkVersion &lt; Build.VERSION_CODES.P;</span><br><span class="line"></span><br><span class="line">            sCompatibilityDone = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>概括来说，主要做了以下几件事：</p>
<ul>
<li><p>对View可访问的关键变量进行赋值：mContext和mResources等</p>
</li>
<li><p>根据系统版本对其成员变量进行赋值，这里的变量大多数都是boolean型</p>
</li>
</ul>
<p>然后是第4个4参数的构造函数实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">View</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> TypedArray a = context.obtainStyledAttributes(</span><br><span class="line">                attrs, com.android.internal.R.styleable.View, defStyleAttr, defStyleRes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mDebugViewAttributes) &#123;</span><br><span class="line">            saveAttributeData(attrs, a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Drawable background = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftPadding = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> topPadding = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> rightPadding = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> bottomPadding = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> startPadding = UNDEFINED_PADDING;</span><br><span class="line">        <span class="keyword">int</span> endPadding = UNDEFINED_PADDING;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> padding = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> paddingHorizontal = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> paddingVertical = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> viewFlagValues = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> viewFlagMasks = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> setScrollContainer = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> tx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> ty = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> tz = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> elevation = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> rotation = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> rotationX = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> rotationY = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> sx = <span class="number">1f</span>;</span><br><span class="line">        <span class="keyword">float</span> sy = <span class="number">1f</span>;</span><br><span class="line">        <span class="keyword">boolean</span> transformSet = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> scrollbarStyle = SCROLLBARS_INSIDE_OVERLAY;</span><br><span class="line">        <span class="keyword">int</span> overScrollMode = mOverScrollMode;</span><br><span class="line">        <span class="keyword">boolean</span> initializeScrollbars = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> initializeScrollIndicators = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> startPaddingDefined = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> endPaddingDefined = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> leftPaddingDefined = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> rightPaddingDefined = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> targetSdkVersion = context.getApplicationInfo().targetSdkVersion;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set default values.</span></span><br><span class="line">        viewFlagValues |= FOCUSABLE_AUTO;</span><br><span class="line">        viewFlagMasks |= FOCUSABLE_AUTO;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = a.getIndexCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> I = <span class="number">0</span>; I &lt; N; I++) &#123;</span><br><span class="line">            <span class="keyword">int</span> attr = a.getIndex(i);</span><br><span class="line">            <span class="keyword">switch</span> (attr) &#123;</span><br><span class="line">                <span class="keyword">case</span> com.android.internal.R.styleable.View_background:</span><br><span class="line">                    background = a.getDrawable(attr);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> com.android.internal.R.styleable.View_padding:</span><br><span class="line">                    padding = a.getDimensionPixelSize(attr, -<span class="number">1</span>);</span><br><span class="line">                    mUserPaddingLeftInitial = padding;</span><br><span class="line">                    mUserPaddingRightInitial = padding;</span><br><span class="line">                    leftPaddingDefined = <span class="keyword">true</span>;</span><br><span class="line">                    rightPaddingDefined = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> com.android.internal.R.styleable.View_paddingHorizontal:</span><br><span class="line">                    paddingHorizontal = a.getDimensionPixelSize(attr, -<span class="number">1</span>);</span><br><span class="line">                    mUserPaddingLeftInitial = paddingHorizontal;</span><br><span class="line">                    mUserPaddingRightInitial = paddingHorizontal;</span><br><span class="line">                    leftPaddingDefined = <span class="keyword">true</span>;</span><br><span class="line">                    rightPaddingDefined = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 此处省略约400行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setOverScrollMode(overScrollMode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Cache start/end user padding as we cannot fully resolve padding here (we don’t have yet</span></span><br><span class="line">        <span class="comment">// the resolved layout direction). Those cached values will be used later during padding</span></span><br><span class="line">        <span class="comment">// resolution.</span></span><br><span class="line">        mUserPaddingStart = startPadding;</span><br><span class="line">        mUserPaddingEnd = endPadding;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (background != <span class="keyword">null</span>) &#123;</span><br><span class="line">            setBackground(background);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// setBackground above will record that padding is currently provided by the background.</span></span><br><span class="line">        <span class="comment">// If we have padding specified via xml, record that here instead and use it.</span></span><br><span class="line">        mLeftPaddingDefined = leftPaddingDefined;</span><br><span class="line">        mRightPaddingDefined = rightPaddingDefined;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (padding &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            leftPadding = padding;</span><br><span class="line">            topPadding = padding;</span><br><span class="line">            rightPadding = padding;</span><br><span class="line">            bottomPadding = padding;</span><br><span class="line">            mUserPaddingLeftInitial = padding;</span><br><span class="line">            mUserPaddingRightInitial = padding;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (paddingHorizontal &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                leftPadding = paddingHorizontal;</span><br><span class="line">                rightPadding = paddingHorizontal;</span><br><span class="line">                mUserPaddingLeftInitial = paddingHorizontal;</span><br><span class="line">                mUserPaddingRightInitial = paddingHorizontal;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (paddingVertical &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                topPadding = paddingVertical;</span><br><span class="line">                bottomPadding = paddingVertical;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isRtlCompatibilityMode()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mLeftPaddingDefined &amp;&amp; startPaddingDefined) &#123;</span><br><span class="line">                leftPadding = startPadding;</span><br><span class="line">            &#125;</span><br><span class="line">            mUserPaddingLeftInitial = (leftPadding &gt;= <span class="number">0</span>) ? leftPadding : mUserPaddingLeftInitial;</span><br><span class="line">            <span class="keyword">if</span> (!mRightPaddingDefined &amp;&amp; endPaddingDefined) &#123;</span><br><span class="line">                rightPadding = endPadding;</span><br><span class="line">            &#125;</span><br><span class="line">            mUserPaddingRightInitial = (rightPadding &gt;= <span class="number">0</span>) ? rightPadding : mUserPaddingRightInitial;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> hasRelativePadding = startPaddingDefined || endPaddingDefined;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mLeftPaddingDefined &amp;&amp; !hasRelativePadding) &#123;</span><br><span class="line">                mUserPaddingLeftInitial = leftPadding;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mRightPaddingDefined &amp;&amp; !hasRelativePadding) &#123;</span><br><span class="line">                mUserPaddingRightInitial = rightPadding;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        internalSetPadding(</span><br><span class="line">                mUserPaddingLeftInitial,</span><br><span class="line">                topPadding &gt;= <span class="number">0</span> ? topPadding : mPaddingTop,</span><br><span class="line">                mUserPaddingRightInitial,</span><br><span class="line">                bottomPadding &gt;= <span class="number">0</span> ? bottomPadding : mPaddingBottom);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (viewFlagMasks != <span class="number">0</span>) &#123;</span><br><span class="line">            setFlags(viewFlagValues, viewFlagMasks);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (initializeScrollbars) &#123;</span><br><span class="line">            initializeScrollbarsInternal(a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (initializeScrollIndicators) &#123;</span><br><span class="line">            initializeScrollIndicatorsInternal();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        a.recycle();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Needs to be called after mViewFlags is set</span></span><br><span class="line">        <span class="keyword">if</span> (scrollbarStyle != SCROLLBARS_INSIDE_OVERLAY) &#123;</span><br><span class="line">            recomputePadding();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x != <span class="number">0</span> || y != <span class="number">0</span>) &#123;</span><br><span class="line">            scrollTo(x, y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (transformSet) &#123;</span><br><span class="line">            setTranslationX(tx);</span><br><span class="line">            setTranslationY(ty);</span><br><span class="line">            setTranslationZ(tz);</span><br><span class="line">            setElevation(elevation);</span><br><span class="line">            setRotation(rotation);</span><br><span class="line">            setRotationX(rotationX);</span><br><span class="line">            setRotationY(rotationY);</span><br><span class="line">            setScaleX(sx);</span><br><span class="line">            setScaleY(sy);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!setScrollContainer &amp;&amp; (viewFlagValues&amp;SCROLLBARS_VERTICAL) != <span class="number">0</span>) &#123;</span><br><span class="line">            setScrollContainer(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        computeOpaqueFlags();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>概括来说，主要做了两件事情：</p>
<ul>
<li><p>从xml中将属性分析出来，然后赋值到对应的变量中，函数的70%的代码都在做这件事情</p>
</li>
<li><p>对Padding、transform等属性进行赋值</p>
</li>
</ul>
<h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><p>一个View的绘制，需要经历3个阶段：</p>
<ul>
<li><p>需要知道这个View所占的区域有多大</p>
</li>
<li><p>需要知道这个View所处的位置是哪里</p>
</li>
<li><p>需要知道这个View外观长什么样</p>
</li>
</ul>
<p>以上3个阶段分别对应measure(),layout(),draw()函数</p>
<p><em>measure()</em><br>首先来看measure函数的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> optical = isLayoutModeOptical(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (optical != isLayoutModeOptical(mParent)) &#123;</span><br><span class="line">            Insets insets = getOpticalInsets();</span><br><span class="line">            <span class="keyword">int</span> oWidth  = insets.left + insets.right;</span><br><span class="line">            <span class="keyword">int</span> oHeight = insets.top  + insets.bottom;</span><br><span class="line">            widthMeasureSpec  = MeasureSpec.adjust(widthMeasureSpec,  optical ? -oWidth  : oWidth);</span><br><span class="line">            heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Suppress sign extension for the low bytes</span></span><br><span class="line">        <span class="keyword">long</span> key = (<span class="keyword">long</span>) widthMeasureSpec &lt;&lt; <span class="number">32</span> | (<span class="keyword">long</span>) heightMeasureSpec &amp; <span class="number">0xffffffffL</span>;</span><br><span class="line">        <span class="keyword">if</span> (mMeasureCache == <span class="keyword">null</span>) mMeasureCache = <span class="keyword">new</span> LongSparseLongArray(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> forceLayout = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Optimize layout by avoiding an extra EXACTLY pass when the view is</span></span><br><span class="line">        <span class="comment">// already measured as the correct size. In API 23 and below, this</span></span><br><span class="line">        <span class="comment">// extra pass is required to make LinearLayout re-distribute weight.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> specChanged = widthMeasureSpec != mOldWidthMeasureSpec</span><br><span class="line">                || heightMeasureSpec != mOldHeightMeasureSpec;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isSpecExactly = MeasureSpec.getMode(widthMeasureSpec) == MeasureSpec.EXACTLY</span><br><span class="line">                &amp;&amp; MeasureSpec.getMode(heightMeasureSpec) == MeasureSpec.EXACTLY;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> matchesSpecSize = getMeasuredWidth() == MeasureSpec.getSize(widthMeasureSpec)</span><br><span class="line">                &amp;&amp; getMeasuredHeight() == MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> needsLayout = specChanged</span><br><span class="line">                &amp;&amp; (sAlwaysRemeasureExactly || !isSpecExactly || !matchesSpecSize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (forceLayout || needsLayout) &#123;</span><br><span class="line">            <span class="comment">// first clears the measured dimension flag</span></span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET;</span><br><span class="line"></span><br><span class="line">            resolveRtlPropertiesIfNeeded();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> cacheIndex = forceLayout ? -<span class="number">1</span> : mMeasureCache.indexOfKey(key);</span><br><span class="line">            <span class="keyword">if</span> (cacheIndex &lt; <span class="number">0</span> || sIgnoreMeasureCache) &#123;</span><br><span class="line">                <span class="comment">// measure ourselves, this should set the measured dimension flag back</span></span><br><span class="line">                onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">                mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> value = mMeasureCache.valueAt(cacheIndex);</span><br><span class="line">                <span class="comment">// Casting a long to int drops the high 32 bits, no mask needed</span></span><br><span class="line">                setMeasuredDimensionRaw((<span class="keyword">int</span>) (value &gt;&gt; <span class="number">32</span>), (<span class="keyword">int</span>) value);</span><br><span class="line">                mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// flag not set, setMeasuredDimension() was not invoked, we raise</span></span><br><span class="line">            <span class="comment">// an exception to warn the developer</span></span><br><span class="line">            <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;View with id&quot;</span> + getId() + <span class="string">&quot;: &quot;</span></span><br><span class="line">                        + getClass().getName() + “#onMeasure() did not set the&quot;</span><br><span class="line">                       + <span class="string">&quot; measured dimension by calling&quot;</span></span><br><span class="line">                       + <span class="string">&quot; setMeasuredDimension()&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mOldWidthMeasureSpec = widthMeasureSpec;</span><br><span class="line">        mOldHeightMeasureSpec = heightMeasureSpec;</span><br><span class="line"></span><br><span class="line">        mMeasureCache.put(key, ((<span class="keyword">long</span>) mMeasuredWidth) &lt;&lt; <span class="number">32</span> |</span><br><span class="line">                (<span class="keyword">long</span>) mMeasuredHeight &amp; <span class="number">0xffffffffL</span>); <span class="comment">// suppress sign extension</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>阅读一个函数，从读懂函数签名开始：从measure()的函数签名中可以得到以下信息：</p>
<ul>
<li><p>final函数，函数被关键字final标记，意味着不可被子类重写，但仔细看函数体内，大量的代码都是与设置boolean标志位相关的，并没有进行measure，真正measure的地方在上述38行的onMeasure()方法中，这也是自定义View时进行测量操作的地方</p>
</li>
<li><p>入参widthMeasureSpec和heightMeasureSpec，一个View需要确定自己有多大，不能为所欲为，需要知道两点信息：/父容器对其大小的限制/和/父容器允许的大小，/入参的widthMeasureSpec和heightMeasureSpec分别从宽和高两个维度用1个变量给出了上述2点信息，下面具体看下是如何做到的</p>
</li>
</ul>
<p><em>MeasureSpec</em><br>在View的onMeasure()方法中，会调用getDefaultSize(int size, int measureSpec)方法来获得这个View默认的size，看下这个方法的源码即可了解MeasureSpec的原理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = size;</span><br><span class="line">        <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">        <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">            result = size;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">            result = specSize;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中关键的两行，第3行MeasureSpec.getMode()得到的就是父容器对其大小的限制，而MeasureSpec.getSize()得到的是父容器允许/建议的大小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMode</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (measureSpec &amp; MODE_MASK);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (measureSpec &amp; ~MODE_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getMode()和getSize()方法的实现非常简洁，这里的MODE_MASK取值为0X3&lt;&lt;30，即32位，高2位为11，余下为0，因为上面两个方法的含义分别是：getMode为取measureSpec的高2位，getSize为取measureSpec的低30位，通过这个方式，1个32位的变量即可存储模式和尺寸两个信息<br>在getDefaultSize()函数中也能看到，得到的specMode有3种取值：</p>
<ul>
<li><p>UNSPECIFIED：父容器对该View的大小没有限制</p>
</li>
<li><p>AL_MOST：最多不能超过给出的specSize</p>
</li>
<li><p>EXACTLTY：取值要为给出的specSize</p>
</li>
</ul>
<p>meMeasure的最终目标，是在onMeasure()方法中，将测量得到的宽高，赋值给View的宽高，用于后续使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setMeasuredDimensionRaw</span><span class="params">(<span class="keyword">int</span> measuredWidth, <span class="keyword">int</span> measuredHeight)</span> </span>&#123;</span><br><span class="line">        mMeasuredWidth = measuredWidth;</span><br><span class="line">        mMeasuredHeight = measuredHeight;</span><br><span class="line"></span><br><span class="line">        mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><em>layout()</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="number">0</span>) &#123;</span><br><span class="line">            onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</span><br><span class="line">            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> oldL = mLeft;</span><br><span class="line">        <span class="keyword">int</span> oldT = mTop;</span><br><span class="line">        <span class="keyword">int</span> oldB = mBottom;</span><br><span class="line">        <span class="keyword">int</span> oldR = mRight;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line">            onLayout(changed, l, t, r, b);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (shouldDrawRoundScrollbar()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(mRoundScrollbarRenderer == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mRoundScrollbarRenderer = <span class="keyword">new</span> RoundScrollbarRenderer(<span class="keyword">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mRoundScrollbarRenderer = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</span><br><span class="line"></span><br><span class="line">            ListenerInfo li = mListenerInfo;</span><br><span class="line">            <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</span><br><span class="line">                        (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</span><br><span class="line">                <span class="keyword">int</span> numListeners = listenersCopy.size();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i I <span class="number">0</span>; i I numListeners; ++i) &#123;</span><br><span class="line">                    listenersCopy.get(i).onLayoutChange(<span class="keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> wasLayoutValid = isLayoutValid();</span><br><span class="line"></span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</span><br><span class="line">        mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!wasLayoutValid &amp;&amp; isFocused()) &#123;</span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_WANTS_FOCUS;</span><br><span class="line">            <span class="keyword">if</span> (canTakeFocus()) &#123;</span><br><span class="line">                <span class="comment">// We have a robust focus, so parents should no longer be wanting focus.</span></span><br><span class="line">                clearParentsWantFocus();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getViewRootImpl() == <span class="keyword">null</span> || !getViewRootImpl().isInLayout()) &#123;</span><br><span class="line">                <span class="comment">// This is a weird case. Most-likely the user, rather than ViewRootImpl, called</span></span><br><span class="line">                <span class="comment">// layout. In this case, there&#x27;s’no guarantee that parent layouts will be evaluated</span></span><br><span class="line">                <span class="comment">// and thus the safest action is to clear focus here.</span></span><br><span class="line">                clearFocusInternal(<span class="keyword">null</span>, <span class="comment">/* propagate */</span> <span class="keyword">true</span>, <span class="comment">/* refocus */</span> <span class="keyword">false</span>);</span><br><span class="line">                clearParentsWantFocus();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasParentWantsFocus()) &#123;</span><br><span class="line">                <span class="comment">// original requestFocus was likely on this view directly, so just clear focus</span></span><br><span class="line">                clearFocusInternal(<span class="keyword">null</span>, <span class="comment">/* propagate */</span> <span class="keyword">true</span>, <span class="comment">/* refocus */</span> <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// otherwise, we let parents handle re-assigning focus during their layout passes.</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_WANTS_FOCUS) != <span class="number">0</span>) &#123;</span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_WANTS_FOCUS;</span><br><span class="line">            View focused = findFocus();</span><br><span class="line">            <span class="keyword">if</span> (focused != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Try to restore focus as close as possible to our starting focus.</span></span><br><span class="line">                <span class="keyword">if</span> (!restoreDefaultFocus() &amp;&amp; !hasParentWantsFocus()) &#123;</span><br><span class="line">                    <span class="comment">// Give up and clear focus once we’v’ reached the top-most parent which wants</span></span><br><span class="line">                    <span class="comment">// focus.</span></span><br><span class="line">                    focused.clearFocusInternal(<span class="keyword">null</span>, <span class="comment">/* propagate */</span> <span class="keyword">true</span>, <span class="comment">/* refocus */</span> <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_NOTIFY_AUTOFILL_ENTER_ON_LAYOUT) != <span class="number">0</span>) &#123;</span><br><span class="line">            mPrivateFlags3 &amp;= ~PFLAG3_NOTIFY_AUTOFILL_ENTER_ON_LAYOUT;</span><br><span class="line">            notifyEnterOrExitForAutoFillIfNeeded(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>layout()函数，作用是确定View的坐标，通过left/top/right/bottom四个值来确定，有2点值得记录的：</p>
<ul>
<li><p>进行layout()时，会检查是否已经进行了onMeasure()，确保layout()在onMeasure(0之后</p>
</li>
<li><p>和measure()与onMeasure()类似，真正进行layout操作的，在onLayout()方法里，也是自定义View确定布局的地方，在View.java里，onLayout()函数是一个空实现</p>
</li>
</ul>
<p><em>draw()</em><br>确定了View的大小和位置之后，就可以进行实际的绘制操作了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> privateFlags = mPrivateFlags;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;</span><br><span class="line">                (mAttachInfo == <span class="keyword">null</span> || !mAttachInfo.mIgnoreDirtyState);</span><br><span class="line">        mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 1, draw the background, if needed</span></span><br><span class="line">        <span class="keyword">int</span> saveCount;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!dirtyOpaque) &#123;</span><br><span class="line">            drawBackground(canvas);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// skip step 2 &amp; 5 if possible (common case)</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</span><br><span class="line">        <span class="keyword">boolean</span> horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</span><br><span class="line">            <span class="comment">// Step 3, draw the content</span></span><br><span class="line">            <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step 4, draw the children</span></span><br><span class="line">            dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">            drawAutofilledHighlight(canvas);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Overlay is part of the content and draws beneath Foreground</span></span><br><span class="line">            <span class="keyword">if</span> (mOverlay != <span class="keyword">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">                mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step 6, draw decorations (foreground, scrollbars)</span></span><br><span class="line">            onDrawForeground(canvas);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step 7, draw the default focus highlight</span></span><br><span class="line">            drawDefaultFocusHighlight(canvas);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (debugDraw()) &#123;</span><br><span class="line">                debugDrawFocus(canvas);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// we’re done…</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>draw()过程，源码的注释比较清晰，主要有7个步骤：</p>
<ul>
<li><p>绘制背景</p>
</li>
<li><p>如果有需要，保存图层信息，用于淡出准备</p>
</li>
<li><p>绘制内容，这一步最关键，也和measure()/layout()相似，这里会调用onDraw()来绘制真正的内容</p>
</li>
<li><p>绘制子view</p>
</li>
<li><p>如果有需要，绘制类似阴影效果</p>
</li>
<li><p>绘制View的装饰，如滚动条</p>
</li>
<li><p>绘制焦点效果</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Android源码学习</tag>
      </tags>
  </entry>
  <entry>
    <title>ViewGroup绘制源码学习</title>
    <url>/2021/04/13/ViewGroup%E7%BB%98%E5%88%B6%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>ViewGroup </p>
<blockquote>
<p>A ViewGroup is a special view that can contain other views. The view group is the base class for layouts and views containers. This class also defines the<br>  android.view.ViewGroup.LayoutParams class which serves as the base class for layouts parameters.</p>
</blockquote>
<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>首先看下ViewGroup的继承层次：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class ViewGroup extends View implements ViewParent, ViewManager </span><br></pre></td></tr></table></figure>
<p>可以看到ViewGroup与View第一个不同点在于，ViewGroup是一个抽象类，继承自View，实现了ViewParent和ViewManager两个接口</p>
<h3 id="ViewParent和ViewManager"><a href="#ViewParent和ViewManager" class="headerlink" title="ViewParent和ViewManager"></a>ViewParent和ViewManager</h3><p>首先是ViewParent这个接口，内含的部分方法如下：<br><img src="https://upload-images.jianshu.io/upload_images/5866715-e627c1cecca60435.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ViewParent部分方法"></p>
<p>其次是ViewManager的方法：<br><img src="https://upload-images.jianshu.io/upload_images/5866715-ae2ee8eff4fffb96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ViewManager"><br>ViewManager的方法很好理解，对View进行的增删改3个操作</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>和View类似，ViewGroup也有4个构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewGroup</span><span class="params">(Context context)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewGroup</span><span class="params">(Context context, AttributeSet attrs)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewGroup</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewGroup</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span></span></span><br></pre></td></tr></table></figure>
<p>但是实际上，前3个构造函数最终也只是调用到第4个，而第4个构造函数的实现也非常简单明了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewGroup</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr, defStyleRes);</span><br><span class="line"></span><br><span class="line">        initViewGroup();</span><br><span class="line">        initFromAttributes(context, attrs, defStyleAttr, defStyleRes);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>即两个init方法的调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initViewGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ViewGroup doesn&#x27;t draw by default</span></span><br><span class="line">        <span class="keyword">if</span> (!debugDraw()) &#123;</span><br><span class="line">            setFlags(WILL_NOT_DRAW, DRAW_MASK);</span><br><span class="line">        &#125;</span><br><span class="line">        mGroupFlags |= FLAG_CLIP_CHILDREN;</span><br><span class="line">        mGroupFlags |= FLAG_CLIP_TO_PADDING;</span><br><span class="line">        mGroupFlags |= FLAG_ANIMATION_DONE;</span><br><span class="line">        mGroupFlags |= FLAG_ANIMATION_CACHE;</span><br><span class="line">        mGroupFlags |= FLAG_ALWAYS_DRAWN_WITH_CACHE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mContext.getApplicationInfo().targetSdkVersion &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">            mGroupFlags |= FLAG_SPLIT_MOTION_EVENTS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setDescendantFocusability(FOCUS_BEFORE_DESCENDANTS);</span><br><span class="line"></span><br><span class="line">        mChildren = <span class="keyword">new</span> View[ARRAY_INITIAL_CAPACITY];</span><br><span class="line">        mChildrenCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        mPersistentDrawingCache = PERSISTENT_SCROLLING_CACHE;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先initViewGroup()方法对其自身的一些标志位等做了初始操作；然后调用initFromAttributes()，从函数名称也可以猜到，这个函数作用是从xml属性中进行初始化操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initFromAttributes</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ViewGroup, defStyleAttr,</span><br><span class="line">                defStyleRes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = a.getIndexCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> attr = a.getIndex(i);</span><br><span class="line">            <span class="keyword">switch</span> (attr) &#123;</span><br><span class="line">                <span class="keyword">case</span> R.styleable.ViewGroup_clipChildren:</span><br><span class="line">                    setClipChildren(a.getBoolean(attr, <span class="keyword">true</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> R.styleable.ViewGroup_clipToPadding:</span><br><span class="line">                    setClipToPadding(a.getBoolean(attr, <span class="keyword">true</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> R.styleable.ViewGroup_animationCache:</span><br><span class="line">                    setAnimationCacheEnabled(a.getBoolean(attr, <span class="keyword">true</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                ……</span><br><span class="line">                <span class="keyword">case</span> R.styleable.ViewGroup_touchscreenBlocksFocus:</span><br><span class="line">                    setTouchscreenBlocksFocus(a.getBoolean(attr, <span class="keyword">false</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        a.recycle();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="绘制相关"><a href="#绘制相关" class="headerlink" title="绘制相关"></a>绘制相关</h3><p>从View的绘制源码学习中已经知道，一个View的绘制，包括measure/layout/draw三个阶段，那么作为View的子类，ViewGroup的绘制也无非这3个阶段：</p>
<h5 id="measure"><a href="#measure" class="headerlink" title="measure"></a>measure</h5><p>因为View的measure()方法是个final方法，因此在ViewGroup中不能重写改方法，而ViewGroup中也没有实现onMeasure()方法，但在measure阶段，ViewGroup提供了几个measure相关的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildren</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> parentHeightMeasureSpec)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed)</span> </span></span><br></pre></td></tr></table></figure>
<p>这几个方法在实现上，关键的点是一致的，因此选择相对简洁的measureChild()来看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> parentHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">                mPaddingLeft + mPaddingRight, lp.width);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">                mPaddingTop + mPaddingBottom, lp.height);</span><br><span class="line"></span><br><span class="line">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>最关键的点在于最后一句，child.measure()，从View绘制过程已经知道，measure阶段的目的在于，让View得到自己所占据的大小，因此对ViewGroup来说，measure阶段，就需要让自己的所有子View知道自己的大小。</p>
<h5 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h5><p>在layout阶段，ViewGroup重写了View的layout()和onlayout()方法</p>
<p>实际上layout并没有做什么实质的工作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mSuppressLayout &amp;&amp; (mTransition == <span class="keyword">null</span> || !mTransition.isChangingLayout())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mTransition != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mTransition.layoutChange(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">super</span>.layout(l, t, r, b);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// record the fact that we noop&#x27;d it; request layout when transition finishes</span></span><br><span class="line">            mLayoutCalledWhileSuppressed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>更加关键的是onLayout()方法，这里变成了abstract抽象方法，这也是为什么ViewGroup是一个抽象类的原因</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected abstract void onLayout(b</span><br><span class="line">        oolean changed,</span><br><span class="line">        int l, int t, int r, int b);</span><br></pre></td></tr></table></figure>

<h5 id="draw"><a href="#draw" class="headerlink" title="draw"></a>draw</h5><p>在draw阶段，ViewGroup里相关的函数是dispatchDraw()，drawChild()：在dispatchDraw()中遍历所有的子View，对所有子View执行drawChild()方法，而drawChild()方法的实现非常简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">drawChild</span><span class="params">(Canvas canvas, View child, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> child.draw(canvas, <span class="keyword">this</span>, drawingTime);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>ViewGroup的绘制，最终也就是各个子View自身的绘制。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后总结一下ViewGroup和View的差异：</p>
<ul>
<li>View是一个普通类，而ViewGroup是一个抽象类</li>
<li>measure阶段，View通过measure()和onMeasure()来确定自身的占据范围，ViewGroup通过measureChild()等方法来确定各个子View的占据范围</li>
<li>layout阶段，View通过layout()和onLayout()函数来确定位置，而ViewGroup中onLayout()变成抽象方法，需要子类实现；</li>
<li>draw阶段，View通过draw()和onDraw()方法来实现绘制，ViewGroup通过dispatchDraw()和drawChild()方法来让各个子View绘制自身。</li>
</ul>
]]></content>
      <tags>
        <tag>Android源码学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Android LinearLayout源码学习</title>
    <url>/2021/04/13/Android-LinearLayout%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>LinearLayout应该是Android开发中最常见的布局容器控件，可以实现子View的线性排列，通过layout_weight的可以方便地控制子View的大小。这篇文档目的在于通过对LinearLayout的源码阅读，理解LinearLayout的工作原理。</p>
<p>###onMeasure<br>在Android中，一个控件的工作过程分为测量、布局、绘制3大阶段，从onMeasure()函数入手，看下LinearLayout是如何完成测量工作的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">            measureVertical(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            measureHorizontal(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>根据设定的方向不同，会调用对应的measure方法，选取VERTICAL来进行解析：</p>
<h5 id="measureVertical-int-widthMeasureSpec-int-heightMeasureSpec"><a href="#measureVertical-int-widthMeasureSpec-int-heightMeasureSpec" class="headerlink" title="measureVertical(int widthMeasureSpec, int heightMeasureSpec)"></a>measureVertical(int widthMeasureSpec, int heightMeasureSpec)</h5><p>整个函数主要分成以下几点：</p>
<ul>
<li>变量声明</li>
<li>遍历子View，确定各个子View所需大小</li>
<li>如有需要，再次遍历子View，更新mTotalLength</li>
<li>再次遍历子View，将多余的空间根据layout_weight分配给子View</li>
</ul>
<p><strong>变量声明部分</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">measureVertical</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        mTotalLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxWidth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> childState = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> alternativeMaxWidth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> weightedMaxWidth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> allFillParent = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">float</span> totalWeight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> count = getVirtualChildCount();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> matchWidth = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> skippedMeasure = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> baselineChildIndex = mBaselineAlignedChildIndex;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> useLargestChild = mUseLargestChild;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> largestChildHeight = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> consumedExcessSpace = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nonSkippedChildCount = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一部分从变量名自身都能够猜到这些变量的意义</p>
<p>**初次遍历子View，确定子View所需大小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">measureVertical</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">        <span class="comment">// See how tall everyone is. Also remember max width.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = getVirtualChildAt(i);</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mTotalLength += measureNullChild(i);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (child.getVisibility() == View.GONE) &#123;</span><br><span class="line">               i += getChildrenSkipCount(child, i);</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nonSkippedChildCount++;</span><br><span class="line">            <span class="keyword">if</span> (hasDividerBeforeChildAt(i)) &#123;</span><br><span class="line">                mTotalLength += mDividerHeight;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">            totalWeight += lp.weight;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> useExcessSpace = lp.height == <span class="number">0</span> &amp;&amp; lp.weight &gt; <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (heightMode == MeasureSpec.EXACTLY &amp;&amp; useExcessSpace) &#123;</span><br><span class="line">                <span class="comment">// Optimization: don&#x27;t bother measuring children who are only</span></span><br><span class="line">                <span class="comment">// laid out using excess space. These views will get measured</span></span><br><span class="line">                <span class="comment">// later if we have space to distribute.</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</span><br><span class="line">                mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);</span><br><span class="line">                skippedMeasure = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (useExcessSpace) &#123;</span><br><span class="line">                    <span class="comment">// The heightMode is either UNSPECIFIED or AT_MOST, and</span></span><br><span class="line">                    <span class="comment">// this child is only laid out using excess space. Measure</span></span><br><span class="line">                    <span class="comment">// using WRAP_CONTENT so that we can find out the view&#x27;s</span></span><br><span class="line">                    <span class="comment">// optimal height. We&#x27;ll restore the original height of 0</span></span><br><span class="line">                    <span class="comment">// after measurement.</span></span><br><span class="line">                    lp.height = LayoutParams.WRAP_CONTENT;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Determine how big this child would like to be. If this or</span></span><br><span class="line">                <span class="comment">// previous children have given a weight, then we allow it to</span></span><br><span class="line">                <span class="comment">// use all available space (and we will shrink things later</span></span><br><span class="line">                <span class="comment">// if needed).</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> usedHeight = totalWeight == <span class="number">0</span> ? mTotalLength : <span class="number">0</span>;</span><br><span class="line">                measureChildBeforeLayout(child, i, widthMeasureSpec, <span class="number">0</span>,</span><br><span class="line">                        heightMeasureSpec, usedHeight);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</span><br><span class="line">                <span class="keyword">if</span> (useExcessSpace) &#123;</span><br><span class="line">                    <span class="comment">// Restore the original height and record how much space</span></span><br><span class="line">                    <span class="comment">// we&#x27;ve allocated to excess-only children so that we can</span></span><br><span class="line">                    <span class="comment">// match the behavior of EXACTLY measurement.</span></span><br><span class="line">                    lp.height = <span class="number">0</span>;</span><br><span class="line">                    consumedExcessSpace += childHeight;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</span><br><span class="line">                mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +</span><br><span class="line">                       lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (useLargestChild) &#123;</span><br><span class="line">                    largestChildHeight = Math.max(childHeight, largestChildHeight);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * If applicable, compute the additional offset to the child&#x27;s baseline</span></span><br><span class="line"><span class="comment">             * we&#x27;ll need later when asked &#123;<span class="doctag">@link</span> #getBaseline&#125;.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> ((baselineChildIndex &gt;= <span class="number">0</span>) &amp;&amp; (baselineChildIndex == i + <span class="number">1</span>)) &#123;</span><br><span class="line">               mBaselineChildTop = mTotalLength;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if we are trying to use a child index for our baseline, the above</span></span><br><span class="line">            <span class="comment">// book keeping only works if there are no children above it with</span></span><br><span class="line">            <span class="comment">// weight.  fail fast to aid the developer.</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; baselineChildIndex &amp;&amp; lp.weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;A child of LinearLayout with index &quot;</span></span><br><span class="line">                        + <span class="string">&quot;less than mBaselineAlignedChildIndex has weight &gt; 0, which &quot;</span></span><br><span class="line">                        + <span class="string">&quot;won&#x27;t work.  Either remove the weight, or don&#x27;t set &quot;</span></span><br><span class="line">                        + <span class="string">&quot;mBaselineAlignedChildIndex.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> matchWidthLocally = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (widthMode != MeasureSpec.EXACTLY &amp;&amp; lp.width == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                <span class="comment">// The width of the linear layout will scale, and at least one</span></span><br><span class="line">                <span class="comment">// child said it wanted to match our width. Set a flag</span></span><br><span class="line">                <span class="comment">// indicating that we need to remeasure at least that view when</span></span><br><span class="line">                <span class="comment">// we know our width.</span></span><br><span class="line">                matchWidth = <span class="keyword">true</span>;</span><br><span class="line">                matchWidthLocally = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> margin = lp.leftMargin + lp.rightMargin;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> measuredWidth = child.getMeasuredWidth() + margin;</span><br><span class="line">            maxWidth = Math.max(maxWidth, measuredWidth);</span><br><span class="line">            childState = combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line"></span><br><span class="line">            allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line">            <span class="keyword">if</span> (lp.weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Widths of weighted Views are bogus if we end up</span></span><br><span class="line"><span class="comment">                 * remeasuring, so keep them separate.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                weightedMaxWidth = Math.max(weightedMaxWidth,</span><br><span class="line">                        matchWidthLocally ? margin : measuredWidth);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                        matchWidthLocally ? margin : measuredWidth);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            i += getChildrenSkipCount(child, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ……</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在初次遍历子View中，关键需要理解的代码在于：</p>
<ul>
<li>如果heightMode为EXCATLY，并且遍历到的子View的height为0，而且weight大于0这个条件成立，将会将skippedMeasure设置为true，然后将<strong>不会</strong>对该子View进行测量</li>
<li>如果上述条件不成立，将会调用measureChildBeforeLayout()方法对该子View进行一次测量</li>
<li>如果对子View进行过测量，会将该子View的高度添加到mTotalLength上记录下来</li>
</ul>
<p><strong>如有需要，再次遍历子View，更新mTotalLength</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (useLargestChild &amp;&amp;</span><br><span class="line">                (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) &#123;</span><br><span class="line">            mTotalLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">                <span class="keyword">final</span> View child = getVirtualChildAt(i);</span><br><span class="line">                <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mTotalLength += measureNullChild(i);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (child.getVisibility() == GONE) &#123;</span><br><span class="line">                    i += getChildrenSkipCount(child, i);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams)</span><br><span class="line">                        child.getLayoutParams();</span><br><span class="line">                <span class="comment">// Account for negative margins</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</span><br><span class="line">                mTotalLength = Math.max(totalLength, totalLength + largestChildHeight +</span><br><span class="line">                        lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这里是如果设置了useLargestChild才会走到的逻辑</p>
<p><strong>再次遍历子View，将多余的空间根据layout_weight分配给子View</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">measureVertical</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> heightSize = mTotalLength;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check against our minimum height</span></span><br><span class="line">        heightSize = Math.max(heightSize, getSuggestedMinimumHeight());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reconcile our calculated size with the heightMeasureSpec</span></span><br><span class="line">        <span class="keyword">int</span> heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, <span class="number">0</span>);</span><br><span class="line">        heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;</span><br><span class="line">        <span class="comment">// Either expand children with weight to take up available space or</span></span><br><span class="line">        <span class="comment">// shrink them if they extend beyond our current bounds. If we skipped</span></span><br><span class="line">        <span class="comment">// measurement on any children, we need to measure them now.</span></span><br><span class="line">        <span class="keyword">int</span> remainingExcess = heightSize - mTotalLength</span><br><span class="line">                + (mAllowInconsistentMeasurement ? <span class="number">0</span> : consumedExcessSpace);</span><br><span class="line">        <span class="keyword">if</span> (skippedMeasure</span><br><span class="line">                || ((sRemeasureWeightedChildren || remainingExcess != <span class="number">0</span>) &amp;&amp; totalWeight &gt; <span class="number">0.0f</span>)) &#123;</span><br><span class="line">            <span class="keyword">float</span> remainingWeightSum = mWeightSum &gt; <span class="number">0.0f</span> ? mWeightSum : totalWeight;</span><br><span class="line"></span><br><span class="line">            mTotalLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">                <span class="keyword">final</span> View child = getVirtualChildAt(i);</span><br><span class="line">                <span class="keyword">if</span> (child == <span class="keyword">null</span> || child.getVisibility() == View.GONE) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> childWeight = lp.weight;</span><br><span class="line">                <span class="keyword">if</span> (childWeight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> share = (<span class="keyword">int</span>) (childWeight * remainingExcess / remainingWeightSum);</span><br><span class="line">                    remainingExcess -= share;</span><br><span class="line">                    remainingWeightSum -= childWeight;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> childHeight;</span><br><span class="line">                    <span class="keyword">if</span> (mUseLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">                        childHeight = largestChildHeight;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lp.height == <span class="number">0</span> &amp;&amp; (!mAllowInconsistentMeasurement</span><br><span class="line">                            || heightMode == MeasureSpec.EXACTLY)) &#123;</span><br><span class="line">                        <span class="comment">// This child needs to be laid out from scratch using</span></span><br><span class="line">                        <span class="comment">// only its share of excess space.</span></span><br><span class="line">                        childHeight = share;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// This child had some intrinsic height to which we</span></span><br><span class="line">                        <span class="comment">// need to add its share of excess space.</span></span><br><span class="line">                        childHeight = child.getMeasuredHeight() + share;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                            Math.max(<span class="number">0</span>, childHeight), MeasureSpec.EXACTLY);</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,</span><br><span class="line">                            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin,</span><br><span class="line">                            lp.width);</span><br><span class="line">                    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Child may now not fit in vertical dimension.</span></span><br><span class="line">                    childState = combineMeasuredStates(childState, child.getMeasuredState()</span><br><span class="line">                            &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> margin =  lp.leftMargin + lp.rightMargin;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> measuredWidth = child.getMeasuredWidth() + margin;</span><br><span class="line">                maxWidth = Math.max(maxWidth, measuredWidth);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">boolean</span> matchWidthLocally = widthMode != MeasureSpec.EXACTLY &amp;&amp;</span><br><span class="line">                        lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line"></span><br><span class="line">                alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                        matchWidthLocally ? margin : measuredWidth);</span><br><span class="line"></span><br><span class="line">                allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</span><br><span class="line">                mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() +</span><br><span class="line">                        lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add in our padding</span></span><br><span class="line">            mTotalLength += mPaddingTop + mPaddingBottom;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Should we recompute the heightSpec based on the new total length?</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                                           weightedMaxWidth);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// We have no limit, so make all weighted views as tall as the largest child.</span></span><br><span class="line">            <span class="comment">// Children will have already been measured once.</span></span><br><span class="line">            <span class="keyword">if</span> (useLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                    <span class="keyword">final</span> View child = getVirtualChildAt(i);</span><br><span class="line">                    <span class="keyword">if</span> (child == <span class="keyword">null</span> || child.getVisibility() == View.GONE) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> LinearLayout.LayoutParams lp =</span><br><span class="line">                            (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">float</span> childExtra = lp.weight;</span><br><span class="line">                    <span class="keyword">if</span> (childExtra &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        child.measure(</span><br><span class="line">                                MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(),</span><br><span class="line">                                        MeasureSpec.EXACTLY),</span><br><span class="line">                                MeasureSpec.makeMeasureSpec(largestChildHeight,</span><br><span class="line">                                        MeasureSpec.EXACTLY));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!allFillParent &amp;&amp; widthMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">            maxWidth = alternativeMaxWidth;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        maxWidth += mPaddingLeft + mPaddingRight;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check against our minimum width</span></span><br><span class="line">        maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</span><br><span class="line"></span><br><span class="line">        setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class="line">                heightSizeAndState);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (matchWidth) &#123;</span><br><span class="line">            forceUniformWidth(count, heightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这一阶段最终要的代码在于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (childWeight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> share = (<span class="keyword">int</span>) (childWeight * remainingExcess / remainingWeightSum);</span><br><span class="line">                    remainingExcess -= share;</span><br><span class="line">                    remainingWeightSum -= childWeight;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> childHeight;</span><br><span class="line">                    <span class="keyword">if</span> (mUseLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">                        childHeight = largestChildHeight;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lp.height == <span class="number">0</span> &amp;&amp; (!mAllowInconsistentMeasurement</span><br><span class="line">                            || heightMode == MeasureSpec.EXACTLY)) &#123;</span><br><span class="line">                        <span class="comment">// This child needs to be laid out from scratch using</span></span><br><span class="line">                        <span class="comment">// only its share of excess space.</span></span><br><span class="line">                        childHeight = share;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// This child had some intrinsic height to which we</span></span><br><span class="line">                        <span class="comment">// need to add its share of excess space.</span></span><br><span class="line">                        childHeight = child.getMeasuredHeight() + share;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                            Math.max(<span class="number">0</span>, childHeight), MeasureSpec.EXACTLY);</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,</span><br><span class="line">                            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin,</span><br><span class="line">                            lp.width);</span><br><span class="line">                    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果子View设置了大于0的layout_weight，将在这里计算出对应的share值</li>
<li>根据share值和原本子View测量到的高度，再次调用子View的measure方法进行测量</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>根据以上源码的阅读，我们可以总结一下在不同情况下，LinearLayout需要测量多少次子View：</p>
<ul>
<li>如果所有的子View都没有设置layout_weight，测量1次</li>
<li>如果有子View设置了layout_weight，设置了layout_weight的子View将测量2次</li>
</ul>
]]></content>
      <tags>
        <tag>Android源码学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Android RelativeLayout源码学习</title>
    <url>/2021/04/13/Android-RelativeLayout%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>RelativeLayout是Android中一种常用的布局，通过View之间的相互关系能够方便地确定子View的位置，通过源码的学习来看下Android是如何实现这一功能的。Android中的一个组件，工作原理主要在onMeasure(),onLayout(),onDraw()这3大阶段中。</p>
<p>###onMeasure()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mDirtyHierarchy) &#123;</span><br><span class="line">            mDirtyHierarchy = <span class="keyword">false</span>;</span><br><span class="line">            sortChildren();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测量过程的第一步是对子View进行排序</strong>，在这一步骤会设置一个标志位mDirtyHierarchy进行优化，下面看下sortChildren的具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sortChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> count = getChildCount();</span><br><span class="line">        <span class="keyword">if</span> (mSortedVerticalChildren == <span class="keyword">null</span> || mSortedVerticalChildren.length != count) &#123;</span><br><span class="line">            mSortedVerticalChildren = <span class="keyword">new</span> View[count];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mSortedHorizontalChildren == <span class="keyword">null</span> || mSortedHorizontalChildren.length != count) &#123;</span><br><span class="line">            mSortedHorizontalChildren = <span class="keyword">new</span> View[count];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> DependencyGraph graph = mGraph;</span><br><span class="line">        graph.clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            graph.add(getChildAt(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        graph.getSortedViews(mSortedVerticalChildren, RULES_VERTICAL);</span><br><span class="line">        graph.getSortedViews(mSortedHorizontalChildren, RULES_HORIZONTAL);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个函数包含以下步骤：</p>
<ul>
<li>初始化两个数组，分别用于记录水平方向和竖直方向的排序结果</li>
<li>初始化一个依赖图DependencyGraph，将子View都加入到依赖图中</li>
<li>调用DependencyGraph的getSortedViews方法，将两个方向的排序结果记录到对应数组中</li>
</ul>
<p>下面首先看下DependencyGraph的结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyGraph</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * List of all views in the graph.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> ArrayList&lt;Node&gt; mNodes = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * List of nodes in the graph. Each node is identified by its</span></span><br><span class="line"><span class="comment">         * view id (see View#getId()).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> SparseArray&lt;Node&gt; mKeyNodes = <span class="keyword">new</span> SparseArray&lt;Node&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Temporary data structure used to build the list of roots</span></span><br><span class="line"><span class="comment">         * for this graph.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> ArrayDeque&lt;Node&gt; mRoots = <span class="keyword">new</span> ArrayDeque&lt;Node&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果里每个成员代表的含义，其注释已经说清楚了；再具体看下Node的结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * The view representing this node in the layout.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            View view;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * The list of dependents for this node; a dependent is a node</span></span><br><span class="line"><span class="comment">             * that needs this node to be processed first.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">final</span> ArrayMap&lt;Node, DependencyGraph&gt; dependents =</span><br><span class="line">                    <span class="keyword">new</span> ArrayMap&lt;Node, DependencyGraph&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * The list of dependencies for this node.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">final</span> SparseArray&lt;Node&gt; dependencies = <span class="keyword">new</span> SparseArray&lt;Node&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据注释也能够明白每个成员的含义</p>
<p>接下来看下DependencyGraph是如何实现getSortedViews方法的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getSortedViews</span><span class="params">(View[] sorted, <span class="keyword">int</span>... rules)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 找出所有的不依赖其他节点的节点，即根节点</span></span><br><span class="line">            <span class="keyword">final</span> ArrayDeque&lt;Node&gt; roots = findRoots(rules);</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            Node node;</span><br><span class="line">            <span class="comment">// 循环从根节点的队尾中取出元素</span></span><br><span class="line">            <span class="keyword">while</span> ((node = roots.pollLast()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> View view = node.view;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> key = view.getId();</span><br><span class="line">                <span class="comment">// 将该节点加入排序结果</span></span><br><span class="line">                sorted[index++] = view;</span><br><span class="line">                <span class="comment">// 取出该节点的所有伴随节点</span></span><br><span class="line">                <span class="keyword">final</span> ArrayMap&lt;Node, DependencyGraph&gt; dependents = node.dependents;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> count = dependents.size();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                    <span class="comment">// 遍历伴随节点</span></span><br><span class="line">                    <span class="keyword">final</span> Node dependent = dependents.keyAt(i);</span><br><span class="line">                    <span class="comment">// 取出伴随节点的所有依赖节点集合</span></span><br><span class="line">                    <span class="keyword">final</span> SparseArray&lt;Node&gt; dependencies = dependent.dependencies;</span><br><span class="line">                    <span class="comment">// 将当前节点从伴随节点的依赖节点集合中去掉</span></span><br><span class="line">                    dependencies.remove(key);</span><br><span class="line">                    <span class="comment">// 如果该伴随节点去掉当前节点的依赖之后，没有再依赖其他节点，证明它是新的根节点，加入根节点集合</span></span><br><span class="line">                    <span class="keyword">if</span> (dependencies.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                        roots.add(dependent);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (index &lt; sorted.length) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Circular dependencies cannot exist&quot;</span></span><br><span class="line">                        + <span class="string">&quot; in RelativeLayout&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这个排序的过程已经在注释中说明，实现过程还是挺明确的。</p>
<p>再看完排序过程，我们回到onMeasure()方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// …… </span></span><br><span class="line">        <span class="keyword">int</span> myWidth = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> myHeight = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> width = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> heightSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Record our dimensions if they are known;</span></span><br><span class="line">        <span class="keyword">if</span> (widthMode != MeasureSpec.UNSPECIFIED) &#123;</span><br><span class="line">            myWidth = widthSize;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (heightMode != MeasureSpec.UNSPECIFIED) &#123;</span><br><span class="line">            myHeight = heightSize;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (widthMode == MeasureSpec.EXACTLY) &#123;</span><br><span class="line">            width = myWidth;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (heightMode == MeasureSpec.EXACTLY) &#123;</span><br><span class="line">            height = myHeight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        View ignore = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> gravity = mGravity &amp; Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> horizontalGravity = gravity != Gravity.START &amp;&amp; gravity != <span class="number">0</span>;</span><br><span class="line">        gravity = mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> verticalGravity = gravity != Gravity.TOP &amp;&amp; gravity != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> top = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> right = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> bottom = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> offsetHorizontalAxis = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> offsetVerticalAxis = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((horizontalGravity || verticalGravity) &amp;&amp; mIgnoreGravity != View.NO_ID) &#123;</span><br><span class="line">            ignore = findViewById(mIgnoreGravity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isWrapContentWidth = widthMode != MeasureSpec.EXACTLY;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isWrapContentHeight = heightMode != MeasureSpec.EXACTLY;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We need to know our size for doing the correct computation of children positioning in RTL</span></span><br><span class="line">        <span class="comment">// mode but there is no practical way to get it instead of running the code below.</span></span><br><span class="line">        <span class="comment">// So, instead of running the code twice, we just set the width to a &quot;default display width&quot;</span></span><br><span class="line">        <span class="comment">// before the computation and then, as a last pass, we will update their real position with</span></span><br><span class="line">        <span class="comment">// an offset equals to &quot;DEFAULT_WIDTH - width&quot;.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = getLayoutDirection();</span><br><span class="line">        <span class="keyword">if</span> (isLayoutRtl() &amp;&amp; myWidth == -<span class="number">1</span>) &#123;</span><br><span class="line">            myWidth = DEFAULT_WIDTH;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中间这段是一些辅助变量的初始化，就不多说了，继续往下看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// …… </span></span><br><span class="line">        View[] views = mSortedHorizontalChildren;</span><br><span class="line">        <span class="keyword">int</span> count = views.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            View child = views[i];</span><br><span class="line">            <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">                LayoutParams params = (LayoutParams) child.getLayoutParams();</span><br><span class="line">                <span class="keyword">int</span>[] rules = params.getRules(layoutDirection);</span><br><span class="line"></span><br><span class="line">                applyHorizontalSizeRules(params, myWidth, rules);</span><br><span class="line">                measureChildHorizontal(child, params, myWidth, myHeight);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (positionChildHorizontal(child, params, myWidth, isWrapContentWidth)) &#123;</span><br><span class="line">                    offsetHorizontalAxis = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测量过程的第二步是遍历子View进行水平方向的依赖测量</strong>，这一步通过3个函数进行，逐个看下函数的实现。</p>
<p>介绍函数实现之前先介绍一下rule的概念，在RelativeLayout.LayoutParams进行解析时，会将RelativeLayout中的子View的依赖关系通过rules数组存储起来，数组中的下标代表某条规则，例如LEFT_OF，对应的元素代表这条规则依赖的View id：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (attr) &#123;</span><br><span class="line">     <span class="keyword">case</span> com.android.internal.R.styleable.RelativeLayout_Layout_layout_toLeftOf:</span><br><span class="line">           rules[LEFT_OF] = a.getResourceId(attr, <span class="number">0</span>);</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">                    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>了解了rule的概念之后，看下遍历子View进行依赖测量时相关方法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applyHorizontalSizeRules</span><span class="params">(LayoutParams childParams, <span class="keyword">int</span> myWidth, <span class="keyword">int</span>[] rules)</span> </span>&#123;</span><br><span class="line">        RelativeLayout.LayoutParams anchorParams;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// VALUE_NOT_SET indicates a &quot;soft requirement&quot; in that direction. For example:</span></span><br><span class="line">        <span class="comment">// left=10, right=VALUE_NOT_SET means the view must start at 10, but can go as far as it</span></span><br><span class="line">        <span class="comment">// wants to the right</span></span><br><span class="line">        <span class="comment">// left=VALUE_NOT_SET, right=10 means the view must end at 10, but can go as far as it</span></span><br><span class="line">        <span class="comment">// wants to the left</span></span><br><span class="line">        <span class="comment">// left=10, right=20 means the left and right ends are both fixed</span></span><br><span class="line">        childParams.mLeft = VALUE_NOT_SET;</span><br><span class="line">        childParams.mRight = VALUE_NOT_SET;</span><br><span class="line"></span><br><span class="line">        anchorParams = getRelatedViewParams(rules, LEFT_OF);</span><br><span class="line">        <span class="keyword">if</span> (anchorParams != <span class="keyword">null</span>) &#123;</span><br><span class="line">            childParams.mRight = anchorParams.mLeft - (anchorParams.leftMargin +</span><br><span class="line">                    childParams.rightMargin);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childParams.alignWithParent &amp;&amp; rules[LEFT_OF] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (myWidth &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                childParams.mRight = myWidth - mPaddingRight - childParams.rightMargin;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        anchorParams = getRelatedViewParams(rules, RIGHT_OF);</span><br><span class="line">        <span class="keyword">if</span> (anchorParams != <span class="keyword">null</span>) &#123;</span><br><span class="line">            childParams.mLeft = anchorParams.mRight + (anchorParams.rightMargin +</span><br><span class="line">                    childParams.leftMargin);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childParams.alignWithParent &amp;&amp; rules[RIGHT_OF] != <span class="number">0</span>) &#123;</span><br><span class="line">            childParams.mLeft = mPaddingLeft + childParams.leftMargin;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        anchorParams = getRelatedViewParams(rules, ALIGN_LEFT);</span><br><span class="line">        <span class="keyword">if</span> (anchorParams != <span class="keyword">null</span>) &#123;</span><br><span class="line">            childParams.mLeft = anchorParams.mLeft + childParams.leftMargin;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childParams.alignWithParent &amp;&amp; rules[ALIGN_LEFT] != <span class="number">0</span>) &#123;</span><br><span class="line">            childParams.mLeft = mPaddingLeft + childParams.leftMargin;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        anchorParams = getRelatedViewParams(rules, ALIGN_RIGHT);</span><br><span class="line">        <span class="keyword">if</span> (anchorParams != <span class="keyword">null</span>) &#123;</span><br><span class="line">            childParams.mRight = anchorParams.mRight - childParams.rightMargin;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childParams.alignWithParent &amp;&amp; rules[ALIGN_RIGHT] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (myWidth &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                childParams.mRight = myWidth - mPaddingRight - childParams.rightMargin;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != rules[ALIGN_PARENT_LEFT]) &#123;</span><br><span class="line">            childParams.mLeft = mPaddingLeft + childParams.leftMargin;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != rules[ALIGN_PARENT_RIGHT]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (myWidth &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                childParams.mRight = myWidth - mPaddingRight - childParams.rightMargin;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>纵观整个函数，其实就是对水平方向的几条规则逐个进行处理，这几条规则分别是：LEFT_OF/RIGHT_OF/ALIGN_LEFT/ALIGN_RIGHT/ALIGN_PARENT_LEFT/ALIGN_PARENT_RIGHT；<br>对于每个属性的处理方法都是相似的：通过相应的规则从getRelativeViewParams中取到对应依赖的View，然后通过依赖的View的对应属性和padding来调整该View的对应属性<br>看看下getRelativeViewParams的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> LayoutParams <span class="title">getRelatedViewParams</span><span class="params">(<span class="keyword">int</span>[] rules, <span class="keyword">int</span> relation)</span> </span>&#123;</span><br><span class="line">        View v = getRelatedView(rules, relation);</span><br><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ViewGroup.LayoutParams params = v.getLayoutParams();</span><br><span class="line">            <span class="keyword">if</span> (params <span class="keyword">instanceof</span> LayoutParams) &#123;</span><br><span class="line">                <span class="keyword">return</span> (LayoutParams) v.getLayoutParams();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>真正的实现在getRelatedView中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> View <span class="title">getRelatedView</span><span class="params">(<span class="keyword">int</span>[] rules, <span class="keyword">int</span> relation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> id = rules[relation];</span><br><span class="line">        <span class="keyword">if</span> (id != <span class="number">0</span>) &#123;</span><br><span class="line">            DependencyGraph.Node node = mGraph.mKeyNodes.get(id);</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            View v = node.view;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Find the first non-GONE view up the chain</span></span><br><span class="line">            <span class="keyword">while</span> (v.getVisibility() == View.GONE) &#123;</span><br><span class="line">                rules = ((LayoutParams) v.getLayoutParams()).getRules(v.getLayoutDirection());</span><br><span class="line">                node = mGraph.mKeyNodes.get((rules[relation]));</span><br><span class="line">                <span class="comment">// ignore self dependency. for more info look in git commit: da3003</span></span><br><span class="line">                <span class="keyword">if</span> (node == <span class="keyword">null</span> || v == node.view) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                v = node.view;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>关键点：</p>
<ul>
<li>通过rules数组取到对应依赖的View id</li>
<li>通过View id从依赖图中取出对应的View</li>
<li>如果取到的View可见性为GONE，则继续通过对应的依赖规则取依赖的View所依赖的View(有点拗口…)</li>
</ul>
<p>经过applyHorizontalSizeRules方法的处理之后，子View的params中的left/right值都已经确定好，然后会进入measureChildHorizontal方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">measureChildHorizontal</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            View child, LayoutParams params, <span class="keyword">int</span> myWidth, <span class="keyword">int</span> myHeight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(params.mLeft, params.mRight,</span><br><span class="line">                params.width, params.leftMargin, params.rightMargin, mPaddingLeft, mPaddingRight,</span><br><span class="line">                myWidth);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec;</span><br><span class="line">        <span class="keyword">if</span> (myHeight &lt; <span class="number">0</span> &amp;&amp; !mAllowBrokenMeasureSpecs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (params.height &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                        params.height, MeasureSpec.EXACTLY);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Negative values in a mySize/myWidth/myWidth value in</span></span><br><span class="line">                <span class="comment">// RelativeLayout measurement is code for, &quot;we got an</span></span><br><span class="line">                <span class="comment">// unspecified mode in the RelativeLayout&#x27;s measure spec.&quot;</span></span><br><span class="line">                <span class="comment">// Carry it forward.</span></span><br><span class="line">                childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(<span class="number">0</span>, MeasureSpec.UNSPECIFIED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> maxHeight;</span><br><span class="line">            <span class="keyword">if</span> (mMeasureVerticalWithPaddingMargin) &#123;</span><br><span class="line">                maxHeight = Math.max(<span class="number">0</span>, myHeight - mPaddingTop - mPaddingBottom</span><br><span class="line">                        - params.topMargin - params.bottomMargin);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxHeight = Math.max(<span class="number">0</span>, myHeight);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> heightMode;</span><br><span class="line">            <span class="keyword">if</span> (params.height == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                heightMode = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                heightMode = MeasureSpec.AT_MOST;</span><br><span class="line">            &#125;</span><br><span class="line">            childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(maxHeight, heightMode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在上一阶段我们确定了子View的left/right参数，在这一阶段，可以通过left/right得到子View的宽度，然后进行第一次子View的measure方法调用，进行第一次测量</p>
<p>接下来调用positionChildHorizontal方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">positionChildHorizontal</span><span class="params">(View child, LayoutParams params, <span class="keyword">int</span> myWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> wrapContent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = getLayoutDirection();</span><br><span class="line">        <span class="keyword">int</span>[] rules = params.getRules(layoutDirection);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (params.mLeft == VALUE_NOT_SET &amp;&amp; params.mRight != VALUE_NOT_SET) &#123;</span><br><span class="line">            <span class="comment">// Right is fixed, but left varies</span></span><br><span class="line">            params.mLeft = params.mRight - child.getMeasuredWidth();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params.mLeft != VALUE_NOT_SET &amp;&amp; params.mRight == VALUE_NOT_SET) &#123;</span><br><span class="line">            <span class="comment">// Left is fixed, but right varies</span></span><br><span class="line">            params.mRight = params.mLeft + child.getMeasuredWidth();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params.mLeft == VALUE_NOT_SET &amp;&amp; params.mRight == VALUE_NOT_SET) &#123;</span><br><span class="line">            <span class="comment">// Both left and right vary</span></span><br><span class="line">            <span class="keyword">if</span> (rules[CENTER_IN_PARENT] != <span class="number">0</span> || rules[CENTER_HORIZONTAL] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!wrapContent) &#123;</span><br><span class="line">                    centerHorizontal(child, params, myWidth);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    positionAtEdge(child, params, myWidth);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// This is the default case. For RTL we start from the right and for LTR we start</span></span><br><span class="line">                <span class="comment">// from the left. This will give LEFT/TOP for LTR and RIGHT/TOP for RTL.</span></span><br><span class="line">                positionAtEdge(child, params, myWidth);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rules[ALIGN_PARENT_END] != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的代码不长，从实现中可以得知，该方法的作用在于，那些在前阶段没有设置的左右边界约束。</p>
<p><strong>接下来是第三步，遍历子View进行垂直方向的依赖测量</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ……</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = views[i];</span><br><span class="line">            <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">                <span class="keyword">final</span> LayoutParams params = (LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">                applyVerticalSizeRules(params, myHeight, child.getBaseline());</span><br><span class="line">                measureChild(child, params, myWidth, myHeight);</span><br><span class="line">                <span class="keyword">if</span> (positionChildVertical(child, params, myHeight, isWrapContentHeight)) &#123;</span><br><span class="line">                    offsetVerticalAxis = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isWrapContentWidth) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isLayoutRtl()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">                            width = Math.max(width, myWidth - params.mLeft);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            width = Math.max(width, myWidth - params.mLeft + params.leftMargin);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">                            width = Math.max(width, params.mRight);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            width = Math.max(width, params.mRight + params.rightMargin);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isWrapContentHeight) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">                        height = Math.max(height, params.mBottom);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        height = Math.max(height, params.mBottom + params.bottomMargin);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (child != ignore || verticalGravity) &#123;</span><br><span class="line">                    left = Math.min(left, params.mLeft - params.leftMargin);</span><br><span class="line">                    top = Math.min(top, params.mTop - params.topMargin);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (child != ignore || horizontalGravity) &#123;</span><br><span class="line">                    right = Math.max(right, params.mRight + params.rightMargin);</span><br><span class="line">                    bottom = Math.max(bottom, params.mBottom + params.bottomMargin);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>垂直方向的约束测量过程和水平方向是一个套路：</p>
<ul>
<li>遍历子View，根据垂直方向的规则进行top/bottom的约束</li>
<li>测量一次子View</li>
<li>补充边界约束</li>
<li>不同的是，在垂直方向的测量阶段，还会对RelativeLayout的最大宽度和最大高度进行计算</li>
</ul>
<p><strong>经过水平和垂直方向两轮对子View的分发测量，已经完成了子View的测量过程，接下来是根据是否wrapContent调整RelativeLayout自身的高度</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isWrapContentWidth) &#123;</span><br><span class="line">        <span class="comment">// Width already has left padding in it since it was calculated by looking at</span></span><br><span class="line">        <span class="comment">// the right of each child view</span></span><br><span class="line">        width += mPaddingRight;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mLayoutParams != <span class="keyword">null</span> &amp;&amp; mLayoutParams.width &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            width = Math.max(width, mLayoutParams.width);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        width = Math.max(width, getSuggestedMinimumWidth());</span><br><span class="line">        width = resolveSize(width, widthMeasureSpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (offsetHorizontalAxis) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> View child = views[i];</span><br><span class="line">                <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">                    <span class="keyword">final</span> LayoutParams params = (LayoutParams) child.getLayoutParams();</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span>[] rules = params.getRules(layoutDirection);</span><br><span class="line">                    <span class="keyword">if</span> (rules[CENTER_IN_PARENT] != <span class="number">0</span> || rules[CENTER_HORIZONTAL] != <span class="number">0</span>) &#123;</span><br><span class="line">                        centerHorizontal(child, params, width);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rules[ALIGN_PARENT_RIGHT] != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> childWidth = child.getMeasuredWidth();</span><br><span class="line">                        params.mLeft = width - mPaddingRight - childWidth;</span><br><span class="line">                        params.mRight = params.mLeft + childWidth;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isWrapContentHeight) &#123;</span><br><span class="line">        <span class="comment">// Height already has top padding in it since it was calculated by looking at</span></span><br><span class="line">        <span class="comment">// the bottom of each child view</span></span><br><span class="line">        height += mPaddingBottom;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mLayoutParams != <span class="keyword">null</span> &amp;&amp; mLayoutParams.height &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            height = Math.max(height, mLayoutParams.height);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        height = Math.max(height, getSuggestedMinimumHeight());</span><br><span class="line">        height = resolveSize(height, heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (offsetVerticalAxis) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> View child = views[i];</span><br><span class="line">                <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">                    <span class="keyword">final</span> LayoutParams params = (LayoutParams) child.getLayoutParams();</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span>[] rules = params.getRules(layoutDirection);</span><br><span class="line">                    <span class="keyword">if</span> (rules[CENTER_IN_PARENT] != <span class="number">0</span> || rules[CENTER_VERTICAL] != <span class="number">0</span>) &#123;</span><br><span class="line">                        centerVertical(child, params, height);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rules[ALIGN_PARENT_BOTTOM] != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</span><br><span class="line">                        params.mTop = height - mPaddingBottom - childHeight;</span><br><span class="line">                        params.mBottom = params.mTop + childHeight;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后再根据Gravity属性调整位置</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isWrapContentWidth) &#123;</span><br><span class="line">        <span class="comment">// Width already has left padding in it since it was calculated by looking at</span></span><br><span class="line">        <span class="comment">// the right of each child view</span></span><br><span class="line">        width += mPaddingRight;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mLayoutParams != <span class="keyword">null</span> &amp;&amp; mLayoutParams.width &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            width = Math.max(width, mLayoutParams.width);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        width = Math.max(width, getSuggestedMinimumWidth());</span><br><span class="line">        width = resolveSize(width, widthMeasureSpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (offsetHorizontalAxis) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> View child = views[i];</span><br><span class="line">                <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">                    <span class="keyword">final</span> LayoutParams params = (LayoutParams) child.getLayoutParams();</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span>[] rules = params.getRules(layoutDirection);</span><br><span class="line">                    <span class="keyword">if</span> (rules[CENTER_IN_PARENT] != <span class="number">0</span> || rules[CENTER_HORIZONTAL] != <span class="number">0</span>) &#123;</span><br><span class="line">                        centerHorizontal(child, params, width);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rules[ALIGN_PARENT_RIGHT] != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> childWidth = child.getMeasuredWidth();</span><br><span class="line">                        params.mLeft = width - mPaddingRight - childWidth;</span><br><span class="line">                        params.mRight = params.mLeft + childWidth;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isWrapContentHeight) &#123;</span><br><span class="line">        <span class="comment">// Height already has top padding in it since it was calculated by looking at</span></span><br><span class="line">        <span class="comment">// the bottom of each child view</span></span><br><span class="line">        height += mPaddingBottom;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mLayoutParams != <span class="keyword">null</span> &amp;&amp; mLayoutParams.height &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            height = Math.max(height, mLayoutParams.height);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        height = Math.max(height, getSuggestedMinimumHeight());</span><br><span class="line">        height = resolveSize(height, heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (offsetVerticalAxis) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> View child = views[i];</span><br><span class="line">                <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">                    <span class="keyword">final</span> LayoutParams params = (LayoutParams) child.getLayoutParams();</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span>[] rules = params.getRules(layoutDirection);</span><br><span class="line">                    <span class="keyword">if</span> (rules[CENTER_IN_PARENT] != <span class="number">0</span> || rules[CENTER_VERTICAL] != <span class="number">0</span>) &#123;</span><br><span class="line">                        centerVertical(child, params, height);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rules[ALIGN_PARENT_BOTTOM] != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</span><br><span class="line">                        params.mTop = height - mPaddingBottom - childHeight;</span><br><span class="line">                        params.mBottom = params.mTop + childHeight;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>最后就是设置自身的宽高，完成测量过程</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isLayoutRtl()) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> offsetWidth = myWidth - width;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">          <span class="keyword">final</span> View child = views[i];</span><br><span class="line">          <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">              <span class="keyword">final</span> LayoutParams params = (LayoutParams) child.getLayoutParams();</span><br><span class="line">              params.mLeft -= offsetWidth;</span><br><span class="line">              params.mRight -= offsetWidth;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setMeasuredDimension(width, height);</span><br></pre></td></tr></table></figure>
<p>上述就是onMeasure的过程。</p>
<h3 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  The layout has actually already been performed and the positions</span></span><br><span class="line">        <span class="comment">//  cached.  Apply the cached values to the children.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> count = getChildCount();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            View child = getChildAt(i);</span><br><span class="line">            <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">                RelativeLayout.LayoutParams st =</span><br><span class="line">                        (RelativeLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line">                child.layout(st.mLeft, st.mTop, st.mRight, st.mBottom);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>onLayout的过程很简单，遍历子View，因为子View在分发测量过程中已经确定了上下左右的边界约束，所以直接调用对应的约束值进行layout。</p>
<p>###onDraw<br>在RelativeLayout中，没有对onDraw进行重写。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>和大多数容器布局类似，RelativeLayout的核心在于测量阶段，需要遍历两次子View，原因是水平和垂直方向各需一次来确定相应方向的边界约束。</p>
]]></content>
      <tags>
        <tag>Android源码学习</tag>
      </tags>
  </entry>
  <entry>
    <title>View触摸事件传递源码学习</title>
    <url>/2021/04/13/View%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="起点"><a href="#起点" class="headerlink" title="起点"></a>起点</h3><p>事件传递，属于我们人与机器交互的范畴，因此选择交互的载体——Activity作为起点。<br>在Activity中与触摸事件相关的方法是dispatchTouchEvent(MotionEvent ev)与onTouchEvent(MotionEvent ev)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            onUserInteraction();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>解析</p>
<ul>
<li>判断事件类型，如果是<em>按下</em>事件，调用onUserInteraction()方法，这个方法在Activity中是一个空实现，表明我们可以根据需要重写这个方法的实现</li>
<li>调用该Activity对应的Window的superDispatchTouchEvent(MotionEvent ev)方法处理事件，如果该方法返回了true，证明事件被消费</li>
<li>如果上述Window的方法返回了false，证明事件没有被消费，此时由Activity的onTouchEvent(MotionEvent ev)方法来消费；</li>
</ul>
<h3 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h3><p>调用Activity的dispatchTouchEvent(MotionEvent ev)方法之后，会调用到对应Window的superDispatchTouchEvent(MotionEvent ev)方法，根据Window类的注释说明，Window类唯一的实现类是PhoneWindow，因此直接到<em>PhoneWindow</em>中看其实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用的是其mDecor的同名方法，mDecor类型是DecorView，再到<em>DecorView</em>中看下它的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用的实际上是父类的dispatchTouchEvent(MotionEvent ev)实现，DecorView的父类是FrameLayout，但FrameLayout自身没有实现这个方法，因此调用的是FrameLayout的父类ViewGroup的方法，在ViewGroup中，dispatchTouchEvent(MotionEvent ev)方法是真正的处理事件的地方，在开始这部分源码阅读之前，先小结一下触摸事件是怎么传递到ViewGroup的：<br><strong>Activity –&gt; PhoneWindow –&gt; DecorView –&gt; ViewGroup</strong></p>
<h3 id="ViewGroup的dispatchTouchEvent-MotionEvent-ev-方法"><a href="#ViewGroup的dispatchTouchEvent-MotionEvent-ev-方法" class="headerlink" title="ViewGroup的dispatchTouchEvent(MotionEvent ev)方法"></a>ViewGroup的dispatchTouchEvent(MotionEvent ev)方法</h3><p>这个方法的实现比较长，主要分成以下阶段来分析：</p>
<h5 id="是否拦截"><a href="#是否拦截" class="headerlink" title="是否拦截"></a>是否拦截</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mInputEventConsistencyVerifier.onTouchEvent(ev, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123;</span><br><span class="line">            ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">                cancelAndClearTouchTargets(ev);</span><br><span class="line">                resetTouchState();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关键代码，判断是否拦截</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                    || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 判断子View是否不允许该父类拦截</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">                    intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                    ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    intercepted = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                intercepted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (intercepted || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，最关键的两点：</p>
<ul>
<li>判断disallowIntercept，即子类是否允许父类拦截</li>
<li>调用onInterceptTouchEvent(MotionEvent ev)，确定拦截判定为true或者false，可想而知，如果为true的话，该事件将不再向子类分发，在ViewGroup中，onInterceptTouchEvent(MotionEvent ev)是有默认实现的：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ev.isFromSource(InputDevice.SOURCE_MOUSE)</span><br><span class="line">                &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN</span><br><span class="line">                &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)</span><br><span class="line">                &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
在特定的4种场景下，事件会被拦截</li>
</ul>
<h5 id="向下分发"><a href="#向下分发" class="headerlink" title="向下分发"></a>向下分发</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">       ……</span><br><span class="line">            <span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">                View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()</span><br><span class="line">                        ? findChildWithAccessibilityFocus() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                        || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">                        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex(); <span class="comment">// always 0 for down</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> idBitsToAssign = split ? <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex)</span><br><span class="line">                            : TouchTarget.ALL_POINTER_IDS;</span><br><span class="line"></span><br><span class="line">               </span><br><span class="line">                    removePointersFromTouchTargets(idBitsToAssign);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">                    <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(actionIndex);</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(actionIndex);</span><br><span class="line">                      <span class="comment">// 关键代码1，构建子View遍历列表</span></span><br><span class="line">                        <span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = preorderedList == <span class="keyword">null</span></span><br><span class="line">                                &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line">                        <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                            <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(</span><br><span class="line">                                    childrenCount, i, customOrder);</span><br><span class="line">                            <span class="keyword">final</span> View child = getAndVerifyPreorderedView(</span><br><span class="line">                                    preorderedList, children, childIndex);</span><br><span class="line">                      </span><br><span class="line">                            <span class="keyword">if</span> (childWithAccessibilityFocus != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (childWithAccessibilityFocus != child) &#123;</span><br><span class="line">                                    <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                childWithAccessibilityFocus = <span class="keyword">null</span>;</span><br><span class="line">                                i = childrenCount - <span class="number">1</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 关键代码2，两个条件分别是是否可以接收触摸事件和触摸点坐标是否在View内</span></span><br><span class="line">                            <span class="comment">// 如果有其中1个条件不满足，就继续找下一个View；否则说明找到目标子View</span></span><br><span class="line">                            <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">                                    || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                                ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            newTouchTarget = getTouchTarget(child);</span><br><span class="line">                            <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            resetCancelNextUpFlag(child);</span><br><span class="line">                            <span class="comment">// 关键代码3，找到目标子View之后调用该方法进行处理</span></span><br><span class="line">                            <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                                mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                                <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                                        <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                                            mLastTouchDownIndex = j;</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    mLastTouchDownIndex = childIndex;</span><br><span class="line">                                &#125;</span><br><span class="line">                                mLastTouchDownX = ev.getX();</span><br><span class="line">                                mLastTouchDownY = ev.getY();</span><br><span class="line">                                 <span class="comment">// 关键代码4，处理了Action.Down事件的View加入到链表中</span></span><br><span class="line">                                newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                                alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) preorderedList.clear();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        newTouchTarget = mFirstTouchTarget;</span><br><span class="line">                        <span class="keyword">while</span> (newTouchTarget.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            newTouchTarget = newTouchTarget.next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 关键代码5，这时证明还没有子View处理事件，调用该方法来自己处理</span></span><br><span class="line">                handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">                        TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                TouchTarget predecessor = <span class="keyword">null</span>;</span><br><span class="line">                TouchTarget target = mFirstTouchTarget;</span><br><span class="line">                <span class="comment">// 关键代码6，不断从链表中取出子View对应的节点，进行Action.Down以外的事件分发</span></span><br><span class="line">                <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">                    <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">                        handled = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                                || intercepted;</span><br><span class="line">                        <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                                target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                            handled = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (cancelChild) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (predecessor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                mFirstTouchTarget = next;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                predecessor.next = next;</span><br><span class="line">                            &#125;</span><br><span class="line">                            target.recycle();</span><br><span class="line">                            target = next;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    predecessor = target;</span><br><span class="line">                    target = next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (canceled</span><br><span class="line">                    || actionMasked == MotionEvent.ACTION_UP</span><br><span class="line">                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">                resetTouchState();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex();</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> idBitsToRemove = <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex);</span><br><span class="line">                removePointersFromTouchTargets(idBitsToRemove);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!handled &amp;&amp; mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mInputEventConsistencyVerifier.onUnhandledEvent(ev, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这一段代码比较长，但抓住注释中的6处关键代码即可把握整体流程：</p>
<ul>
<li>构建子View的遍历列表</li>
<li>遍历子View，找到可以处理ACTION_DOWN的View</li>
<li>调用dispatchTransformedTouchEvent方法将事件分发到子View上进行处理</li>
<li>对所有处理了ACTION_DOWN方法的子View加入到一个链表中</li>
<li>如果没有子View处理过ACTION_DOWN方法，则调用dispatchTransformTouchEvent来分发给自身来处理</li>
<li>如果有子View处理过ACTION_DOWN方法，则不断从链表中取出子View，进行其余正常事件的分发</li>
</ul>
<h5 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h5><p>由上述代码可以得知，无论是找到了子View让其处理，还是没有子View处理而自身处理，都是通过调用dispatchTransformedTouchEvent方法进行的，来看下这个方法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></span><br><span class="line"><span class="function"><span class="params">            View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</span><br><span class="line">        <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">            event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">                handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handled = child.dispatchTouchEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line">            event.setAction(oldAction);</span><br><span class="line">            <span class="keyword">return</span> handled;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldPointerIdBits = event.getPointerIdBits();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newPointerIdBits == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">final</span> MotionEvent transformedEvent;</span><br><span class="line">        <span class="keyword">if</span> (newPointerIdBits == oldPointerIdBits) &#123;</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="keyword">null</span> || child.hasIdentityMatrix()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</span><br><span class="line">                    event.offsetLocation(offsetX, offsetY);</span><br><span class="line"></span><br><span class="line">                    handled = child.dispatchTouchEvent(event);</span><br><span class="line"></span><br><span class="line">                    event.offsetLocation(-offsetX, -offsetY);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> handled;</span><br><span class="line">            &#125;</span><br><span class="line">            transformedEvent = MotionEvent.obtain(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            transformedEvent = event.split(newPointerIdBits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            handled = <span class="keyword">super</span>.dispatchTouchEvent(transformedEvent);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</span><br><span class="line">            transformedEvent.offsetLocation(offsetX, offsetY);</span><br><span class="line">            <span class="keyword">if</span> (! child.hasIdentityMatrix()) &#123;</span><br><span class="line">                transformedEvent.transform(child.getInverseMatrix());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            handled = child.dispatchTouchEvent(transformedEvent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        transformedEvent.recycle();</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法乍一看内容比较多，但其实返回的handled值，归根到底就是一个if-else：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">    handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    handled = child.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此这段函数要么就是调用子View的dispatchTouchEvent()，要么就是调用父类的dispatchTouchEvent()，而无论是调用子View还是父类，最终都会调用到View类的这个方法实现；因此接下来看下View类中dispatchTouchEvent()的源码：</p>
<h5 id="View类的dispatchTouchEvent方法"><a href="#View类的dispatchTouchEvent方法" class="headerlink" title="View类的dispatchTouchEvent方法"></a>View类的dispatchTouchEvent方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (event.isTargetAccessibilityFocus()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isAccessibilityFocusedViewOrHost()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;        </span><br><span class="line">            event.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mInputEventConsistencyVerifier.onTouchEvent(event, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = event.getActionMasked();</span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">           </span><br><span class="line">            stopNestedScroll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</span><br><span class="line">                result = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">            ListenerInfo li = mListenerInfo;</span><br><span class="line">            <span class="comment">// 关键代码1，是否设置了onTouchListener，并且消费</span></span><br><span class="line">            <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">                    &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line">                result = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 关键代码2，调用自身的onTouchEvent()决定是否消费</span></span><br><span class="line">            <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">                result = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!result &amp;&amp; mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mInputEventConsistencyVerifier.onUnhandledEvent(event, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_UP ||</span><br><span class="line">                actionMasked == MotionEvent.ACTION_CANCEL ||</span><br><span class="line">                (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123;</span><br><span class="line">            stopNestedScroll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>View类的dispatchTouchEvent方法并不长，而且代码核心在于注释的2处：</p>
<ul>
<li>首先看该View是否设置了onTouchListener，调用其onTouch(MotionEvent ev)方法，如果onTouchListener的onTouch方法消费了该方法；则View自身的onTouchEvent(MotionEvent ev)方法将不被调用；</li>
<li>如果没有设置onTouchListener或者onTouchListener的onTouch(MotionEvent ev)方法没有消费事件，则调用View自身的onTouchEvent()方法</li>
</ul>
<h5 id="View的onTouchEvent方法"><a href="#View的onTouchEvent方法" class="headerlink" title="View的onTouchEvent方法"></a>View的onTouchEvent方法</h5><p>根据上述流程可以得到，如果触摸事件的整个传递过程中，没有被拦截也没有被onTouchListener消费的话，最终将走到View的onTouchEvent(MotionEvent ev)方法中执行，接下来看下View的onTouchEvent方法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> x = event.getX();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> y = event.getY();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> action = event.getAction();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE</span><br><span class="line">                || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</span><br><span class="line">                || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</span><br><span class="line">                setPressed(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class="line">            <span class="keyword">return</span> clickable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关键代码1，是否设置了TouchDelegate并且onTouchEvent()方法消费了该事件</span></span><br><span class="line">        <span class="keyword">if</span> (mTouchDelegate != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mTouchDelegate.onTouchEvent(event)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关键代码2，该View是否可以被点击</span></span><br><span class="line">        <span class="keyword">if</span> (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">                <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                    mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class="line">                    <span class="keyword">if</span> ((viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class="line">                        handleTooltipUp();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!clickable) &#123;</span><br><span class="line">                        removeTapCallback();</span><br><span class="line">                        removeLongPressCallback();</span><br><span class="line">                        mInContextButtonPress = <span class="keyword">false</span>;</span><br><span class="line">                        mHasPerformedLongPress = <span class="keyword">false</span>;</span><br><span class="line">                        mIgnoreNextUpEvent = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">boolean</span> prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span> || prepressed) &#123;</span><br><span class="line">                        <span class="keyword">boolean</span> focusTaken = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">if</span> (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</span><br><span class="line">                            focusTaken = requestFocus();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (prepressed) &#123;</span><br><span class="line">                            setPressed(<span class="keyword">true</span>, x, y);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</span><br><span class="line">                            removeLongPressCallback();</span><br><span class="line">                            <span class="keyword">if</span> (!focusTaken) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    mPerformClick = <span class="keyword">new</span> PerformClick();</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (!post(mPerformClick)) &#123;</span><br><span class="line">                                    <span class="comment">// 关键代码3，进行单击操作</span></span><br><span class="line">                                    performClickInternal();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (mUnsetPressedState == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            mUnsetPressedState = <span class="keyword">new</span> UnsetPressedState();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (prepressed) &#123;</span><br><span class="line">                            postDelayed(mUnsetPressedState,</span><br><span class="line">                                    ViewConfiguration.getPressedStateDuration());</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!post(mUnsetPressedState)) &#123;</span><br><span class="line">                            mUnsetPressedState.run();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        removeTapCallback();</span><br><span class="line">                    &#125;</span><br><span class="line">                    mIgnoreNextUpEvent = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                    <span class="keyword">if</span> (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) &#123;</span><br><span class="line">                        mPrivateFlags3 |= PFLAG3_FINGER_DOWN;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mHasPerformedLongPress = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!clickable) &#123;</span><br><span class="line">                        checkForLongClick(<span class="number">0</span>, x, y);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (performButtonActionOnTouchDown(event)) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">boolean</span> isInScrollingContainer = isInScrollingContainer();</span><br><span class="line">                    <span class="keyword">if</span> (isInScrollingContainer) &#123;</span><br><span class="line">                        mPrivateFlags |= PFLAG_PREPRESSED;</span><br><span class="line">                        <span class="keyword">if</span> (mPendingCheckForTap == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            mPendingCheckForTap = <span class="keyword">new</span> CheckForTap();</span><br><span class="line">                        &#125;</span><br><span class="line">                        mPendingCheckForTap.x = event.getX();</span><br><span class="line">                        mPendingCheckForTap.y = event.getY();</span><br><span class="line">                        postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        setPressed(<span class="keyword">true</span>, x, y);</span><br><span class="line">                        <span class="comment">// 关键代码4，进行长按检测</span></span><br><span class="line">                        checkForLongClick(<span class="number">0</span>, x, y);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">                    <span class="keyword">if</span> (clickable) &#123;</span><br><span class="line">                        setPressed(<span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    removeTapCallback();</span><br><span class="line">                    removeLongPressCallback();</span><br><span class="line">                    mInContextButtonPress = <span class="keyword">false</span>;</span><br><span class="line">                    mHasPerformedLongPress = <span class="keyword">false</span>;</span><br><span class="line">                    mIgnoreNextUpEvent = <span class="keyword">false</span>;</span><br><span class="line">                    mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                    <span class="keyword">if</span> (clickable) &#123;</span><br><span class="line">                        drawableHotspotChanged(x, y);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!pointInView(x, y, mTouchSlop)) &#123;</span><br><span class="line">                        removeTapCallback();</span><br><span class="line">                        removeLongPressCallback();</span><br><span class="line">                        <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</span><br><span class="line">                            setPressed(<span class="keyword">false</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>View的onTouchEvent()方法也并不长，主要是分成DOWN/UP/MOVE/CANCEL这4种case进行处理，其中的几处关键代码分别是：</p>
<ul>
<li>关键代码1会判断是否设置了onTouchDelegate，如果设置了，将优先被delegate处理</li>
<li>如果没有delegate或者delegate没有处理，将判断view是否可点击，可点击将走进这个if代码块，注意到这个if代码块最终是return true的</li>
<li>关键代码3，在ACTION_UP中进行单击操作performClickInternal()</li>
<li>关键代码4，在ACTION_DOWN中进行长按检测，如果检测到是长按，则进行长按回调</li>
</ul>
<h5 id="单击和长按的处理函数"><a href="#单击和长按的处理函数" class="headerlink" title="单击和长按的处理函数"></a>单击和长按的处理函数</h5><p>在View中，处理单击和长按的函数分别是perfromClick()和performLongClickInternal()，最后分别看下这两个函数的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        notifyAutofillManagerOnClick();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> result;</span><br><span class="line">        <span class="keyword">final</span> ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnClickListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            playSoundEffect(SoundEffectConstants.CLICK);</span><br><span class="line">            <span class="comment">// 关键代码，调用监听器的onClick</span></span><br><span class="line">            li.mOnClickListener.onClick(<span class="keyword">this</span>);</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</span><br><span class="line"></span><br><span class="line">        notifyEnterOrExitForAutoFillIfNeeded(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">performLongClickInternal</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span> </span>&#123;</span><br><span class="line">        sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_LONG_CLICKED);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLongClickListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 关键代码，调用监听器的onLongClick</span></span><br><span class="line">            handled = li.mOnLongClickListener.onLongClick(View.<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!handled) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> isAnchored = !Float.isNaN(x) &amp;&amp; !Float.isNaN(y);</span><br><span class="line">            handled = isAnchored ? showContextMenu(x, y) : showContextMenu();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((mViewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!handled) &#123;</span><br><span class="line">                handled = showLongClickTooltip((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (handled) &#123;</span><br><span class="line">            performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，对单击和长按的最终处理，是通过调用相应Listener的对应方法来进行的。</p>
]]></content>
      <tags>
        <tag>Android源码学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Android AbsoluteLayout源码学习</title>
    <url>/2021/04/16/Android-AbsoluteLayout%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="OverView"><a href="#OverView" class="headerlink" title="OverView"></a>OverView</h3><p>Android AbsoluteLayout是Android六大布局之一，但目前已经处于Deprecated状态，废弃的原因在于，绝对布局使用的是绝对坐标进行定位，而Android的屏幕大小各种各样，使用绝对坐标必然在兼容性上有极大问题。尽管如此，还是了解一下其实现。（整个类代码也不足300行）</p>
<h3 id="继承层次及构造函数"><a href="#继承层次及构造函数" class="headerlink" title="继承层次及构造函数"></a>继承层次及构造函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsoluteLayout</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span></span></span><br></pre></td></tr></table></figure>
<p>AbsoluteLayout也是继承自ViewGroup，在六大布局中，只有TableLayout是继承自LinearLayout，其余均继承自ViewGroup</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbsoluteLayout</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbsoluteLayout</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbsoluteLayout</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, attrs, defStyleAttr, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbsoluteLayout</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, attrs, defStyleAttr, defStyleRes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbsoluteLayout的4个构造函数，便是最简单的1个入参至4个入参的实现，最终调用到的是父类即ViewGroup的构造方法，没有进行额外的操作。</p>
<h3 id="AbsoluteLayout-LayoutParams"><a href="#AbsoluteLayout-LayoutParams" class="headerlink" title="AbsoluteLayout.LayoutParams"></a>AbsoluteLayout.LayoutParams</h3><p>布局容器一般都有自己对应的LayoutParams，用于实现自己特定支持的布局方法，相比LinearLayout.LayoutParams和RelativeLayout.LayoutParams，AbsoluteLayout.LayoutParams的结构简单很多，因为只要支持x,y坐标即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LayoutParams</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span>.<span class="title">LayoutParams</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The horizontal, or X, location of the child within the view group.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@InspectableProperty(name = &quot;layout_x&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> x;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The vertical, or Y, location of the child within the view group.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@InspectableProperty(name = &quot;layout_y&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LayoutParams</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(width, height);</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LayoutParams</span><span class="params">(Context c, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(c, attrs);</span><br><span class="line">            TypedArray a = c.obtainStyledAttributes(attrs,</span><br><span class="line">                    com.android.internal.R.styleable.AbsoluteLayout_Layout);</span><br><span class="line">            x = a.getDimensionPixelOffset(</span><br><span class="line">                    com.android.internal.R.styleable.AbsoluteLayout_Layout_layout_x, <span class="number">0</span>);</span><br><span class="line">            y = a.getDimensionPixelOffset(</span><br><span class="line">                    com.android.internal.R.styleable.AbsoluteLayout_Layout_layout_y, <span class="number">0</span>);</span><br><span class="line">            a.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LayoutParams</span><span class="params">(ViewGroup.LayoutParams source)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(source);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">debug</span><span class="params">(String output)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> output + <span class="string">&quot;Absolute.LayoutParams=&#123;width=&quot;</span></span><br><span class="line">                    + sizeToString(width) + <span class="string">&quot;, height=&quot;</span> + sizeToString(height)</span><br><span class="line">                    + <span class="string">&quot; x=&quot;</span> + x + <span class="string">&quot; y=&quot;</span> + y + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面就是AbsoluteLayout.LayoutParams的全部代码，可以看到其构造函数也就是从xml中解析出x、y的值。</p>
<h3 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure()"></a>onMeasure()</h3><p>接下来看下AbsoluteLayout的onMeasure()函数实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = getChildCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxHeight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxWidth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find out how big everyone wants to be</span></span><br><span class="line">    measureChildren(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find rightmost and bottom-most child</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        View child = getChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">            <span class="keyword">int</span> childRight;</span><br><span class="line">            <span class="keyword">int</span> childBottom;</span><br><span class="line"></span><br><span class="line">            AbsoluteLayout.LayoutParams lp</span><br><span class="line">                    = (AbsoluteLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">            childRight = lp.x + child.getMeasuredWidth();</span><br><span class="line">            childBottom = lp.y + child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">            maxWidth = Math.max(maxWidth, childRight);</span><br><span class="line">            maxHeight = Math.max(maxHeight, childBottom);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Account for padding too</span></span><br><span class="line">    maxWidth += mPaddingLeft + mPaddingRight;</span><br><span class="line">    maxHeight += mPaddingTop + mPaddingBottom;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check against minimum height and width</span></span><br><span class="line">    maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());</span><br><span class="line">    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</span><br><span class="line">    </span><br><span class="line">    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, <span class="number">0</span>),</span><br><span class="line">            resolveSizeAndState(maxHeight, heightMeasureSpec, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中主要的点有：</p>
<ul>
<li>先调用一次measureChildren()，完成了对子View的测量</li>
<li>随后的for循环会遍历一次子View，其目的在于，通过子View的x坐标值加上子View的宽，能得到子View最右端的值，同理也可以通过y坐标和高得到最小的坐标值；遍历所有子View得到所有子View中最右和最下的的坐标，即AbsoluteLayout所需要的宽和高</li>
<li>最后通过setMeasureDimension把宽高设置进去</li>
</ul>
<h3 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout()"></a>onLayout()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = getChildCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        View child = getChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line"></span><br><span class="line">            AbsoluteLayout.LayoutParams lp =</span><br><span class="line">                    (AbsoluteLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> childLeft = mPaddingLeft + lp.x;</span><br><span class="line">            <span class="keyword">int</span> childTop = mPaddingTop + lp.y;</span><br><span class="line">            child.layout(childLeft, childTop,</span><br><span class="line">                    childLeft + child.getMeasuredWidth(),</span><br><span class="line">                    childTop + child.getMeasuredHeight());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbsoluteLayout的onLayout()方法则更加直观了，因为本来onLayout()方法传入的left/top/right/bottom参数，就是一种绝对坐标的形式，因此只要拿到x/y坐标，加上相应的宽高，即可得到onLayout所需的参数。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>AbsoluteLayout的测量阶段，确定自身宽高的方式是，先测量子View，然后遍历一次子View找到所有子View中最右和最下的坐标，即为父容器自身的宽高。</li>
</ul>
]]></content>
      <tags>
        <tag>Android源码学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Android GridLayout源码学习</title>
    <url>/2021/04/16/Android-GridLayout%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="OverView"><a href="#OverView" class="headerlink" title="OverView"></a>OverView</h3><p>FrameLayout也是Android开发中常用的布局之一，其特征是子View层层相叠，通过源码来了解其工作原理。</p>
<h3 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h3><p>一个布局容器的工作原理无非就是onMeasure()/onLayout()/onDraw()3个阶段的处理，先来直接看下onMeasure()的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = getChildCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> measureMatchParentChildren =</span><br><span class="line">            MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY ||</span><br><span class="line">            MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY;</span><br><span class="line">    mMatchParentChildren.clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxHeight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxWidth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> childState = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = getChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (mMeasureAllChildren || child.getVisibility() != GONE) &#123;</span><br><span class="line">            measureChildWithMargins(child, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">            maxWidth = Math.max(maxWidth,</span><br><span class="line">                    child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);</span><br><span class="line">            maxHeight = Math.max(maxHeight,</span><br><span class="line">                    child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);</span><br><span class="line">            childState = combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line">            <span class="keyword">if</span> (measureMatchParentChildren) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT ||</span><br><span class="line">                        lp.height == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                    mMatchParentChildren.add(child);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FrameLayout的onMeasure()过程比LinearLayout/RelativeLayout都要简洁，分成两部分，上面是第一部分的源码，其处理过程很简单：</p>
<ul>
<li>遍历一次子View，通过调用measureChildWithMargins()方法，完成了对子View的一次测量</li>
<li>随后会判断子View是否需要match_parent，如需要将加入到mMatchParentChildren集合中，待下一阶段处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">    count = mMatchParentChildren.size();</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = mMatchParentChildren.get(i);</span><br><span class="line">            <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec;</span><br><span class="line">            <span class="keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> width = Math.max(<span class="number">0</span>, getMeasuredWidth()</span><br><span class="line">                        - getPaddingLeftWithForeground() - getPaddingRightWithForeground()</span><br><span class="line">                        - lp.leftMargin - lp.rightMargin);</span><br><span class="line">                childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                        width, MeasureSpec.EXACTLY);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,</span><br><span class="line">                        getPaddingLeftWithForeground() + getPaddingRightWithForeground() +</span><br><span class="line">                        lp.leftMargin + lp.rightMargin,</span><br><span class="line">                        lp.width);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec;</span><br><span class="line">            <span class="keyword">if</span> (lp.height == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> height = Math.max(<span class="number">0</span>, getMeasuredHeight()</span><br><span class="line">                        - getPaddingTopWithForeground() - getPaddingBottomWithForeground()</span><br><span class="line">                        - lp.topMargin - lp.bottomMargin);</span><br><span class="line">                childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                        height, MeasureSpec.EXACTLY);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec,</span><br><span class="line">                        getPaddingTopWithForeground() + getPaddingBottomWithForeground() +</span><br><span class="line">                        lp.topMargin + lp.bottomMargin,</span><br><span class="line">                        lp.height);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在onMeasure()的第二部分，会将之前一次遍历中发现的需要将width或者height设置成match_parent的子View再进行一次处理，对其再进行一次正确宽高值的measure调用。</p>
<h3 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    layoutChildren(left, top, right, bottom, <span class="keyword">false</span> <span class="comment">/* no force left gravity */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void layoutChildren(int left, int top, int right, int bottom, boolean forceLeftGravity) &#123;</span><br><span class="line">    final int count &#x3D; getChildCount();</span><br><span class="line"></span><br><span class="line">    final int parentLeft &#x3D; getPaddingLeftWithForeground();</span><br><span class="line">    final int parentRight &#x3D; right - left - getPaddingRightWithForeground();</span><br><span class="line"></span><br><span class="line">    final int parentTop &#x3D; getPaddingTopWithForeground();</span><br><span class="line">    final int parentBottom &#x3D; bottom - top - getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">        final View child &#x3D; getChildAt(i);</span><br><span class="line">        if (child.getVisibility() !&#x3D; GONE) &#123;</span><br><span class="line">            final LayoutParams lp &#x3D; (LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">            final int width &#x3D; child.getMeasuredWidth();</span><br><span class="line">            final int height &#x3D; child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">            int childLeft;</span><br><span class="line">            int childTop;</span><br><span class="line"></span><br><span class="line">            int gravity &#x3D; lp.gravity;</span><br><span class="line">            if (gravity &#x3D;&#x3D; -1) &#123;</span><br><span class="line">                gravity &#x3D; DEFAULT_CHILD_GRAVITY;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final int layoutDirection &#x3D; getLayoutDirection();</span><br><span class="line">            final int absoluteGravity &#x3D; Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line">            final int verticalGravity &#x3D; gravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line"></span><br><span class="line">            switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">                case Gravity.CENTER_HORIZONTAL:</span><br><span class="line">                    childLeft &#x3D; parentLeft + (parentRight - parentLeft - width) &#x2F; 2 +</span><br><span class="line">                    lp.leftMargin - lp.rightMargin;</span><br><span class="line">                    break;</span><br><span class="line">                case Gravity.RIGHT:</span><br><span class="line">                    if (!forceLeftGravity) &#123;</span><br><span class="line">                        childLeft &#x3D; parentRight - width - lp.rightMargin;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                case Gravity.LEFT:</span><br><span class="line">                default:</span><br><span class="line">                    childLeft &#x3D; parentLeft + lp.leftMargin;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            switch (verticalGravity) &#123;</span><br><span class="line">                case Gravity.TOP:</span><br><span class="line">                    childTop &#x3D; parentTop + lp.topMargin;</span><br><span class="line">                    break;</span><br><span class="line">                case Gravity.CENTER_VERTICAL:</span><br><span class="line">                    childTop &#x3D; parentTop + (parentBottom - parentTop - height) &#x2F; 2 +</span><br><span class="line">                    lp.topMargin - lp.bottomMargin;</span><br><span class="line">                    break;</span><br><span class="line">                case Gravity.BOTTOM:</span><br><span class="line">                    childTop &#x3D; parentBottom - height - lp.bottomMargin;</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    childTop &#x3D; parentTop + lp.topMargin;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            child.layout(childLeft, childTop, childLeft + width, childTop + height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FrameLayout的onLayout()过程也很清晰：</p>
<ul>
<li>遍历子View，根据gravity值的不同进行相应的childLeft/childTop值的处理</li>
<li>通过调整后的childLeft/childTop值，调用child的layout方法，进行布局</li>
</ul>
<h3 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw"></a>onDraw</h3><p>FrameLayout没有重写onDraw()方法</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>相对LinearLayout和RelativeLayout而言，FrameLayout的功能比较简单，因此onMeasure()和onLayout()的实现都比较简洁，在onMeasure()过程，最好情况是测量一次子View，最坏情况是两次。</p>
]]></content>
      <tags>
        <tag>Android源码学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Android FrameLayout源码学习</title>
    <url>/2021/04/16/Android-FrameLayout%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="OverView"><a href="#OverView" class="headerlink" title="OverView"></a>OverView</h3><p>FrameLayout也是Android开发中常用的布局之一，其特征是子View层层相叠，通过源码来了解其工作原理。</p>
<h3 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h3><p>一个布局容器的工作原理无非就是onMeasure()/onLayout()/onDraw()3个阶段的处理，先来直接看下onMeasure()的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = getChildCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> measureMatchParentChildren =</span><br><span class="line">            MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY ||</span><br><span class="line">            MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY;</span><br><span class="line">    mMatchParentChildren.clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxHeight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxWidth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> childState = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = getChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (mMeasureAllChildren || child.getVisibility() != GONE) &#123;</span><br><span class="line">            measureChildWithMargins(child, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">            maxWidth = Math.max(maxWidth,</span><br><span class="line">                    child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);</span><br><span class="line">            maxHeight = Math.max(maxHeight,</span><br><span class="line">                    child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);</span><br><span class="line">            childState = combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line">            <span class="keyword">if</span> (measureMatchParentChildren) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT ||</span><br><span class="line">                        lp.height == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                    mMatchParentChildren.add(child);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FrameLayout的onMeasure()过程比LinearLayout/RelativeLayout都要简洁，分成两部分，上面是第一部分的源码，其处理过程很简单：</p>
<ul>
<li>遍历一次子View，通过调用measureChildWithMargins()方法，完成了对子View的一次测量</li>
<li>随后会判断子View是否需要match_parent，如需要将加入到mMatchParentChildren集合中，待下一阶段处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">    count = mMatchParentChildren.size();</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = mMatchParentChildren.get(i);</span><br><span class="line">            <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec;</span><br><span class="line">            <span class="keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> width = Math.max(<span class="number">0</span>, getMeasuredWidth()</span><br><span class="line">                        - getPaddingLeftWithForeground() - getPaddingRightWithForeground()</span><br><span class="line">                        - lp.leftMargin - lp.rightMargin);</span><br><span class="line">                childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                        width, MeasureSpec.EXACTLY);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,</span><br><span class="line">                        getPaddingLeftWithForeground() + getPaddingRightWithForeground() +</span><br><span class="line">                        lp.leftMargin + lp.rightMargin,</span><br><span class="line">                        lp.width);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec;</span><br><span class="line">            <span class="keyword">if</span> (lp.height == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> height = Math.max(<span class="number">0</span>, getMeasuredHeight()</span><br><span class="line">                        - getPaddingTopWithForeground() - getPaddingBottomWithForeground()</span><br><span class="line">                        - lp.topMargin - lp.bottomMargin);</span><br><span class="line">                childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                        height, MeasureSpec.EXACTLY);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec,</span><br><span class="line">                        getPaddingTopWithForeground() + getPaddingBottomWithForeground() +</span><br><span class="line">                        lp.topMargin + lp.bottomMargin,</span><br><span class="line">                        lp.height);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在onMeasure()的第二部分，会将之前一次遍历中发现的需要将width或者height设置成match_parent的子View再进行一次处理，对其再进行一次正确宽高值的measure调用。</p>
<h3 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    layoutChildren(left, top, right, bottom, <span class="keyword">false</span> <span class="comment">/* no force left gravity */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void layoutChildren(int left, int top, int right, int bottom, boolean forceLeftGravity) &#123;</span><br><span class="line">    final int count &#x3D; getChildCount();</span><br><span class="line"></span><br><span class="line">    final int parentLeft &#x3D; getPaddingLeftWithForeground();</span><br><span class="line">    final int parentRight &#x3D; right - left - getPaddingRightWithForeground();</span><br><span class="line"></span><br><span class="line">    final int parentTop &#x3D; getPaddingTopWithForeground();</span><br><span class="line">    final int parentBottom &#x3D; bottom - top - getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">        final View child &#x3D; getChildAt(i);</span><br><span class="line">        if (child.getVisibility() !&#x3D; GONE) &#123;</span><br><span class="line">            final LayoutParams lp &#x3D; (LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">            final int width &#x3D; child.getMeasuredWidth();</span><br><span class="line">            final int height &#x3D; child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">            int childLeft;</span><br><span class="line">            int childTop;</span><br><span class="line"></span><br><span class="line">            int gravity &#x3D; lp.gravity;</span><br><span class="line">            if (gravity &#x3D;&#x3D; -1) &#123;</span><br><span class="line">                gravity &#x3D; DEFAULT_CHILD_GRAVITY;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final int layoutDirection &#x3D; getLayoutDirection();</span><br><span class="line">            final int absoluteGravity &#x3D; Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line">            final int verticalGravity &#x3D; gravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line"></span><br><span class="line">            switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">                case Gravity.CENTER_HORIZONTAL:</span><br><span class="line">                    childLeft &#x3D; parentLeft + (parentRight - parentLeft - width) &#x2F; 2 +</span><br><span class="line">                    lp.leftMargin - lp.rightMargin;</span><br><span class="line">                    break;</span><br><span class="line">                case Gravity.RIGHT:</span><br><span class="line">                    if (!forceLeftGravity) &#123;</span><br><span class="line">                        childLeft &#x3D; parentRight - width - lp.rightMargin;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                case Gravity.LEFT:</span><br><span class="line">                default:</span><br><span class="line">                    childLeft &#x3D; parentLeft + lp.leftMargin;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            switch (verticalGravity) &#123;</span><br><span class="line">                case Gravity.TOP:</span><br><span class="line">                    childTop &#x3D; parentTop + lp.topMargin;</span><br><span class="line">                    break;</span><br><span class="line">                case Gravity.CENTER_VERTICAL:</span><br><span class="line">                    childTop &#x3D; parentTop + (parentBottom - parentTop - height) &#x2F; 2 +</span><br><span class="line">                    lp.topMargin - lp.bottomMargin;</span><br><span class="line">                    break;</span><br><span class="line">                case Gravity.BOTTOM:</span><br><span class="line">                    childTop &#x3D; parentBottom - height - lp.bottomMargin;</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    childTop &#x3D; parentTop + lp.topMargin;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            child.layout(childLeft, childTop, childLeft + width, childTop + height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FrameLayout的onLayout()过程也很清晰：</p>
<ul>
<li>遍历子View，根据gravity值的不同进行相应的childLeft/childTop值的处理</li>
<li>通过调整后的childLeft/childTop值，调用child的layout方法，进行布局</li>
</ul>
<h3 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw"></a>onDraw</h3><p>FrameLayout没有重写onDraw()方法</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>相对LinearLayout和RelativeLayout而言，FrameLayout的功能比较简单，因此onMeasure()和onLayout()的实现都比较简洁，在onMeasure()过程，最好情况是测量一次子View，最坏情况是两次。</p>
]]></content>
      <tags>
        <tag>Android源码学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Android ListView源码学习</title>
    <url>/2021/04/16/Android-ListView%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="OverView"><a href="#OverView" class="headerlink" title="OverView"></a>OverView</h3><p>Android ListView 是Android中常用的长列表组件，其继承层次如下：<br><img src="https://upload-images.jianshu.io/upload_images/5866715-5599c6565bf045a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>通常在业务代码中使用ListView的常用姿势是：</p>
<ul>
<li>创建1个ListView</li>
<li>创建1个BaseAdapter的子类，实现getCount/getItem/getItemId/getView这4个方法，有时候还会实现getItemViewType/getViewTypeCount方法来满足有多种ItemView样式的需求</li>
<li>将BaseAdatper的子类实例通过ListView的setAdapter()方法，设置给ListView实例</li>
</ul>
<h3 id="常用优化"><a href="#常用优化" class="headerlink" title="常用优化"></a>常用优化</h3><p>通常的ListView在View的复用上有2种优化：</p>
<ul>
<li>public View getView(int position, View convertView, ViewGroup parent)这个方法在实现是，首先判断一下传入的convertView是否为null，不为null即可复用，无需调用inflate或者new来新创建1个View</li>
<li>可以通过ViewHoloder的方法，将convertView的子View直接存一个引用在ViewHolder中，然后将ViewHolder通过convertView的setTag方法存储在convertView上；这种做法的好处在于，通过对子View的直接引用访问，避免了findViewById的耗时操作</li>
</ul>
<h3 id="源码浅析"><a href="#源码浅析" class="headerlink" title="源码浅析"></a>源码浅析</h3><p>ListView的源码比较长，暂时先把精力放在理解Adapter的6个方法(getViewTypeCount/getItemViewType/getCount/getItem/getItemId/getView)被调用的时机上，更详细的源码分析文章已经很多了，比较经典的有郭霖前辈的<a href="https://blog.csdn.net/sinyu890807/article/details/44996879">https://blog.csdn.net/sinyu890807/article/details/44996879</a></p>
<h3 id="int-getViewTypeCount"><a href="#int-getViewTypeCount" class="headerlink" title="int getViewTypeCount()"></a>int getViewTypeCount()</h3><p>在源码中搜索getViewTypeCount()被引用的位置，得到的和ListView相关的结果是在setAdapter(ListAdapter adapter)方法中有1行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mRecycler.setViewTypeCount(mAdapter.getViewTypeCount());</span><br></pre></td></tr></table></figure>
<p>这个mRecycler成员是RecycleBin类型，RecycleBin的定义在AbsListView中，其作用顾名思义，就是起到1个回收的垃圾箱作用，其setViewTypeCount(int viewTypeCount)方法的实现为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setViewTypeCount</span><span class="params">(<span class="keyword">int</span> viewTypeCount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (viewTypeCount &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Can&#x27;t have a viewTypeCount &lt; 1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//noinspection unchecked</span></span><br><span class="line">    ArrayList&lt;View&gt;[] scrapViews = <span class="keyword">new</span> ArrayList[viewTypeCount];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; viewTypeCount; i++) &#123;</span><br><span class="line">        scrapViews[i] = <span class="keyword">new</span> ArrayList&lt;View&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    mViewTypeCount = viewTypeCount;</span><br><span class="line">    mCurrentScrap = scrapViews[<span class="number">0</span>];</span><br><span class="line">    mScrapViews = scrapViews;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RecycleBin回收废弃View的实现是通过其scrapViews数组实现的，而传入的viewTypeCount决定了这个数组的长度，注意scrapViews的每一个成员是一个ArrayList<View>；在这里我的理解是，viewTypeCount决定了有多少种View会被回收，而每1个被回收的View会根据viewType进入到对应的ArrayList<View>中去，方便在复用时从正确的类型中取出对应的View来进行复用。</p>
<h3 id="int-getItemViewType-int-position"><a href="#int-getItemViewType-int-position" class="headerlink" title="int getItemViewType(int position)"></a>int getItemViewType(int position)</h3><p>在源码中搜索该函数，有好几处调用的地方，但多数调用都是得到viewType之后设置到AbsListView.LayoutParams的viewType属性上使用，这种使用并不是非常重要，真正关键的调用在AbsListView的getScrapView(position)函数中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">View <span class="title">getScrapView</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> whichScrap = mAdapter.getItemViewType(position);</span><br><span class="line">    <span class="keyword">if</span> (whichScrap &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mViewTypeCount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> retrieveFromScrap(mCurrentScrap, position);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (whichScrap &lt; mScrapViews.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> retrieveFromScrap(mScrapViews[whichScrap], position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getScrapView(int position)函数的作用在于，从废弃的View中获取一个View，准备复用，从实现上可以看出，getItemViewType的作用在于，得到正确的ViewType，从而从对应的mScrapViews数组中取出1个ScrapView</p>
<h3 id="int-getCount"><a href="#int-getCount" class="headerlink" title="int getCount()"></a>int getCount()</h3><p>getCount()的调用在源码中的搜索结果就实在是太多了，粗略浏览的一下，把觉得比较关键的点记录下来</p>
<ul>
<li><p>首先是ListView的setAdatper()函数中有这么一句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mItemCount = mAdapter.getCount();</span><br></pre></td></tr></table></figure>
<p>这个mItemCount是ListView的祖先类AdapterView的成员，设置到这上面之后就能更加方便地使用了</p>
</li>
<li><p>然后是ListView的layoutChildren()函数中有这么一段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mItemCount == <span class="number">0</span>) &#123;</span><br><span class="line">    resetList();</span><br><span class="line">    invokeOnItemScrollListener();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mItemCount != mAdapter.getCount()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The content of the adapter has changed but &quot;</span></span><br><span class="line">            + <span class="string">&quot;ListView did not receive a notification. Make sure the content of &quot;</span></span><br><span class="line">            + <span class="string">&quot;your adapter is not modified from a background thread, but only from &quot;</span></span><br><span class="line">            + <span class="string">&quot;the UI thread. Make sure your adapter calls notifyDataSetChanged() &quot;</span></span><br><span class="line">            + <span class="string">&quot;when its content changes. [in ListView(&quot;</span> + getId() + <span class="string">&quot;, &quot;</span> + getClass()</span><br><span class="line">            + <span class="string">&quot;) with Adapter(&quot;</span> + mAdapter.getClass() + <span class="string">&quot;)]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在layoutChildren()过程中需要检查mItemCount和mAdapter.getCount()是否一致，如果不一致，证明数据源被改变了却没有调用notifyDataSetChanged()通知观察方</p>
</li>
</ul>
<h3 id="Object-getItem-int-position"><a href="#Object-getItem-int-position" class="headerlink" title="Object getItem(int position)"></a>Object getItem(int position)</h3><p>getItem(int position)方法主要被调用的地方在AdapterView的getItemAtPosition(int position)函数中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getItemAtPosition</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    T adapter = getAdapter();</span><br><span class="line">    <span class="keyword">return</span> (adapter == <span class="keyword">null</span> || position &lt; <span class="number">0</span>) ? <span class="keyword">null</span> : adapter.getItem(position);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，在源码中再没找到getItem(int position)的相关调用，这也可以理解，因为getItem(int position)更主要的使用场景是我们在业务代码中调用，通过该方法，能够从Adapter里拿出数据项，而不需要直接跟数据源接触。</p>
<h3 id="long-getItemId-int-position"><a href="#long-getItemId-int-position" class="headerlink" title="long getItemId(int position)"></a>long getItemId(int position)</h3><p>getItemId(int postion)函数在源码中搜索，ListView中的调用已经被标注为@Deprecate，其余主要的调用都在AbsListView中，选择其中一处来看下这个方法的作用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setItemChecked</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (mChoiceMode == CHOICE_MODE_NONE) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Start selection mode if needed. We don&#x27;t need to if we&#x27;re unchecking something.</span></span><br><span class="line">     <span class="keyword">if</span> (value &amp;&amp; mChoiceMode == CHOICE_MODE_MULTIPLE_MODAL &amp;&amp; mChoiceActionMode == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (mMultiChoiceModeCallback == <span class="keyword">null</span> ||</span><br><span class="line">                 !mMultiChoiceModeCallback.hasWrappedCallback()) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;AbsListView: attempted to start selection mode &quot;</span> +</span><br><span class="line">                     <span class="string">&quot;for CHOICE_MODE_MULTIPLE_MODAL but no choice mode callback was &quot;</span> +</span><br><span class="line">                     <span class="string">&quot;supplied. Call setMultiChoiceModeListener to set a callback.&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         mChoiceActionMode = startActionMode(mMultiChoiceModeCallback);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">boolean</span> itemCheckChanged;</span><br><span class="line">     <span class="keyword">if</span> (mChoiceMode == CHOICE_MODE_MULTIPLE || mChoiceMode == CHOICE_MODE_MULTIPLE_MODAL) &#123;</span><br><span class="line">         <span class="keyword">boolean</span> oldValue = mCheckStates.get(position);</span><br><span class="line">         mCheckStates.put(position, value);</span><br><span class="line">         <span class="keyword">if</span> (mCheckedIdStates != <span class="keyword">null</span> &amp;&amp; mAdapter.hasStableIds()) &#123;</span><br><span class="line">             <span class="keyword">if</span> (value) &#123;</span><br><span class="line">                 mCheckedIdStates.put(mAdapter.getItemId(position), position);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 mCheckedIdStates.delete(mAdapter.getItemId(position));</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         itemCheckChanged = oldValue != value;</span><br><span class="line">         <span class="keyword">if</span> (itemCheckChanged) &#123;</span><br><span class="line">             <span class="keyword">if</span> (value) &#123;</span><br><span class="line">                 mCheckedItemCount++;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 mCheckedItemCount--;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (mChoiceActionMode != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">final</span> <span class="keyword">long</span> id = mAdapter.getItemId(position);</span><br><span class="line">             mMultiChoiceModeCallback.onItemCheckedStateChanged(mChoiceActionMode,</span><br><span class="line">                     position, id, value);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ……</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// this may end up selecting the value we just cleared but this way</span></span><br><span class="line">         <span class="comment">// we ensure length of mCheckStates is 1, a fact getCheckedItemPosition relies on</span></span><br><span class="line">         <span class="keyword">if</span> (value) &#123;</span><br><span class="line">             mCheckStates.put(position, <span class="keyword">true</span>);</span><br><span class="line">             <span class="keyword">if</span> (updateIds) &#123;</span><br><span class="line">                 mCheckedIdStates.put(mAdapter.getItemId(position), position);</span><br><span class="line">             &#125;</span><br><span class="line">             mCheckedItemCount = <span class="number">1</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mCheckStates.size() == <span class="number">0</span> || !mCheckStates.valueAt(<span class="number">0</span>)) &#123;</span><br><span class="line">             mCheckedItemCount = <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Do not generate a data change while we are in the layout phase or data has not changed</span></span><br><span class="line">     <span class="keyword">if</span> (!mInLayout &amp;&amp; !mBlockLayoutRequests &amp;&amp; itemCheckChanged) &#123;</span><br><span class="line">         mDataChanged = <span class="keyword">true</span>;</span><br><span class="line">         rememberSyncState();</span><br><span class="line">         requestLayout();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，主要是通过该方法，获得对应位置的id后，能够作为一个索引，用于增删改查等快速操作。</p>
<h3 id="View-getView-int-position-View-convertView-ViewGroup-parent"><a href="#View-getView-int-position-View-convertView-ViewGroup-parent" class="headerlink" title="View getView(int position, View convertView, ViewGroup parent)"></a>View getView(int position, View convertView, ViewGroup parent)</h3><p>最后Adapter中最重要的方法，getView方法的作用是返回某一项对应的ItemView，在源码中关键的调用是AbsListView中的obtainView()方法中的调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final View scrapView &#x3D; mRecycler.getScrapView(position);</span><br><span class="line">final View child &#x3D; mAdapter.getView(position, scrapView, this);</span><br><span class="line">if (scrapView !&#x3D; null) &#123;</span><br><span class="line">    if (child !&#x3D; scrapView) &#123;</span><br><span class="line">        &#x2F;&#x2F; Failed to re-bind the data, return scrap to the heap.</span><br><span class="line">        mRecycler.addScrapView(scrapView, position);</span><br><span class="line">    &#125; else if (child.isTemporarilyDetached()) &#123;</span><br><span class="line">        outMetadata[0] &#x3D; true;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Finish the temporary detach started in addScrapView().</span><br><span class="line">        child.dispatchFinishTemporaryDetach();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbsListView的obtainView函数的作用就是构建出某一position对应的View，首先会从mRecycler中取出一个对应的废弃View，这个废弃View就是传入Adapter的getView()方法中的convertView，这里也就解释了为什么需要判空——在首次布局时，实际上是还没有废弃的View可用的，而后面布局时就有废弃的View可复用，无需重新构建了。</p>
]]></content>
      <tags>
        <tag>Android源码学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Android TableLayout源码学习</title>
    <url>/2021/04/16/Android-TableLayout%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="OverView"><a href="#OverView" class="headerlink" title="OverView"></a>OverView</h3><p>FrameLayout也是Android开发中常用的布局之一，其特征是子View层层相叠，通过源码来了解其工作原理。</p>
<h3 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h3><p>一个布局容器的工作原理无非就是onMeasure()/onLayout()/onDraw()3个阶段的处理，先来直接看下onMeasure()的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = getChildCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> measureMatchParentChildren =</span><br><span class="line">            MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY ||</span><br><span class="line">            MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY;</span><br><span class="line">    mMatchParentChildren.clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxHeight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxWidth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> childState = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = getChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (mMeasureAllChildren || child.getVisibility() != GONE) &#123;</span><br><span class="line">            measureChildWithMargins(child, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">            maxWidth = Math.max(maxWidth,</span><br><span class="line">                    child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);</span><br><span class="line">            maxHeight = Math.max(maxHeight,</span><br><span class="line">                    child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);</span><br><span class="line">            childState = combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line">            <span class="keyword">if</span> (measureMatchParentChildren) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT ||</span><br><span class="line">                        lp.height == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                    mMatchParentChildren.add(child);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FrameLayout的onMeasure()过程比LinearLayout/RelativeLayout都要简洁，分成两部分，上面是第一部分的源码，其处理过程很简单：</p>
<ul>
<li>遍历一次子View，通过调用measureChildWithMargins()方法，完成了对子View的一次测量</li>
<li>随后会判断子View是否需要match_parent，如需要将加入到mMatchParentChildren集合中，待下一阶段处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">    count = mMatchParentChildren.size();</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = mMatchParentChildren.get(i);</span><br><span class="line">            <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec;</span><br><span class="line">            <span class="keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> width = Math.max(<span class="number">0</span>, getMeasuredWidth()</span><br><span class="line">                        - getPaddingLeftWithForeground() - getPaddingRightWithForeground()</span><br><span class="line">                        - lp.leftMargin - lp.rightMargin);</span><br><span class="line">                childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                        width, MeasureSpec.EXACTLY);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,</span><br><span class="line">                        getPaddingLeftWithForeground() + getPaddingRightWithForeground() +</span><br><span class="line">                        lp.leftMargin + lp.rightMargin,</span><br><span class="line">                        lp.width);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec;</span><br><span class="line">            <span class="keyword">if</span> (lp.height == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> height = Math.max(<span class="number">0</span>, getMeasuredHeight()</span><br><span class="line">                        - getPaddingTopWithForeground() - getPaddingBottomWithForeground()</span><br><span class="line">                        - lp.topMargin - lp.bottomMargin);</span><br><span class="line">                childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                        height, MeasureSpec.EXACTLY);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec,</span><br><span class="line">                        getPaddingTopWithForeground() + getPaddingBottomWithForeground() +</span><br><span class="line">                        lp.topMargin + lp.bottomMargin,</span><br><span class="line">                        lp.height);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在onMeasure()的第二部分，会将之前一次遍历中发现的需要将width或者height设置成match_parent的子View再进行一次处理，对其再进行一次正确宽高值的measure调用。</p>
<h3 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    layoutChildren(left, top, right, bottom, <span class="keyword">false</span> <span class="comment">/* no force left gravity */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void layoutChildren(int left, int top, int right, int bottom, boolean forceLeftGravity) &#123;</span><br><span class="line">    final int count &#x3D; getChildCount();</span><br><span class="line"></span><br><span class="line">    final int parentLeft &#x3D; getPaddingLeftWithForeground();</span><br><span class="line">    final int parentRight &#x3D; right - left - getPaddingRightWithForeground();</span><br><span class="line"></span><br><span class="line">    final int parentTop &#x3D; getPaddingTopWithForeground();</span><br><span class="line">    final int parentBottom &#x3D; bottom - top - getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">        final View child &#x3D; getChildAt(i);</span><br><span class="line">        if (child.getVisibility() !&#x3D; GONE) &#123;</span><br><span class="line">            final LayoutParams lp &#x3D; (LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">            final int width &#x3D; child.getMeasuredWidth();</span><br><span class="line">            final int height &#x3D; child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">            int childLeft;</span><br><span class="line">            int childTop;</span><br><span class="line"></span><br><span class="line">            int gravity &#x3D; lp.gravity;</span><br><span class="line">            if (gravity &#x3D;&#x3D; -1) &#123;</span><br><span class="line">                gravity &#x3D; DEFAULT_CHILD_GRAVITY;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final int layoutDirection &#x3D; getLayoutDirection();</span><br><span class="line">            final int absoluteGravity &#x3D; Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line">            final int verticalGravity &#x3D; gravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line"></span><br><span class="line">            switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">                case Gravity.CENTER_HORIZONTAL:</span><br><span class="line">                    childLeft &#x3D; parentLeft + (parentRight - parentLeft - width) &#x2F; 2 +</span><br><span class="line">                    lp.leftMargin - lp.rightMargin;</span><br><span class="line">                    break;</span><br><span class="line">                case Gravity.RIGHT:</span><br><span class="line">                    if (!forceLeftGravity) &#123;</span><br><span class="line">                        childLeft &#x3D; parentRight - width - lp.rightMargin;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                case Gravity.LEFT:</span><br><span class="line">                default:</span><br><span class="line">                    childLeft &#x3D; parentLeft + lp.leftMargin;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            switch (verticalGravity) &#123;</span><br><span class="line">                case Gravity.TOP:</span><br><span class="line">                    childTop &#x3D; parentTop + lp.topMargin;</span><br><span class="line">                    break;</span><br><span class="line">                case Gravity.CENTER_VERTICAL:</span><br><span class="line">                    childTop &#x3D; parentTop + (parentBottom - parentTop - height) &#x2F; 2 +</span><br><span class="line">                    lp.topMargin - lp.bottomMargin;</span><br><span class="line">                    break;</span><br><span class="line">                case Gravity.BOTTOM:</span><br><span class="line">                    childTop &#x3D; parentBottom - height - lp.bottomMargin;</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    childTop &#x3D; parentTop + lp.topMargin;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            child.layout(childLeft, childTop, childLeft + width, childTop + height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FrameLayout的onLayout()过程也很清晰：</p>
<ul>
<li>遍历子View，根据gravity值的不同进行相应的childLeft/childTop值的处理</li>
<li>通过调整后的childLeft/childTop值，调用child的layout方法，进行布局</li>
</ul>
<h3 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw"></a>onDraw</h3><p>FrameLayout没有重写onDraw()方法</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>相对LinearLayout和RelativeLayout而言，FrameLayout的功能比较简单，因此onMeasure()和onLayout()的实现都比较简洁，在onMeasure()过程，最好情况是测量一次子View，最坏情况是两次。</p>
]]></content>
      <tags>
        <tag>Android源码学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Android ImageView源码浅析</title>
    <url>/2021/04/16/Android-ImageView%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h3 id="OverView"><a href="#OverView" class="headerlink" title="OverView"></a>OverView</h3><p>官方文档中关于ImageView的介绍是：<br>Displays image resources, for example Bitmap or Drawable resources. ImageView is also commonly used to apply tints to an image and handle image scaling.<br>即用来展示图像资源的控件。<br>其继承层次为<br><img src="https://upload-images.jianshu.io/upload_images/5866715-cc8fc944cabf6d5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="ImageView-ScaleType"><a href="#ImageView-ScaleType" class="headerlink" title="ImageView.ScaleType"></a>ImageView.ScaleType</h3><p>在ImageView中有一个内部枚举类ScaleType，用来控制图像和ImageView的尺寸不一致时的拉伸规则：<br>| 枚举值 | 含义<br>| —-    | —- |<br>| CENTER| 不拉伸图像，居中置于ImageView中|<br>|CENTER_CROP|等比例拉伸图像，直至长和宽都等于或者大于ImageView的对应边，然后居中置于ImageView，（如果本来的长宽就都大于ImageView的对应边，则不拉伸）|<br>|CENTER_INSIDE|等比例拉伸图像，直至长和宽都等于或者小于ImageView的对应边，然后居中置于ImageView(如果本来的长宽就都小于ImageView的对应边，则不拉伸)|<br>|FILL_XY|图像的长和宽都拉伸到和ImageView一致，以充满ImageView，这种情况下会改变图像的比例|<br>|FILL_CENTER|等比例拉伸图片，直到某一边刚好和ImageView一致，然后居中置于ImageView|<br>|FILL_START|等比例拉伸图片，直到某一边刚好和ImageView一致，然后靠开始位置置于ImageView|<br>|FILL_END|等比例拉伸图片，直到某一边刚好和ImageView一致，然后靠结束位置置于ImageView|<br>|MATRIX|从左上角开始平铺图像|</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ImageView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">        initImageView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageView</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageView</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, defStyleAttr, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageView</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs, <span class="keyword">int</span> defStyleAttr,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr, defStyleRes);</span><br><span class="line"></span><br><span class="line">        initImageView();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (getImportantForAutofill() == IMPORTANT_FOR_AUTOFILL_AUTO) &#123;</span><br><span class="line">            setImportantForAutofill(IMPORTANT_FOR_AUTOFILL_NO);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> TypedArray a = context.obtainStyledAttributes(</span><br><span class="line">                attrs, R.styleable.ImageView, defStyleAttr, defStyleRes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Drawable d = a.getDrawable(R.styleable.ImageView_src);</span><br><span class="line">        <span class="keyword">if</span> (d != <span class="keyword">null</span>) &#123;</span><br><span class="line">            setImageDrawable(d);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mBaselineAlignBottom = a.getBoolean(R.styleable.ImageView_baselineAlignBottom, <span class="keyword">false</span>);</span><br><span class="line">        mBaseline = a.getDimensionPixelSize(R.styleable.ImageView_baseline, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        setAdjustViewBounds(a.getBoolean(R.styleable.ImageView_adjustViewBounds, <span class="keyword">false</span>));</span><br><span class="line">        setMaxWidth(a.getDimensionPixelSize(R.styleable.ImageView_maxWidth, Integer.MAX_VALUE));</span><br><span class="line">        setMaxHeight(a.getDimensionPixelSize(R.styleable.ImageView_maxHeight, Integer.MAX_VALUE));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> index = a.getInt(R.styleable.ImageView_scaleType, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            setScaleType(sScaleTypeArray[index]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a.hasValue(R.styleable.ImageView_tint)) &#123;</span><br><span class="line">            mDrawableTintList = a.getColorStateList(R.styleable.ImageView_tint);</span><br><span class="line">            mHasDrawableTint = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            mDrawableTintMode = PorterDuff.Mode.SRC_ATOP;</span><br><span class="line">            mHasDrawableTintMode = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a.hasValue(R.styleable.ImageView_tintMode)) &#123;</span><br><span class="line">            mDrawableTintMode = Drawable.parseTintMode(a.getInt(</span><br><span class="line">                    R.styleable.ImageView_tintMode, -<span class="number">1</span>), mDrawableTintMode);</span><br><span class="line">            mHasDrawableTintMode = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        applyImageTint();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> alpha = a.getInt(R.styleable.ImageView_drawableAlpha, <span class="number">255</span>);</span><br><span class="line">        <span class="keyword">if</span> (alpha != <span class="number">255</span>) &#123;</span><br><span class="line">            setImageAlpha(alpha);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mCropToPadding = a.getBoolean(</span><br><span class="line">                R.styleable.ImageView_cropToPadding, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        a.recycle();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>View的构造函数的写法都比较模板化，4个构造函数，2参数和3参数最终调用到的是4参数的构造函数，4参数的构造函数从xml中解析出各个属性也和其他View的构造函数是相同套路<br>单参数和4参数的构造函数，主要的工作都是调用了initImageView()函数<br>看下initImageView()函数的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initImageView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     mMatrix = <span class="keyword">new</span> Matrix();</span><br><span class="line">     mScaleType = ScaleType.FIT_CENTER;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!sCompatDone) &#123;</span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">int</span> targetSdkVersion = mContext.getApplicationInfo().targetSdkVersion;</span><br><span class="line">         sCompatAdjustViewBounds = targetSdkVersion &lt;= Build.VERSION_CODES.JELLY_BEAN_MR1;</span><br><span class="line">         sCompatUseCorrectStreamDensity = targetSdkVersion &gt; Build.VERSION_CODES.M;</span><br><span class="line">         sCompatDrawableVisibilityDispatch = targetSdkVersion &lt; Build.VERSION_CODES.N;</span><br><span class="line">         sCompatDone = <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>initImageView()函数也很简单，初始化了一个mMatrix变量，将mScaleType设置成默认的ScaleType.FIT_CENTER（后面展开说下ScaleType这个枚举类）<br>接下来看下4参数中调用的setImageDrawable(Drawable d)的调用，因为在实际使用中，ImageView的最关键就在于把图像展示出来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImageDrawable</span><span class="params">(<span class="meta">@Nullable</span> Drawable drawable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDrawable != drawable) &#123;</span><br><span class="line">        mResource = <span class="number">0</span>;</span><br><span class="line">        mUri = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldWidth = mDrawableWidth;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldHeight = mDrawableHeight;</span><br><span class="line"></span><br><span class="line">        updateDrawable(drawable);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (oldWidth != mDrawableWidth || oldHeight != mDrawableHeight) &#123;</span><br><span class="line">            requestLayout();</span><br><span class="line">        &#125;</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要逻辑在updateDrawable(Drawable d)里面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateDrawable</span><span class="params">(Drawable d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d != mRecycleableBitmapDrawable &amp;&amp; mRecycleableBitmapDrawable != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mRecycleableBitmapDrawable.setBitmap(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> sameDrawable = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDrawable != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sameDrawable = mDrawable == d;</span><br><span class="line">        mDrawable.setCallback(<span class="keyword">null</span>);</span><br><span class="line">        unscheduleDrawable(mDrawable);</span><br><span class="line">        <span class="keyword">if</span> (!sCompatDrawableVisibilityDispatch &amp;&amp; !sameDrawable &amp;&amp; isAttachedToWindow()) &#123;</span><br><span class="line">            mDrawable.setVisible(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDrawable = d;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d != <span class="keyword">null</span>) &#123;</span><br><span class="line">        d.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        d.setLayoutDirection(getLayoutDirection());</span><br><span class="line">        <span class="keyword">if</span> (d.isStateful()) &#123;</span><br><span class="line">            d.setState(getDrawableState());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!sameDrawable || sCompatDrawableVisibilityDispatch) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> visible = sCompatDrawableVisibilityDispatch</span><br><span class="line">                    ? getVisibility() == VISIBLE</span><br><span class="line">                    : isAttachedToWindow() &amp;&amp; getWindowVisibility() == VISIBLE &amp;&amp; isShown();</span><br><span class="line">            d.setVisible(visible, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        d.setLevel(mLevel);</span><br><span class="line">        mDrawableWidth = d.getIntrinsicWidth();</span><br><span class="line">        mDrawableHeight = d.getIntrinsicHeight();</span><br><span class="line">        applyImageTint();</span><br><span class="line">        applyColorMod();</span><br><span class="line"></span><br><span class="line">        configureBounds();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mDrawableWidth = mDrawableHeight = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的applyImageTint()和applyColorMod()函数的作用是设置着色、颜色相关的属性，比较关键的函数调用是configureBounds()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureBounds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDrawable == <span class="keyword">null</span> || !mHaveFrame) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> dwidth = mDrawableWidth;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> dheight = mDrawableHeight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> vwidth = getWidth() - mPaddingLeft - mPaddingRight;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> vheight = getHeight() - mPaddingTop - mPaddingBottom;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> fits = (dwidth &lt; <span class="number">0</span> || vwidth == dwidth)</span><br><span class="line">            &amp;&amp; (dheight &lt; <span class="number">0</span> || vheight == dheight);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dwidth &lt;= <span class="number">0</span> || dheight &lt;= <span class="number">0</span> || ScaleType.FIT_XY == mScaleType) &#123;</span><br><span class="line">        <span class="comment">/* If the drawable has no intrinsic size, or we&#x27;re told to</span></span><br><span class="line"><span class="comment">            scaletofit, then we just fill our entire view.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        mDrawable.setBounds(<span class="number">0</span>, <span class="number">0</span>, vwidth, vheight);</span><br><span class="line">        mDrawMatrix = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// We need to do the scaling ourself, so have the drawable</span></span><br><span class="line">        <span class="comment">// use its native size.</span></span><br><span class="line">        mDrawable.setBounds(<span class="number">0</span>, <span class="number">0</span>, dwidth, dheight);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ScaleType.MATRIX == mScaleType) &#123;</span><br><span class="line">            <span class="comment">// Use the specified matrix as-is.</span></span><br><span class="line">            <span class="keyword">if</span> (mMatrix.isIdentity()) &#123;</span><br><span class="line">                mDrawMatrix = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mDrawMatrix = mMatrix;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fits) &#123;</span><br><span class="line">            <span class="comment">// The bitmap fits exactly, no transform needed.</span></span><br><span class="line">            mDrawMatrix = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ScaleType.CENTER == mScaleType) &#123;</span><br><span class="line">            <span class="comment">// Center bitmap in view, no scaling.</span></span><br><span class="line">            mDrawMatrix = mMatrix;</span><br><span class="line">            mDrawMatrix.setTranslate(Math.round((vwidth - dwidth) * <span class="number">0.5f</span>),</span><br><span class="line">                                     Math.round((vheight - dheight) * <span class="number">0.5f</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ScaleType.CENTER_CROP == mScaleType) &#123;</span><br><span class="line">            mDrawMatrix = mMatrix;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> scale;</span><br><span class="line">            <span class="keyword">float</span> dx = <span class="number">0</span>, dy = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dwidth * vheight &gt; vwidth * dheight) &#123;</span><br><span class="line">                scale = (<span class="keyword">float</span>) vheight / (<span class="keyword">float</span>) dheight;</span><br><span class="line">                dx = (vwidth - dwidth * scale) * <span class="number">0.5f</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                scale = (<span class="keyword">float</span>) vwidth / (<span class="keyword">float</span>) dwidth;</span><br><span class="line">                dy = (vheight - dheight * scale) * <span class="number">0.5f</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mDrawMatrix.setScale(scale, scale);</span><br><span class="line">            mDrawMatrix.postTranslate(Math.round(dx), Math.round(dy));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ScaleType.CENTER_INSIDE == mScaleType) &#123;</span><br><span class="line">            mDrawMatrix = mMatrix;</span><br><span class="line">            <span class="keyword">float</span> scale;</span><br><span class="line">            <span class="keyword">float</span> dx;</span><br><span class="line">            <span class="keyword">float</span> dy;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dwidth &lt;= vwidth &amp;&amp; dheight &lt;= vheight) &#123;</span><br><span class="line">                scale = <span class="number">1.0f</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                scale = Math.min((<span class="keyword">float</span>) vwidth / (<span class="keyword">float</span>) dwidth,</span><br><span class="line">                        (<span class="keyword">float</span>) vheight / (<span class="keyword">float</span>) dheight);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dx = Math.round((vwidth - dwidth * scale) * <span class="number">0.5f</span>);</span><br><span class="line">            dy = Math.round((vheight - dheight * scale) * <span class="number">0.5f</span>);</span><br><span class="line"></span><br><span class="line">            mDrawMatrix.setScale(scale, scale);</span><br><span class="line">            mDrawMatrix.postTranslate(dx, dy);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Generate the required transform.</span></span><br><span class="line">            mTempSrc.set(<span class="number">0</span>, <span class="number">0</span>, dwidth, dheight);</span><br><span class="line">            mTempDst.set(<span class="number">0</span>, <span class="number">0</span>, vwidth, vheight);</span><br><span class="line"></span><br><span class="line">            mDrawMatrix = mMatrix;</span><br><span class="line">            mDrawMatrix.setRectToRect(mTempSrc, mTempDst, scaleTypeToScaleToFit(mScaleType));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的主要部分是一大堆的if条件对ScaleType的判断，对相应的ScaleType进行图像的矩阵Matrix处理</p>
<h3 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure()"></a>onMeasure()</h3><p>看完构造函数，接下来开始看绘制相关的内容，首先是第一阶段的onMeasure()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    resolveUri();</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Desired aspect ratio of the view&#x27;s contents (not including padding)</span></span><br><span class="line">    <span class="keyword">float</span> desiredAspect = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We are allowed to change the view&#x27;s width</span></span><br><span class="line">    <span class="keyword">boolean</span> resizeWidth = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We are allowed to change the view&#x27;s height</span></span><br><span class="line">    <span class="keyword">boolean</span> resizeHeight = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDrawable == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If no drawable, its intrinsic size is 0.</span></span><br><span class="line">        mDrawableWidth = -<span class="number">1</span>;</span><br><span class="line">        mDrawableHeight = -<span class="number">1</span>;</span><br><span class="line">        w = h = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        w = mDrawableWidth;</span><br><span class="line">        h = mDrawableHeight;</span><br><span class="line">        <span class="keyword">if</span> (w &lt;= <span class="number">0</span>) w = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (h &lt;= <span class="number">0</span>) h = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We are supposed to adjust view bounds to match the aspect</span></span><br><span class="line">        <span class="comment">// ratio of our drawable. See if that is possible.</span></span><br><span class="line">        <span class="keyword">if</span> (mAdjustViewBounds) &#123;</span><br><span class="line">            resizeWidth = widthSpecMode != MeasureSpec.EXACTLY;</span><br><span class="line">            resizeHeight = heightSpecMode != MeasureSpec.EXACTLY;</span><br><span class="line"></span><br><span class="line">            desiredAspect = (<span class="keyword">float</span>) w / (<span class="keyword">float</span>) h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> pleft = mPaddingLeft;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> pright = mPaddingRight;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> ptop = mPaddingTop;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> pbottom = mPaddingBottom;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> widthSize;</span><br><span class="line">    <span class="keyword">int</span> heightSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resizeWidth || resizeHeight) &#123;</span><br><span class="line">        <span class="comment">/* If we get here, it means we want to resize to match the</span></span><br><span class="line"><span class="comment">            drawables aspect ratio, and we have the freedom to change at</span></span><br><span class="line"><span class="comment">            least one dimension.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the max possible width given our constraints</span></span><br><span class="line">        widthSize = resolveAdjustedSize(w + pleft + pright, mMaxWidth, widthMeasureSpec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the max possible height given our constraints</span></span><br><span class="line">        heightSize = resolveAdjustedSize(h + ptop + pbottom, mMaxHeight, heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (desiredAspect != <span class="number">0.0f</span>) &#123;</span><br><span class="line">            <span class="comment">// See what our actual aspect ratio is</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> actualAspect = (<span class="keyword">float</span>)(widthSize - pleft - pright) /</span><br><span class="line">                                    (heightSize - ptop - pbottom);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Math.abs(actualAspect - desiredAspect) &gt; <span class="number">0.0000001</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Try adjusting width to be proportional to height</span></span><br><span class="line">                <span class="keyword">if</span> (resizeWidth) &#123;</span><br><span class="line">                    <span class="keyword">int</span> newWidth = (<span class="keyword">int</span>)(desiredAspect * (heightSize - ptop - pbottom)) +</span><br><span class="line">                            pleft + pright;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Allow the width to outgrow its original estimate if height is fixed.</span></span><br><span class="line">                    <span class="keyword">if</span> (!resizeHeight &amp;&amp; !sCompatAdjustViewBounds) &#123;</span><br><span class="line">                        widthSize = resolveAdjustedSize(newWidth, mMaxWidth, widthMeasureSpec);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (newWidth &lt;= widthSize) &#123;</span><br><span class="line">                        widthSize = newWidth;</span><br><span class="line">                        done = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Try adjusting height to be proportional to width</span></span><br><span class="line">                <span class="keyword">if</span> (!done &amp;&amp; resizeHeight) &#123;</span><br><span class="line">                    <span class="keyword">int</span> newHeight = (<span class="keyword">int</span>)((widthSize - pleft - pright) / desiredAspect) +</span><br><span class="line">                            ptop + pbottom;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Allow the height to outgrow its original estimate if width is fixed.</span></span><br><span class="line">                    <span class="keyword">if</span> (!resizeWidth &amp;&amp; !sCompatAdjustViewBounds) &#123;</span><br><span class="line">                        heightSize = resolveAdjustedSize(newHeight, mMaxHeight,</span><br><span class="line">                                heightMeasureSpec);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (newHeight &lt;= heightSize) &#123;</span><br><span class="line">                        heightSize = newHeight;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* We are either don&#x27;t want to preserve the drawables aspect ratio,</span></span><br><span class="line"><span class="comment">           or we are not allowed to change view dimensions. Just measure in</span></span><br><span class="line"><span class="comment">           the normal way.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        w += pleft + pright;</span><br><span class="line">        h += ptop + pbottom;</span><br><span class="line"></span><br><span class="line">        w = Math.max(w, getSuggestedMinimumWidth());</span><br><span class="line">        h = Math.max(h, getSuggestedMinimumHeight());</span><br><span class="line"></span><br><span class="line">        widthSize = resolveSizeAndState(w, widthMeasureSpec, <span class="number">0</span>);</span><br><span class="line">        heightSize = resolveSizeAndState(h, heightMeasureSpec, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setMeasuredDimension(widthSize, heightSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先会调用一次 resolveUri()，这个函数的作用是，确保在进行onMeasure()时已经有mDrawble，resolveUri()会在未设置mDrawble的情况下通过Uri来获取Drawable</li>
<li>通过mDrawable的宽高来设置w和h</li>
<li>默认情况下resizeWidth/resizeHeight取值为false，这样只会走最下面的一段else分支，w/h加上对应的padding，然后通过resolveSizeAndState产生相应的<br>MeasureSpec</li>
<li>假如resizeWidth/resizeHeight为true，会走到中间的if代码块中，这个代码块的作用是，根据比例规则重算宽高</li>
</ul>
<h3 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout()"></a>onLayout()</h3><p>因为ImageView只是普通View的子类，因此没有重写onLayout()</p>
<h3 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw()"></a>onDraw()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDrawable == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// couldn&#x27;t resolve the URI</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDrawableWidth == <span class="number">0</span> || mDrawableHeight == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;     <span class="comment">// nothing to draw (empty bounds)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDrawMatrix == <span class="keyword">null</span> &amp;&amp; mPaddingTop == <span class="number">0</span> &amp;&amp; mPaddingLeft == <span class="number">0</span>) &#123;</span><br><span class="line">        mDrawable.draw(canvas);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> saveCount = canvas.getSaveCount();</span><br><span class="line">        canvas.save();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mCropToPadding) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> scrollX = mScrollX;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> scrollY = mScrollY;</span><br><span class="line">            canvas.clipRect(scrollX + mPaddingLeft, scrollY + mPaddingTop,</span><br><span class="line">                    scrollX + mRight - mLeft - mPaddingRight,</span><br><span class="line">                    scrollY + mBottom - mTop - mPaddingBottom);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        canvas.translate(mPaddingLeft, mPaddingTop);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mDrawMatrix != <span class="keyword">null</span>) &#123;</span><br><span class="line">            canvas.concat(mDrawMatrix);</span><br><span class="line">        &#125;</span><br><span class="line">        mDrawable.draw(canvas);</span><br><span class="line">        canvas.restoreToCount(saveCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在onDraw()的源码可以看出，ImageView的绘制，最终是通过Drawable的draw(Canvas canvas)方法完成的。</p>
]]></content>
      <tags>
        <tag>Android源码学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Android RecyclerView源码浅析</title>
    <url>/2021/04/16/Android-RecyclerView%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h3 id="OverView"><a href="#OverView" class="headerlink" title="OverView"></a>OverView</h3><p>RecyclerView是Android5.0推出的新组件，可以认为是更加灵活强大的ListView，在日常开发中基本上已经取代了ListView成为长列表控件的首选。<br>其继承结构如下：<br><img src="https://upload-images.jianshu.io/upload_images/5866715-c382744bd06ca4a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>从继承结构可以看到，RecyclerView是ViewGroup的直接子类，这里就是RecyclerView与ListView第一点大不同，ListView和ViewGroup之间隔了两层，其实个人认为在继承结构上揭露了RecyclerView相比ListView的优点：由于RecyclerView这么简单的继承结构，说明了其主要功能都是通过<strong>组合</strong>来实现的，而ListView是通过<strong>继承</strong>实现的。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>通常来说，在业务代码中使用RecyclerView，主要有以下几个步骤：</p>
<ul>
<li>创建RecyclerView实例</li>
<li>为RecyclerView设置LayoutManager，LayoutManager是一个抽象类，常用的实现类有LinearLayoutManager</li>
<li>如有必要，为RecyclerView设置ItemAnimator</li>
<li>如有必要，为RecyclerView设置ItemDecoration</li>
<li>继承RecyclerView.Adapter<VH extends ViewHolder>，实现getItemCount()/onCreateViewHolder(ViewGroup parent, int viewType)/onBindViewHolder(VH holder, int position)</li>
<li>在RecyclerView.Adapter中使用到的VH是ViewHolder的实现类，但ViewHolder虽然是一个抽象类，其中却没有需要我们实现的抽象方法，ViewHolder中关键的成员是itemView，即其承载的视图，可见性为public，可以直接获取</li>
</ul>
<h3 id="源码浅析"><a href="#源码浅析" class="headerlink" title="源码浅析"></a>源码浅析</h3><p>这部分跟随RecyclerView使用到的各个类的方法，看下这些关键方法是在何时被调用的</p>
<h3 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h3><ul>
<li><p>public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType)<br>在源码中查找onCreateViewHolder(ViewGroup parent, int viewType)的调用，能得到下图<br><img src="https://upload-images.jianshu.io/upload_images/5866715-20937ebf735b9cca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>内一层是外一层的调用，最终可以看到主要的调用在LinearLayoutManager的onLayoutChildren()；直接的调用方法是在RecyclerView的tryGetViewHolderForPositionByDeadline(int position, boolean dryRun, long deadlineNs)中有这么1段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">long</span> start = getNanoTime();</span><br><span class="line">    <span class="keyword">if</span> (deadlineNs != FOREVER_NS</span><br><span class="line">            &amp;&amp; !mRecyclerPool.willCreateInTime(type, start, deadlineNs)) &#123;</span><br><span class="line">        <span class="comment">// abort - we have a deadline we can&#x27;t meet</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    holder = mAdapter.createViewHolder(RecyclerView.<span class="keyword">this</span>, type);</span><br><span class="line">    <span class="keyword">if</span> (ALLOW_THREAD_GAP_WORK) &#123;</span><br><span class="line">        <span class="comment">// only bother finding nested RV if prefetching</span></span><br><span class="line">        RecyclerView innerView = findNestedRecyclerView(holder.itemView);</span><br><span class="line">        <span class="keyword">if</span> (innerView != <span class="keyword">null</span>) &#123;</span><br><span class="line">            holder.mNestedRecyclerView = <span class="keyword">new</span> WeakReference&lt;&gt;(innerView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> end = getNanoTime();</span><br><span class="line">    mRecyclerPool.factorInCreateTime(type, end - start);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;tryGetViewHolderForPositionByDeadline created new ViewHolder&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单来说，就是在layout()过程，如果holder为null，就调用这个方法来创建一个ViewHolder</p>
</li>
<li><p>public void onBindViewHolder(RecyclerView.ViewHolder holder, int position)<br>首先在RecyclerView.Adapter的bindViewHolder(VH holder, int position)中有直接调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bindViewHolder</span><span class="params">(VH holder, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    holder.mPosition = position;</span><br><span class="line">    <span class="keyword">if</span> (hasStableIds()) &#123;</span><br><span class="line">        holder.mItemId = getItemId(position);</span><br><span class="line">    &#125;</span><br><span class="line">    holder.setFlags(ViewHolder.FLAG_BOUND,</span><br><span class="line">            ViewHolder.FLAG_BOUND | ViewHolder.FLAG_UPDATE | ViewHolder.FLAG_INVALID</span><br><span class="line">                    | ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN);</span><br><span class="line">    TraceCompat.beginSection(TRACE_BIND_VIEW_TAG);</span><br><span class="line">    onBindViewHolder(holder, position, holder.getUnmodifiedPayloads());</span><br><span class="line">    holder.clearPayload();</span><br><span class="line">    <span class="keyword">final</span> ViewGroup.LayoutParams layoutParams = holder.itemView.getLayoutParams();</span><br><span class="line">    <span class="keyword">if</span> (layoutParams <span class="keyword">instanceof</span> RecyclerView.LayoutParams) &#123;</span><br><span class="line">        ((LayoutParams) layoutParams).mInsetsDirty = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TraceCompat.endSection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用完之后从其itemView中取出LayoutParams来进行处理<br>然后再源码中查找最终的调用链，结果如下：<br><img src="https://upload-images.jianshu.io/upload_images/5866715-af28fd79ed1d96b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>调用链中关键的一环是在RecyclerView的View getViewForPosition(int position, boolean dryRun)中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">View <span class="title">getViewForPosition</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">boolean</span> dryRun)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面先调用了tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS)方法，在前面分析onCreateViewHolder()的时候已经看到了，这个方法里尝试获取holder，取不到就创建holder，创建后就进行onBindViewHolder()的操作，bind完之后在这里可以看到，返回的是holder.itemView，因此在布局过程中，就是从这里获得了正确的itemView</p>
</li>
<li><p>int getItemCount()<br>这个方法的调用，在源码里看都是直接调用<br><img src="https://upload-images.jianshu.io/upload_images/5866715-0b8d7170c3e44049.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</li>
<li><p>int getItemViewType(int position)<br>这个方法在源码中的被调用位置主要是RecyclerView的tryGetViewHolderForPositionByDeadline()函数，这个函数在上面也已经出现过了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> type = mAdapter.getItemViewType(offsetPosition);</span><br><span class="line"><span class="comment">// 2) Find from scrap/cache via stable ids, if exists</span></span><br><span class="line"><span class="keyword">if</span> (mAdapter.hasStableIds()) &#123;</span><br><span class="line">    holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),</span><br><span class="line">            type, dryRun);</span><br><span class="line">    <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// update position</span></span><br><span class="line">        holder.mPosition = offsetPosition;</span><br><span class="line">        fromScrapOrHiddenOrCache = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这个方法拿到的type，就是在onCreateViewHolder()/onBindViewHolder()函数中的入参type</p>
</li>
</ul>
<h3 id="LayoutManager"><a href="#LayoutManager" class="headerlink" title="LayoutManager"></a>LayoutManager</h3><ul>
<li>public abstract LayoutParams generateDefaultLayoutParams();<br>查找源码，这个方法被调用的位置为RecyclerView的同名函数中：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> ViewGroup.<span class="function">LayoutParams <span class="title">generateDefaultLayoutParams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mLayout == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;RecyclerView has no LayoutManager&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mLayout.generateDefaultLayoutParams();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>public void onLayoutChildren(Recycler recycler, State state)<br>这个方法本身并不是abstract函数，但在LayoutManager中必须重写：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLayoutChildren</span><span class="params">(Recycler recycler, State state)</span> </span>&#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;You must override onLayoutChildren(Recycler recycler, State state) &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在源码中查找其调用，可以看到被调用的地方主要有两处：<br>首先是RecyclerView的dispatchLayoutStep1()函数<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mState.assertLayoutStep(State.STEP_START);</span><br><span class="line">    mState.mIsMeasuring = <span class="keyword">false</span>;</span><br><span class="line">    eatRequestLayout();</span><br><span class="line">    mViewInfoStore.clear();</span><br><span class="line">    onEnterLayoutOrScroll();</span><br><span class="line">    processAdapterUpdatesAndSetAnimationFlags();</span><br><span class="line">    saveFocusInfo();</span><br><span class="line">    mState.mTrackOldChangeHolders = mState.mRunSimpleAnimations &amp;&amp; mItemsChanged;</span><br><span class="line">    mItemsAddedOrRemoved = mItemsChanged = <span class="keyword">false</span>;</span><br><span class="line">    mState.mInPreLayout = mState.mRunPredictiveAnimations;</span><br><span class="line">    mState.mItemCount = mAdapter.getItemCount();</span><br><span class="line">    findMinMaxChildLayoutPositions(mMinMaxLayoutPositions);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mState.mRunSimpleAnimations) &#123;</span><br><span class="line">        <span class="comment">// Step 0: Find out where all non-removed items are, pre-layout</span></span><br><span class="line">        <span class="keyword">int</span> count = mChildHelper.getChildCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            <span class="keyword">final</span> ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));</span><br><span class="line">            <span class="keyword">if</span> (holder.shouldIgnore() || (holder.isInvalid() &amp;&amp; !mAdapter.hasStableIds())) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> ItemHolderInfo animationInfo = mItemAnimator</span><br><span class="line">                    .recordPreLayoutInformation(mState, holder,</span><br><span class="line">                            ItemAnimator.buildAdapterChangeFlagsForAnimations(holder),</span><br><span class="line">                            holder.getUnmodifiedPayloads());</span><br><span class="line">            mViewInfoStore.addToPreLayout(holder, animationInfo);</span><br><span class="line">            <span class="keyword">if</span> (mState.mTrackOldChangeHolders &amp;&amp; holder.isUpdated() &amp;&amp; !holder.isRemoved()</span><br><span class="line">                    &amp;&amp; !holder.shouldIgnore() &amp;&amp; !holder.isInvalid()) &#123;</span><br><span class="line">                <span class="keyword">long</span> key = getChangedHolderKey(holder);</span><br><span class="line">                <span class="comment">// This is NOT the only place where a ViewHolder is added to old change holders</span></span><br><span class="line">                <span class="comment">// list. There is another case where:</span></span><br><span class="line">                <span class="comment">//    * A VH is currently hidden but not deleted</span></span><br><span class="line">                <span class="comment">//    * The hidden item is changed in the adapter</span></span><br><span class="line">                <span class="comment">//    * Layout manager decides to layout the item in the pre-Layout pass (step1)</span></span><br><span class="line">                <span class="comment">// When this case is detected, RV will un-hide that view and add to the old</span></span><br><span class="line">                <span class="comment">// change holders list.</span></span><br><span class="line">                mViewInfoStore.addToOldChangeHolders(key, holder);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mState.mRunPredictiveAnimations) &#123;</span><br><span class="line">        <span class="comment">// Step 1: run prelayout: This will use the old positions of items. The layout manager</span></span><br><span class="line">        <span class="comment">// is expected to layout everything, even removed items (though not to add removed</span></span><br><span class="line">        <span class="comment">// items back to the container). This gives the pre-layout position of APPEARING views</span></span><br><span class="line">        <span class="comment">// which come into existence as part of the real layout.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save old positions so that LayoutManager can run its mapping logic.</span></span><br><span class="line">        saveOldPositions();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> didStructureChange = mState.mStructureChanged;</span><br><span class="line">        mState.mStructureChanged = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// temporarily disable flag because we are asking for previous layout</span></span><br><span class="line">        mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class="line">        mState.mStructureChanged = didStructureChange;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mChildHelper.getChildCount(); ++i) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = mChildHelper.getChildAt(i);</span><br><span class="line">            <span class="keyword">final</span> ViewHolder viewHolder = getChildViewHolderInt(child);</span><br><span class="line">            <span class="keyword">if</span> (viewHolder.shouldIgnore()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!mViewInfoStore.isInPreLayout(viewHolder)) &#123;</span><br><span class="line">                <span class="keyword">int</span> flags = ItemAnimator.buildAdapterChangeFlagsForAnimations(viewHolder);</span><br><span class="line">                <span class="keyword">boolean</span> wasHidden = viewHolder</span><br><span class="line">                        .hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);</span><br><span class="line">                <span class="keyword">if</span> (!wasHidden) &#123;</span><br><span class="line">                    flags |= ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">final</span> ItemHolderInfo animationInfo = mItemAnimator.recordPreLayoutInformation(</span><br><span class="line">                        mState, viewHolder, flags, viewHolder.getUnmodifiedPayloads());</span><br><span class="line">                <span class="keyword">if</span> (wasHidden) &#123;</span><br><span class="line">                    recordAnimationInfoIfBouncedHiddenView(viewHolder, animationInfo);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mViewInfoStore.addToAppearedInPreLayoutHolders(viewHolder, animationInfo);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// we don&#x27;t process disappearing list because they may re-appear in post layout pass.</span></span><br><span class="line">        clearOldPositions();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clearOldPositions();</span><br><span class="line">    &#125;</span><br><span class="line">    onExitLayoutOrScroll();</span><br><span class="line">    resumeRequestLayout(<span class="keyword">false</span>);</span><br><span class="line">    mState.mLayoutStep = State.STEP_LAYOUT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其次是dispatchLayoutStep2()中：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    eatRequestLayout();</span><br><span class="line">    onEnterLayoutOrScroll();</span><br><span class="line">    mState.assertLayoutStep(State.STEP_LAYOUT | State.STEP_ANIMATIONS);</span><br><span class="line">    mAdapterHelper.consumeUpdatesInOnePass();</span><br><span class="line">    mState.mItemCount = mAdapter.getItemCount();</span><br><span class="line">    mState.mDeletedInvisibleItemCountSincePreviousLayout = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2: Run layout</span></span><br><span class="line">    mState.mInPreLayout = <span class="keyword">false</span>;</span><br><span class="line">    mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class="line"></span><br><span class="line">    mState.mStructureChanged = <span class="keyword">false</span>;</span><br><span class="line">    mPendingSavedState = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// onLayoutChildren may have caused client code to disable item animations; re-check</span></span><br><span class="line">    mState.mRunSimpleAnimations = mState.mRunSimpleAnimations &amp;&amp; mItemAnimator != <span class="keyword">null</span>;</span><br><span class="line">    mState.mLayoutStep = State.STEP_ANIMATIONS;</span><br><span class="line">    onExitLayoutOrScroll();</span><br><span class="line">    resumeRequestLayout(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="ItemDecoration"><a href="#ItemDecoration" class="headerlink" title="ItemDecoration"></a>ItemDecoration</h3><ul>
<li><p>onDraw(Canvas c, RecyclerView parent, RecyclerView.State state)<br>这个函数作用在于绘制分割线，在源码中被调用的地方在RecyclerView中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDraw(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = mItemDecorations.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        mItemDecorations.get(i).onDraw(c, <span class="keyword">this</span>, mState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是RecyclerView的onDraw()函数中进行了分割线的绘制</p>
</li>
<li><p>public void getItemOffsets(Rect outRect, View view, RecyclerView parent, State state)<br>这个函数是，在每一项itemView绘制的时候，通过控制outRect的left/top/right/bottom值，来确定itemView四周留出来的范围，效果类似于padding或margin<br>在源码中被调用的地方有：<br><img src="https://upload-images.jianshu.io/upload_images/5866715-bf7a5a266bd563b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</li>
</ul>
<p>可以看到，主要是和measure有关的函数，很容易理解，因为就是在measure过程确定一个itemView占据多少空间</p>
<h3 id="ItemAnimator"><a href="#ItemAnimator" class="headerlink" title="ItemAnimator"></a>ItemAnimator</h3><p>ItemAnimator主要用于对item的插入、修改、删除动画处理主要有animateApprearance/animateDisappearance/animateChange/animatePersistence这几个在对应动作的函数</p>
<ul>
<li>public abstract boolean animateAppearance(@NonNull ViewHolder viewHolder, @Nullable ItemHolderInfo preLayoutInfo, @NonNull ItemHolderInfo postLayoutInfo);<br>在源码中查找animateAppearance的调用链为：<br><img src="https://upload-images.jianshu.io/upload_images/5866715-f9faa327825620a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>最终又是在熟悉的dispatchLayoutStep3()中被调用<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Step 4: Process view info lists and trigger animations</span></span><br><span class="line">mViewInfoStore.process(mViewInfoProcessCallback);</span><br></pre></td></tr></table></figure>
但这一行并不是很能看出怎么就调用了animateAppearance，看下再上一步的调用：<br><img src="https://upload-images.jianshu.io/upload_images/5866715-410a68952c1c2acf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
</ul>
<p>可以看到在调用process()函数的时候，是有根据record.flags来判断应该执行的是哪个处理</p>
<ul>
<li><p> public abstract boolean animateDisappearance(@NonNull ViewHolder viewHolder, @NonNull ItemHolderInfo preLayoutInfo, @Nullable ItemHolderInfo postLayoutInfo)<br>在源码中查找其调用位置：<br><img src="https://upload-images.jianshu.io/upload_images/5866715-79c3bdf424c8368c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>可以看到跟animateAppearance一样，最终都是被dispatchLayoutStep3()调用</p>
</li>
<li><p>public abstract boolean animateChange(@NonNull ViewHolder oldHolder,</p>
<pre><code>          @NonNull ViewHolder newHolder,
          @NonNull ItemHolderInfo preLayoutInfo, @NonNull ItemHolderInfo postLayoutInfo)
</code></pre>
<p>这个函数的调用链和上述一致，就不重复贴图了</p>
</li>
</ul>
<ul>
<li>public abstract boolean animatePersistence(@NonNull ViewHolder viewHolder,<pre><code>          @NonNull ItemHolderInfo preLayoutInfo, @NonNull ItemHolderInfo postLayoutInfo);
</code></pre>
这个函数的调用链依然和上述一致</li>
</ul>
]]></content>
      <tags>
        <tag>Android源码学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Android TextView源码浅析之Layout</title>
    <url>/2021/04/16/Android-TextView%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90%E4%B9%8BLayout/</url>
    <content><![CDATA[<h3 id="OverView"><a href="#OverView" class="headerlink" title="OverView"></a>OverView</h3><p>在上一篇从顶层整体流程分析TextView时能看到Layout这个重要概念，无论是onMeasure()过程还是onDraw()过程，主要工作都是由Layout来完成。<br>Layout类负责的作用是，完成TextView的排版，包括折行、省略等等。</p>
<h3 id="TextView-makeNewLayout"><a href="#TextView-makeNewLayout" class="headerlink" title="TextView.makeNewLayout()"></a>TextView.makeNewLayout()</h3><p>在上一篇的分析中，在onMeasure()过程，会调用到TextView的makeNewLayout()方法，现在来看下它的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeNewLayout</span><span class="params">(<span class="keyword">int</span> wantWidth, <span class="keyword">int</span> hintWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">                             BoringLayout.Metrics boring,</span></span></span><br><span class="line"><span class="function"><span class="params">                             BoringLayout.Metrics hintBoring,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> ellipsisWidth, <span class="keyword">boolean</span> bringIntoView)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 暂停走马灯动画</span></span><br><span class="line">    stopMarquee();</span><br><span class="line"></span><br><span class="line">    mOldMaximum = mMaximum;</span><br><span class="line">    mOldMaxMode = mMaxMode;</span><br><span class="line"></span><br><span class="line">    mHighlightPathBogus = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wantWidth &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        wantWidth = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hintWidth &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        hintWidth = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 1.获取对齐方式</span></span><br><span class="line">    Layout.Alignment alignment = getLayoutAlignment();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> testDirChange = mSingleLine &amp;&amp; mLayout != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; (alignment == Layout.Alignment.ALIGN_NORMAL</span><br><span class="line">                    || alignment == Layout.Alignment.ALIGN_OPPOSITE);</span><br><span class="line">    <span class="keyword">int</span> oldDir = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (testDirChange) oldDir = mLayout.getParagraphDirection(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">boolean</span> shouldEllipsize = mEllipsize != <span class="keyword">null</span> &amp;&amp; getKeyListener() == <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 2.处理省略方式</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> switchEllipsize = mEllipsize == TruncateAt.MARQUEE</span><br><span class="line">            &amp;&amp; mMarqueeFadeMode != MARQUEE_FADE_NORMAL;</span><br><span class="line">    TruncateAt effectiveEllipsize = mEllipsize;</span><br><span class="line">    <span class="keyword">if</span> (mEllipsize == TruncateAt.MARQUEE</span><br><span class="line">            &amp;&amp; mMarqueeFadeMode == MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) &#123;</span><br><span class="line">        effectiveEllipsize = TruncateAt.END_SMALL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.获取文字方向</span></span><br><span class="line">    <span class="keyword">if</span> (mTextDir == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mTextDir = getTextDirectionHeuristic();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.通过上述信息，构建mLayout</span></span><br><span class="line">    mLayout = makeSingleLayout(wantWidth, boring, ellipsisWidth, alignment, shouldEllipsize,</span><br><span class="line">            effectiveEllipsize, effectiveEllipsize == mEllipsize);</span><br><span class="line">    <span class="keyword">if</span> (switchEllipsize) &#123;</span><br><span class="line">        TruncateAt oppositeEllipsize = effectiveEllipsize == TruncateAt.MARQUEE</span><br><span class="line">                ? TruncateAt.END : TruncateAt.MARQUEE;</span><br><span class="line">        mSavedMarqueeModeLayout = makeSingleLayout(wantWidth, boring, ellipsisWidth, alignment,</span><br><span class="line">                shouldEllipsize, oppositeEllipsize, effectiveEllipsize != mEllipsize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shouldEllipsize = mEllipsize != <span class="keyword">null</span>;</span><br><span class="line">    mHintLayout = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 5.构建出用于显示hint的Layout</span></span><br><span class="line">    <span class="keyword">if</span> (mHint != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shouldEllipsize) hintWidth = wantWidth;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hintBoring == UNKNOWN_BORING) &#123;</span><br><span class="line">            hintBoring = BoringLayout.isBoring(mHint, mTextPaint, mTextDir,</span><br><span class="line">                                               mHintBoring);</span><br><span class="line">            <span class="keyword">if</span> (hintBoring != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mHintBoring = hintBoring;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hintBoring != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hintBoring.width &lt;= hintWidth</span><br><span class="line">                    &amp;&amp; (!shouldEllipsize || hintBoring.width &lt;= ellipsisWidth)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mSavedHintLayout != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mHintLayout = mSavedHintLayout.replaceOrMake(mHint, mTextPaint,</span><br><span class="line">                            hintWidth, alignment, mSpacingMult, mSpacingAdd,</span><br><span class="line">                            hintBoring, mIncludePad);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mHintLayout = BoringLayout.make(mHint, mTextPaint,</span><br><span class="line">                            hintWidth, alignment, mSpacingMult, mSpacingAdd,</span><br><span class="line">                            hintBoring, mIncludePad);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mSavedHintLayout = (BoringLayout) mHintLayout;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shouldEllipsize &amp;&amp; hintBoring.width &lt;= hintWidth) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mSavedHintLayout != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mHintLayout = mSavedHintLayout.replaceOrMake(mHint, mTextPaint,</span><br><span class="line">                            hintWidth, alignment, mSpacingMult, mSpacingAdd,</span><br><span class="line">                            hintBoring, mIncludePad, mEllipsize,</span><br><span class="line">                            ellipsisWidth);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mHintLayout = BoringLayout.make(mHint, mTextPaint,</span><br><span class="line">                            hintWidth, alignment, mSpacingMult, mSpacingAdd,</span><br><span class="line">                            hintBoring, mIncludePad, mEllipsize,</span><br><span class="line">                            ellipsisWidth);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mHintLayout == <span class="keyword">null</span>) &#123;</span><br><span class="line">            StaticLayout.Builder builder = StaticLayout.Builder.obtain(mHint, <span class="number">0</span>,</span><br><span class="line">                    mHint.length(), mTextPaint, hintWidth)</span><br><span class="line">                    .setAlignment(alignment)</span><br><span class="line">                    .setTextDirection(mTextDir)</span><br><span class="line">                    .setLineSpacing(mSpacingAdd, mSpacingMult)</span><br><span class="line">                    .setIncludePad(mIncludePad)</span><br><span class="line">                    .setUseLineSpacingFromFallbacks(mUseFallbackLineSpacing)</span><br><span class="line">                    .setBreakStrategy(mBreakStrategy)</span><br><span class="line">                    .setHyphenationFrequency(mHyphenationFrequency)</span><br><span class="line">                    .setJustificationMode(mJustificationMode)</span><br><span class="line">                    .setMaxLines(mMaxMode == LINES ? mMaximum : Integer.MAX_VALUE);</span><br><span class="line">            <span class="keyword">if</span> (shouldEllipsize) &#123;</span><br><span class="line">                builder.setEllipsize(mEllipsize)</span><br><span class="line">                        .setEllipsizedWidth(ellipsisWidth);</span><br><span class="line">            &#125;</span><br><span class="line">            mHintLayout = builder.build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bringIntoView || (testDirChange &amp;&amp; oldDir != mLayout.getParagraphDirection(<span class="number">0</span>))) &#123;</span><br><span class="line">        registerForPreDraw();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.重启走马灯动画</span></span><br><span class="line">    <span class="keyword">if</span> (mEllipsize == TextUtils.TruncateAt.MARQUEE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!compressText(ellipsisWidth)) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> height = mLayoutParams.height;</span><br><span class="line">            <span class="keyword">if</span> (height != LayoutParams.WRAP_CONTENT &amp;&amp; height != LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                startMarquee();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mRestartMarquee = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CursorControllers need a non-null mLayout</span></span><br><span class="line">    <span class="keyword">if</span> (mEditor != <span class="keyword">null</span>) mEditor.prepareCursorControllers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个函数中，最重要的是第4点的通过调用makeSingleLayout()方法构建出主Layout，但第5点构建hint的Layout也很值得学习，因为涉及了BoringLayout和StaticLayout这两个重要的概念：<br>BoringLayout和StaticLayout都是Layout的子类，其中BoringLayout是指不包含Span而且文本都是左到右而且能够一行展示下的文本，这种情况下使用BoringLayout能够节省不必要的计算；当hint不满足BoringLayout的条件时，会使用StaticLayout来进行布局</p>
<h3 id="TextView-makeSingleLayout-方法"><a href="#TextView-makeSingleLayout-方法" class="headerlink" title="TextView.makeSingleLayout()方法"></a>TextView.makeSingleLayout()方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Layout <span class="title">makeSingleLayout</span><span class="params">(<span class="keyword">int</span> wantWidth, BoringLayout.Metrics boring, <span class="keyword">int</span> ellipsisWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">        Layout.Alignment alignment, <span class="keyword">boolean</span> shouldEllipsize, TruncateAt effectiveEllipsize,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> useSaved)</span> </span>&#123;</span><br><span class="line">    Layout result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 这个方法的内部会判断文本是否是Spannable，是的话会使用DynamicLayout</span></span><br><span class="line">    <span class="keyword">if</span> (useDynamicLayout()) &#123;</span><br><span class="line">        <span class="keyword">final</span> DynamicLayout.Builder builder = DynamicLayout.Builder.obtain(mText, mTextPaint,</span><br><span class="line">                wantWidth)</span><br><span class="line">                .setDisplayText(mTransformed)</span><br><span class="line">                .setAlignment(alignment)</span><br><span class="line">                .setTextDirection(mTextDir)</span><br><span class="line">                .setLineSpacing(mSpacingAdd, mSpacingMult)</span><br><span class="line">                .setIncludePad(mIncludePad)</span><br><span class="line">                .setUseLineSpacingFromFallbacks(mUseFallbackLineSpacing)</span><br><span class="line">                .setBreakStrategy(mBreakStrategy)</span><br><span class="line">                .setHyphenationFrequency(mHyphenationFrequency)</span><br><span class="line">                .setJustificationMode(mJustificationMode)</span><br><span class="line">                .setEllipsize(getKeyListener() == <span class="keyword">null</span> ? effectiveEllipsize : <span class="keyword">null</span>)</span><br><span class="line">                .setEllipsizedWidth(ellipsisWidth);</span><br><span class="line">        result = builder.build();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否确定了是不是Boring</span></span><br><span class="line">        <span class="keyword">if</span> (boring == UNKNOWN_BORING) &#123;</span><br><span class="line">            boring = BoringLayout.isBoring(mTransformed, mTextPaint, mTextDir, mBoring);</span><br><span class="line">            <span class="keyword">if</span> (boring != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mBoring = boring;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这个条件如果成立，则证明是Boring</span></span><br><span class="line">        <span class="keyword">if</span> (boring != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 根据boring的不同属性，创建对应的Layout，if-else分支里都会尝试从mSavedLayout中创建，拿不到再调用BoringLayout.make()来创建新的</span></span><br><span class="line">            <span class="keyword">if</span> (boring.width &lt;= wantWidth</span><br><span class="line">                    &amp;&amp; (effectiveEllipsize == <span class="keyword">null</span> || boring.width &lt;= ellipsisWidth)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (useSaved &amp;&amp; mSavedLayout != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    result = mSavedLayout.replaceOrMake(mTransformed, mTextPaint,</span><br><span class="line">                            wantWidth, alignment, mSpacingMult, mSpacingAdd,</span><br><span class="line">                            boring, mIncludePad);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result = BoringLayout.make(mTransformed, mTextPaint,</span><br><span class="line">                            wantWidth, alignment, mSpacingMult, mSpacingAdd,</span><br><span class="line">                            boring, mIncludePad);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (useSaved) &#123;</span><br><span class="line">                    mSavedLayout = (BoringLayout) result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shouldEllipsize &amp;&amp; boring.width &lt;= wantWidth) &#123;</span><br><span class="line">                <span class="keyword">if</span> (useSaved &amp;&amp; mSavedLayout != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    result = mSavedLayout.replaceOrMake(mTransformed, mTextPaint,</span><br><span class="line">                            wantWidth, alignment, mSpacingMult, mSpacingAdd,</span><br><span class="line">                            boring, mIncludePad, effectiveEllipsize,</span><br><span class="line">                            ellipsisWidth);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result = BoringLayout.make(mTransformed, mTextPaint,</span><br><span class="line">                            wantWidth, alignment, mSpacingMult, mSpacingAdd,</span><br><span class="line">                            boring, mIncludePad, effectiveEllipsize,</span><br><span class="line">                            ellipsisWidth);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在这里result依然为null，证明不是Boring，需要用StaticLayout</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        StaticLayout.Builder builder = StaticLayout.Builder.obtain(mTransformed,</span><br><span class="line">                <span class="number">0</span>, mTransformed.length(), mTextPaint, wantWidth)</span><br><span class="line">                .setAlignment(alignment)</span><br><span class="line">                .setTextDirection(mTextDir)</span><br><span class="line">                .setLineSpacing(mSpacingAdd, mSpacingMult)</span><br><span class="line">                .setIncludePad(mIncludePad)</span><br><span class="line">                .setUseLineSpacingFromFallbacks(mUseFallbackLineSpacing)</span><br><span class="line">                .setBreakStrategy(mBreakStrategy)</span><br><span class="line">                .setHyphenationFrequency(mHyphenationFrequency)</span><br><span class="line">                .setJustificationMode(mJustificationMode)</span><br><span class="line">                .setMaxLines(mMaxMode == LINES ? mMaximum : Integer.MAX_VALUE);</span><br><span class="line">        <span class="keyword">if</span> (shouldEllipsize) &#123;</span><br><span class="line">            builder.setEllipsize(effectiveEllipsize)</span><br><span class="line">                    .setEllipsizedWidth(ellipsisWidth);</span><br><span class="line">        &#125;</span><br><span class="line">        result = builder.build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="StaticLayout-generate"><a href="#StaticLayout-generate" class="headerlink" title="StaticLayout.generate()"></a>StaticLayout.generate()</h3><p>在调用StaticLayout.Builder.build()方法之后，最终会调用到StaticLayout的generate()方法来构建出真正对应的Layout，generate()方法很长，还是采取分部分的方式来看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> CharSequence source = b.mText;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> bufStart = b.mStart;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> bufEnd = b.mEnd;</span><br><span class="line">    TextPaint paint = b.mPaint;</span><br><span class="line">    <span class="keyword">int</span> outerWidth = b.mWidth;</span><br><span class="line">    TextDirectionHeuristic textDir = b.mTextDir;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> fallbackLineSpacing = b.mFallbackLineSpacing;</span><br><span class="line">    <span class="keyword">float</span> spacingmult = b.mSpacingMult;</span><br><span class="line">    <span class="keyword">float</span> spacingadd = b.mSpacingAdd;</span><br><span class="line">    <span class="keyword">float</span> ellipsizedWidth = b.mEllipsizedWidth;</span><br><span class="line">    TextUtils.TruncateAt ellipsize = b.mEllipsize;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> addLastLineSpacing = b.mAddLastLineLineSpacing;</span><br><span class="line">    LineBreaks lineBreaks = <span class="keyword">new</span> LineBreaks(); </span><br><span class="line">    FloatArray widths = <span class="keyword">new</span> FloatArray();</span><br><span class="line"></span><br><span class="line">    mLineCount = <span class="number">0</span>;</span><br><span class="line">    mEllipsized = <span class="keyword">false</span>;</span><br><span class="line">    mMaxLineHeight = mMaximumVisibleLineCount &lt; <span class="number">1</span> ? <span class="number">0</span> : DEFAULT_MAX_LINE_HEIGHT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> v = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> needMultiply = (spacingmult != <span class="number">1</span> || spacingadd != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Paint.FontMetricsInt fm = b.mFontMetricsInt;</span><br><span class="line">    <span class="keyword">int</span>[] chooseHtv = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>第1部分是变量的初始化<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span>[] indents;</span><br><span class="line">    <span class="keyword">if</span> (mLeftIndents != <span class="keyword">null</span> || mRightIndents != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> leftLen = mLeftIndents == <span class="keyword">null</span> ? <span class="number">0</span> : mLeftIndents.length;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> rightLen = mRightIndents == <span class="keyword">null</span> ? <span class="number">0</span> : mRightIndents.length;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> indentsLen = Math.max(leftLen, rightLen);</span><br><span class="line">        indents = <span class="keyword">new</span> <span class="keyword">int</span>[indentsLen];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; leftLen; i++) &#123;</span><br><span class="line">            indents[i] = mLeftIndents[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rightLen; i++) &#123;</span><br><span class="line">            indents[i] += mRightIndents[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        indents = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> nativePtr = nInit(</span><br><span class="line">            b.mBreakStrategy, b.mHyphenationFrequency,</span><br><span class="line">            b.mJustificationMode != Layout.JUSTIFICATION_MODE_NONE,</span><br><span class="line">            indents, mLeftPaddings, mRightPaddings);</span><br></pre></td></tr></table></figure></li>
<li>第2部分是对文本缩进的处理，最终处理调用的是native函数实现，但实际这个if代码块，暂时还没有找到能够判断为true的地方<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrecomputedText.ParagraphInfo[] paragraphInfo = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">final</span> Spanned spanned = (source <span class="keyword">instanceof</span> Spanned) ? (Spanned) source : <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (source <span class="keyword">instanceof</span> PrecomputedText) &#123;</span><br><span class="line">    PrecomputedText precomputed = (PrecomputedText) source;</span><br><span class="line">    <span class="keyword">if</span> (precomputed.canUseMeasuredResult(bufStart, bufEnd, textDir, paint,</span><br><span class="line">              b.mBreakStrategy, b.mHyphenationFrequency)) &#123;</span><br><span class="line">        paragraphInfo = precomputed.getParagraphInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (paragraphInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> PrecomputedText.Params param = <span class="keyword">new</span> PrecomputedText.Params(paint, textDir,</span><br><span class="line">            b.mBreakStrategy, b.mHyphenationFrequency);</span><br><span class="line">    paragraphInfo = PrecomputedText.createMeasuredParagraphs(source, param, bufStart,</span><br><span class="line">            bufEnd, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第3部分是分析文本的段落信息，这里涉及到的PrecomputedText是包含了文本测量信息的类，通过它来构建文本能够节省一些开销</li>
</ul>
<p>接下来的部分，是根据段落信息，逐段地分析段落里的文本内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> paraIndex = <span class="number">0</span>; paraIndex &lt; paragraphInfo.length; paraIndex++) &#123;</span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">int</span> paraStart = paraIndex == <span class="number">0</span></span><br><span class="line">                 ? bufStart : paragraphInfo[paraIndex - <span class="number">1</span>].paragraphEnd;</span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">int</span> paraEnd = paragraphInfo[paraIndex].paragraphEnd;</span><br><span class="line"> <span class="comment">// ……</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>下面这几段的代码都发生在这个大的for循环中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> firstWidthLineCount = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> firstWidth = outerWidth;</span><br><span class="line"><span class="keyword">int</span> restWidth = outerWidth;</span><br><span class="line"></span><br><span class="line">LineHeightSpan[] chooseHt = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (spanned != <span class="keyword">null</span>) &#123;</span><br><span class="line">    LeadingMarginSpan[] sp = getParagraphSpans(spanned, paraStart, paraEnd,</span><br><span class="line">            LeadingMarginSpan.class);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sp.length; i++) &#123;</span><br><span class="line">        LeadingMarginSpan lms = sp[i];</span><br><span class="line">        firstWidth -= sp[i].getLeadingMargin(<span class="keyword">true</span>);</span><br><span class="line">        restWidth -= sp[i].getLeadingMargin(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// LeadingMarginSpan2 is odd.  The count affects all</span></span><br><span class="line">        <span class="comment">// leading margin spans, not just this particular one</span></span><br><span class="line">        <span class="keyword">if</span> (lms <span class="keyword">instanceof</span> LeadingMarginSpan2) &#123;</span><br><span class="line">            LeadingMarginSpan2 lms2 = (LeadingMarginSpan2) lms;</span><br><span class="line">            firstWidthLineCount = Math.max(firstWidthLineCount,</span><br><span class="line">                    lms2.getLeadingMarginLineCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>首先是宽度方面的分析，解析LeadingMarginSpan和LeadingMargin2<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    chooseHt = getParagraphSpans(spanned, paraStart, paraEnd, LineHeightSpan.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (chooseHt.length == <span class="number">0</span>) &#123;</span><br><span class="line">        chooseHt = <span class="keyword">null</span>; <span class="comment">// So that out() would not assume it has any contents</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (chooseHtv == <span class="keyword">null</span> || chooseHtv.length &lt; chooseHt.length) &#123;</span><br><span class="line">            chooseHtv = ArrayUtils.newUnpaddedIntArray(chooseHt.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chooseHt.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> o = spanned.getSpanStart(chooseHt[i]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (o &lt; paraStart) &#123;</span><br><span class="line">                <span class="comment">// starts in this layout, before the</span></span><br><span class="line">                <span class="comment">// current paragraph</span></span><br><span class="line"></span><br><span class="line">                chooseHtv[i] = getLineTop(getLineForOffset(o));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// starts in this paragraph</span></span><br><span class="line"></span><br><span class="line">                chooseHtv[i] = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>然后是行高的分析，通过解析LineHeightSpan来实现<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[] variableTabStops &#x3D; null;</span><br><span class="line">if (spanned !&#x3D; null) &#123;</span><br><span class="line">    TabStopSpan[] spans &#x3D; getParagraphSpans(spanned, paraStart,</span><br><span class="line">            paraEnd, TabStopSpan.class);</span><br><span class="line">    if (spans.length &gt; 0) &#123;</span><br><span class="line">        int[] stops &#x3D; new int[spans.length];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; spans.length; i++) &#123;</span><br><span class="line">            stops[i] &#x3D; spans[i].getTabStop();</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(stops, 0, stops.length);</span><br><span class="line">        variableTabStops &#x3D; stops;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>这一段通过解析TabStopSpan来获取tabStop，排序后存储在variableTabStop中<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final MeasuredParagraph measuredPara &#x3D; paragraphInfo[paraIndex].measured;</span><br><span class="line">final char[] chs &#x3D; measuredPara.getChars();</span><br><span class="line">final int[] spanEndCache &#x3D; measuredPara.getSpanEndCache().getRawArray();</span><br><span class="line">final int[] fmCache &#x3D; measuredPara.getFontMetrics().getRawArray();</span><br><span class="line">widths.resize(chs.length);</span><br></pre></td></tr></table></figure></li>
<li>这部分作用是从段落信息paragraphInfo[paraIndex]中取出测量相关的信息，后面准备使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> breakCount = nComputeLineBreaks(</span><br><span class="line">         nativePtr,</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Inputs</span></span><br><span class="line">         chs,</span><br><span class="line">         measuredPara.getNativePtr(),</span><br><span class="line">         paraEnd - paraStart,</span><br><span class="line">         firstWidth,</span><br><span class="line">         firstWidthLineCount,</span><br><span class="line">         restWidth,</span><br><span class="line">         variableTabStops,</span><br><span class="line">         TAB_INCREMENT,</span><br><span class="line">         mLineCount,</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Outputs</span></span><br><span class="line">         lineBreaks,</span><br><span class="line">         lineBreaks.breaks.length,</span><br><span class="line">         lineBreaks.breaks,</span><br><span class="line">         lineBreaks.widths,</span><br><span class="line">         lineBreaks.ascents,</span><br><span class="line">         lineBreaks.descents,</span><br><span class="line">         lineBreaks.flags,</span><br><span class="line">         widths.getRawArray());</span><br><span class="line"></span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">int</span>[] breaks = lineBreaks.breaks;</span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">float</span>[] lineWidths = lineBreaks.widths;</span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">float</span>[] ascents = lineBreaks.ascents;</span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">float</span>[] descents = lineBreaks.descents;</span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">int</span>[] flags = lineBreaks.flags;</span><br></pre></td></tr></table></figure>
<ul>
<li>这一段是根据前述步骤的宽度、行宽等信息，调用native的方法进行了折行处理，处理后的结果在lineBreaks中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> remainingLineCount = mMaximumVisibleLineCount - mLineCount;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> ellipsisMayBeApplied = ellipsize != <span class="keyword">null</span></span><br><span class="line">        &amp;&amp; (ellipsize == TextUtils.TruncateAt.END</span><br><span class="line">            || (mMaximumVisibleLineCount == <span class="number">1</span></span><br><span class="line">                    &amp;&amp; ellipsize != TextUtils.TruncateAt.MARQUEE));</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> &lt; remainingLineCount &amp;&amp; remainingLineCount &lt; breakCount</span><br><span class="line">        &amp;&amp; ellipsisMayBeApplied) &#123;</span><br><span class="line">    <span class="comment">// Calculate width and flag.</span></span><br><span class="line">    <span class="keyword">float</span> width = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>; <span class="comment">// XXX May need to also have starting hyphen edit</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = remainingLineCount - <span class="number">1</span>; i &lt; breakCount; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == breakCount - <span class="number">1</span>) &#123;</span><br><span class="line">            width += lineWidths[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = (i == <span class="number">0</span> ? <span class="number">0</span> : breaks[i - <span class="number">1</span>]); j &lt; breaks[i]; j++) &#123;</span><br><span class="line">                width += widths.get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        flag |= flags[i] &amp; TAB_MASK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Treat the last line and overflowed lines as a single line.</span></span><br><span class="line">    breaks[remainingLineCount - <span class="number">1</span>] = breaks[breakCount - <span class="number">1</span>];</span><br><span class="line">    lineWidths[remainingLineCount - <span class="number">1</span>] = width;</span><br><span class="line">    flags[remainingLineCount - <span class="number">1</span>] = flag;</span><br><span class="line"></span><br><span class="line">    breakCount = remainingLineCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这里主要是对末行以及省略的相应处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> here = paraStart;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fmTop = <span class="number">0</span>, fmBottom = <span class="number">0</span>, fmAscent = <span class="number">0</span>, fmDescent = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> fmCacheIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> spanEndCacheIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> breakIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> spanStart = paraStart, spanEnd; spanStart &lt; paraEnd; spanStart = spanEnd) &#123;</span><br><span class="line">        <span class="comment">// retrieve end of span</span></span><br><span class="line">        spanEnd = spanEndCache[spanEndCacheIndex++];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// retrieve cached metrics, order matches above</span></span><br><span class="line">        fm.top = fmCache[fmCacheIndex * <span class="number">4</span> + <span class="number">0</span>];</span><br><span class="line">        fm.bottom = fmCache[fmCacheIndex * <span class="number">4</span> + <span class="number">1</span>];</span><br><span class="line">        fm.ascent = fmCache[fmCacheIndex * <span class="number">4</span> + <span class="number">2</span>];</span><br><span class="line">        fm.descent = fmCache[fmCacheIndex * <span class="number">4</span> + <span class="number">3</span>];</span><br><span class="line">        fmCacheIndex++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fm.top &lt; fmTop) &#123;</span><br><span class="line">            fmTop = fm.top;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fm.ascent &lt; fmAscent) &#123;</span><br><span class="line">            fmAscent = fm.ascent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fm.descent &gt; fmDescent) &#123;</span><br><span class="line">            fmDescent = fm.descent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fm.bottom &gt; fmBottom) &#123;</span><br><span class="line">            fmBottom = fm.bottom;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// skip breaks ending before current span range</span></span><br><span class="line">        <span class="keyword">while</span> (breakIndex &lt; breakCount &amp;&amp; paraStart + breaks[breakIndex] &lt; spanStart) &#123;</span><br><span class="line">            breakIndex++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (breakIndex &lt; breakCount &amp;&amp; paraStart + breaks[breakIndex] &lt;= spanEnd) &#123;</span><br><span class="line">            <span class="keyword">int</span> endPos = paraStart + breaks[breakIndex];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> moreChars = (endPos &lt; bufEnd);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> ascent = fallbackLineSpacing</span><br><span class="line">                    ? Math.min(fmAscent, Math.round(ascents[breakIndex]))</span><br><span class="line">                    : fmAscent;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> descent = fallbackLineSpacing</span><br><span class="line">                    ? Math.max(fmDescent, Math.round(descents[breakIndex]))</span><br><span class="line">                    : fmDescent;</span><br><span class="line">            v = out(source, here, endPos,</span><br><span class="line">                    ascent, descent, fmTop, fmBottom,</span><br><span class="line">                    v, spacingmult, spacingadd, chooseHt, chooseHtv, fm,</span><br><span class="line">                    flags[breakIndex], needMultiply, measuredPara, bufEnd,</span><br><span class="line">                    includepad, trackpad, addLastLineSpacing, chs, widths.getRawArray(),</span><br><span class="line">                    paraStart, ellipsize, ellipsizedWidth, lineWidths[breakIndex],</span><br><span class="line">                    paint, moreChars);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (endPos &lt; spanEnd) &#123;</span><br><span class="line">                <span class="comment">// preserve metrics for current span</span></span><br><span class="line">                fmTop = fm.top;</span><br><span class="line">                fmBottom = fm.bottom;</span><br><span class="line">                fmAscent = fm.ascent;</span><br><span class="line">                fmDescent = fm.descent;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fmTop = fmBottom = fmAscent = fmDescent = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            here = endPos;</span><br><span class="line">            breakIndex++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mLineCount &gt;= mMaximumVisibleLineCount &amp;&amp; mEllipsized) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (paraEnd == bufEnd) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这一段是对段落中的Span和这行进行处理，其中fmCache是前面PrecomputeText在测量时已经测算好的各个Span在top/bottom/ascent/descent这几个维度上的值，并缓存在fmCache中，因此在这里需要计算某个段落的字体属性时，直接从fmCache中取出即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((bufEnd == bufStart || source.charAt(bufEnd - <span class="number">1</span>) == CHAR_NEW_LINE)</span><br><span class="line">                    &amp;&amp; mLineCount &lt; mMaximumVisibleLineCount) &#123;</span><br><span class="line">                <span class="keyword">final</span> MeasuredParagraph measuredPara =</span><br><span class="line">                        MeasuredParagraph.buildForBidi(source, bufEnd, bufEnd, textDir, <span class="keyword">null</span>);</span><br><span class="line">                paint.getFontMetricsInt(fm);</span><br><span class="line">                v = out(source,</span><br><span class="line">                        bufEnd, bufEnd, fm.ascent, fm.descent,</span><br><span class="line">                        fm.top, fm.bottom,</span><br><span class="line">                        v,</span><br><span class="line">                        spacingmult, spacingadd, <span class="keyword">null</span>,</span><br><span class="line">                        <span class="keyword">null</span>, fm, <span class="number">0</span>,</span><br><span class="line">                        needMultiply, measuredPara, bufEnd,</span><br><span class="line">                        includepad, trackpad, addLastLineSpacing, <span class="keyword">null</span>,</span><br><span class="line">                        <span class="keyword">null</span>, bufStart, ellipsize,</span><br><span class="line">                        ellipsizedWidth, <span class="number">0</span>, paint, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意最后这一段的成立条件：结束为止和起始位置相等，并且前一个字符是换行符，那证明是一个新的空白段落，也需要作为一个单独的段落进行单独处理</li>
</ul>
<h3 id="StaticLayout-out"><a href="#StaticLayout-out" class="headerlink" title="StaticLayout.out()"></a>StaticLayout.out()</h3><p>上面已经看完了整体的StaticLayout.generate()函数，其中看到有对out()函数的调用，out()函数完整的签名如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">out</span><span class="params">(<span class="keyword">final</span> CharSequence text, <span class="keyword">final</span> <span class="keyword">int</span> start, <span class="keyword">final</span> <span class="keyword">int</span> end, <span class="keyword">int</span> above, <span class="keyword">int</span> below,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> top, <span class="keyword">int</span> bottom, <span class="keyword">int</span> v, <span class="keyword">final</span> <span class="keyword">float</span> spacingmult, <span class="keyword">final</span> <span class="keyword">float</span> spacingadd,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> LineHeightSpan[] chooseHt, <span class="keyword">final</span> <span class="keyword">int</span>[] chooseHtv, <span class="keyword">final</span> Paint.FontMetricsInt fm,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> <span class="keyword">int</span> flags, <span class="keyword">final</span> <span class="keyword">boolean</span> needMultiply, <span class="meta">@NonNull</span> <span class="keyword">final</span> MeasuredParagraph measured,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> <span class="keyword">int</span> bufEnd, <span class="keyword">final</span> <span class="keyword">boolean</span> includePad, <span class="keyword">final</span> <span class="keyword">boolean</span> trackPad,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> <span class="keyword">boolean</span> addLastLineLineSpacing, <span class="keyword">final</span> <span class="keyword">char</span>[] chs, <span class="keyword">final</span> <span class="keyword">float</span>[] widths,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> <span class="keyword">int</span> widthStart, <span class="keyword">final</span> TextUtils.TruncateAt ellipsize, <span class="keyword">final</span> <span class="keyword">float</span> ellipsisWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> <span class="keyword">float</span> textWidth, <span class="keyword">final</span> TextPaint paint, <span class="keyword">final</span> <span class="keyword">boolean</span> moreChars)</span></span></span><br></pre></td></tr></table></figure>
<p>参数非常多，但看参数名基本能看出和此前的generate()函数基本是对应的<br>接下来分段看下它做了什么</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> j = mLineCount;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> off = j * mColumns;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> want = off + mColumns + TOP;</span><br><span class="line"><span class="keyword">int</span>[] lines = mLines;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> dir = measured.getParagraphDir();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (want &gt;= lines.length) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span>[] grow = ArrayUtils.newUnpaddedIntArray(GrowingArrayUtils.growSize(want));</span><br><span class="line">    System.arraycopy(lines, <span class="number">0</span>, grow, <span class="number">0</span>, lines.length);</span><br><span class="line">    mLines = grow;</span><br><span class="line">    lines = grow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (j &gt;= mLineDirections.length) &#123;</span><br><span class="line">    <span class="keyword">final</span> Directions[] grow = ArrayUtils.newUnpaddedArray(Directions.class,</span><br><span class="line">            GrowingArrayUtils.growSize(j));</span><br><span class="line">    System.arraycopy(mLineDirections, <span class="number">0</span>, grow, <span class="number">0</span>, mLineDirections.length);</span><br><span class="line">    mLineDirections = grow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第1部分是判断mLines/mLineDirections数组是否需要扩容以及在需要时进行扩容操作，mLines数组中存储的是每行的信息，包括每一行的信息包括START/TOP/DESCENT/HYPHEN/ELLIPSIS_START/ELLIPSIS_COUNT</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (chooseHt != <span class="keyword">null</span>) &#123;</span><br><span class="line">    fm.ascent = above;</span><br><span class="line">    fm.descent = below;</span><br><span class="line">    fm.top = top;</span><br><span class="line">    fm.bottom = bottom;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chooseHt.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chooseHt[i] <span class="keyword">instanceof</span> LineHeightSpan.WithDensity) &#123;</span><br><span class="line">            ((LineHeightSpan.WithDensity) chooseHt[i])</span><br><span class="line">                    .chooseHeight(text, start, end, chooseHtv[i], v, fm, paint);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            chooseHt[i].chooseHeight(text, start, end, chooseHtv[i], v, fm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    above = fm.ascent;</span><br><span class="line">    below = fm.descent;</span><br><span class="line">    top = fm.top;</span><br><span class="line">    bottom = fm.bottom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第2部分是对高度进行处理，得到的结果存储在above/below/top/bottom变量中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ellipsize != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// If there is only one line, then do any type of ellipsis except when it is MARQUEE</span></span><br><span class="line">    <span class="comment">// if there are multiple lines, just allow END ellipsis on the last line</span></span><br><span class="line">    <span class="keyword">boolean</span> forceEllipsis = moreChars &amp;&amp; (mLineCount + <span class="number">1</span> == mMaximumVisibleLineCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> doEllipsis =</span><br><span class="line">            (((mMaximumVisibleLineCount == <span class="number">1</span> &amp;&amp; moreChars) || (firstLine &amp;&amp; !moreChars)) &amp;&amp;</span><br><span class="line">                    ellipsize != TextUtils.TruncateAt.MARQUEE) ||</span><br><span class="line">            (!firstLine &amp;&amp; (currentLineIsTheLastVisibleOne || !moreChars) &amp;&amp;</span><br><span class="line">                    ellipsize == TextUtils.TruncateAt.END);</span><br><span class="line">    <span class="keyword">if</span> (doEllipsis) &#123;</span><br><span class="line">        calculateEllipsis(start, end, widths, widthStart,</span><br><span class="line">                ellipsisWidth, ellipsize, j,</span><br><span class="line">                textWidth, paint, forceEllipsis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第3部分是对省略的计算和处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> lastLine;</span><br><span class="line"><span class="keyword">if</span> (mEllipsized) &#123;</span><br><span class="line">    lastLine = <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> lastCharIsNewLine = widthStart != bufEnd &amp;&amp; bufEnd &gt; <span class="number">0</span></span><br><span class="line">            &amp;&amp; text.charAt(bufEnd - <span class="number">1</span>) == CHAR_NEW_LINE;</span><br><span class="line">    <span class="keyword">if</span> (end == bufEnd &amp;&amp; !lastCharIsNewLine) &#123;</span><br><span class="line">        lastLine = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start == bufEnd &amp;&amp; lastCharIsNewLine) &#123;</span><br><span class="line">        lastLine = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lastLine = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (firstLine) &#123;</span><br><span class="line">    <span class="keyword">if</span> (trackPad) &#123;</span><br><span class="line">        mTopPadding = top - above;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (includePad) &#123;</span><br><span class="line">        above = top;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> extra;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (lastLine) &#123;</span><br><span class="line">    <span class="keyword">if</span> (trackPad) &#123;</span><br><span class="line">        mBottomPadding = bottom - below;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (includePad) &#123;</span><br><span class="line">        below = bottom;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (needMultiply &amp;&amp; (addLastLineLineSpacing || !lastLine)) &#123;</span><br><span class="line">    <span class="keyword">double</span> ex = (below - above) * (spacingmult - <span class="number">1</span>) + spacingadd;</span><br><span class="line">    <span class="keyword">if</span> (ex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        extra = (<span class="keyword">int</span>)(ex + EXTRA_ROUNDING);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        extra = -(<span class="keyword">int</span>)(-ex + EXTRA_ROUNDING);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    extra = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第4部分是对首行末行的特殊处理，因为要考虑上下留白；还有对行间距的特殊处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lines[off + START] = start;</span><br><span class="line">  lines[off + TOP] = v;</span><br><span class="line">  lines[off + DESCENT] = below + extra;</span><br><span class="line">  lines[off + EXTRA] = extra;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// special case for non-ellipsized last visible line when maxLines is set</span></span><br><span class="line">  <span class="comment">// store the height as if it was ellipsized</span></span><br><span class="line">  <span class="keyword">if</span> (!mEllipsized &amp;&amp; currentLineIsTheLastVisibleOne) &#123;</span><br><span class="line">      <span class="comment">// below calculation as if it was the last line</span></span><br><span class="line">      <span class="keyword">int</span> maxLineBelow = includePad ? bottom : below;</span><br><span class="line">      <span class="comment">// similar to the calculation of v below, without the extra.</span></span><br><span class="line">      mMaxLineHeight = v + (maxLineBelow - above);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  v += (below - above) + extra;</span><br><span class="line">  lines[off + mColumns + START] = end;</span><br><span class="line">  lines[off + mColumns + TOP] = v;</span><br><span class="line"></span><br><span class="line">  lines[off + TAB] |= flags &amp; TAB_MASK;</span><br><span class="line">  lines[off + HYPHEN] = flags;</span><br><span class="line">  lines[off + DIR] |= dir &lt;&lt; DIR_SHIFT;</span><br><span class="line">  mLineDirections[j] = measured.getDirections(start - widthStart, end - widthStart);</span><br><span class="line"></span><br><span class="line">  mLineCount++;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br></pre></td></tr></table></figure>
<ul>
<li>第5部分就是将处理完的每一行的信息，都记录到lines数组中了</li>
</ul>
<p><strong>从这里就能看出out函数的作用是对Layout中的每一行文本进行分析，最重要的产出就是得到mLines数组</strong></p>
<h3 id="Layout-draw"><a href="#Layout-draw" class="headerlink" title="Layout.draw()"></a>Layout.draw()</h3><p>在上一篇TextView的整体流程中我们看到，TextView的onDraw()执行过程中，最终实际上是通过Layout.draw()函数完成的，而在Layout前面的分析中我们已经得到了每一行的信息，所以接下来看下Layout.draw()函数是怎么执行的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas, Path highlight, Paint highlightPaint,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> cursorOffsetVertical)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> lineRange = getLineRangeForDraw(canvas);</span><br><span class="line">    <span class="keyword">int</span> firstLine = TextUtils.unpackRangeStartFromLong(lineRange);</span><br><span class="line">    <span class="keyword">int</span> lastLine = TextUtils.unpackRangeEndFromLong(lineRange);</span><br><span class="line">    <span class="keyword">if</span> (lastLine &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    drawBackground(canvas, highlight, highlightPaint, cursorOffsetVertical,</span><br><span class="line">            firstLine, lastLine);</span><br><span class="line">    drawText(canvas, firstLine, lastLine);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Layout.draw()实际上分成了两部分，drawBackground()和drawText()，下面看下它们的实现：</p>
<h3 id="Layout-drawBackground"><a href="#Layout-drawBackground" class="headerlink" title="Layout.drawBackground()"></a>Layout.drawBackground()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void drawBackground(Canvas canvas, Path highlight, Paint highlightPaint,</span><br><span class="line">        int cursorOffsetVertical, int firstLine, int lastLine) &#123;</span><br><span class="line">    &#x2F;&#x2F; First, draw LineBackgroundSpans.</span><br><span class="line">    &#x2F;&#x2F; LineBackgroundSpans know nothing about the alignment, margins, or</span><br><span class="line">    &#x2F;&#x2F; direction of the layout or line.  XXX: Should they?</span><br><span class="line">    &#x2F;&#x2F; They are evaluated at each line.</span><br><span class="line">    if (mSpannedText) &#123;</span><br><span class="line">        if (mLineBackgroundSpans &#x3D;&#x3D; null) &#123;</span><br><span class="line">            mLineBackgroundSpans &#x3D; new SpanSet&lt;LineBackgroundSpan&gt;(LineBackgroundSpan.class);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Spanned buffer &#x3D; (Spanned) mText;</span><br><span class="line">        int textLength &#x3D; buffer.length();</span><br><span class="line">        mLineBackgroundSpans.init(buffer, 0, textLength);</span><br><span class="line"></span><br><span class="line">        if (mLineBackgroundSpans.numberOfSpans &gt; 0) &#123;</span><br><span class="line">            int previousLineBottom &#x3D; getLineTop(firstLine);</span><br><span class="line">            int previousLineEnd &#x3D; getLineStart(firstLine);</span><br><span class="line">            ParagraphStyle[] spans &#x3D; NO_PARA_SPANS;</span><br><span class="line">            int spansLength &#x3D; 0;</span><br><span class="line">            TextPaint paint &#x3D; mPaint;</span><br><span class="line">            int spanEnd &#x3D; 0;</span><br><span class="line">            final int width &#x3D; mWidth;</span><br><span class="line">            for (int i &#x3D; firstLine; i &lt;&#x3D; lastLine; i++) &#123;</span><br><span class="line">                int start &#x3D; previousLineEnd;</span><br><span class="line">                int end &#x3D; getLineStart(i + 1);</span><br><span class="line">                previousLineEnd &#x3D; end;</span><br><span class="line"></span><br><span class="line">                int ltop &#x3D; previousLineBottom;</span><br><span class="line">                int lbottom &#x3D; getLineTop(i + 1);</span><br><span class="line">                previousLineBottom &#x3D; lbottom;</span><br><span class="line">                int lbaseline &#x3D; lbottom - getLineDescent(i);</span><br><span class="line"></span><br><span class="line">                if (start &gt;&#x3D; spanEnd) &#123;</span><br><span class="line">                    &#x2F;&#x2F; These should be infrequent, so we&#39;ll use this so that</span><br><span class="line">                    &#x2F;&#x2F; we don&#39;t have to check as often.</span><br><span class="line">                    spanEnd &#x3D; mLineBackgroundSpans.getNextTransition(start, textLength);</span><br><span class="line">                    &#x2F;&#x2F; All LineBackgroundSpans on a line contribute to its background.</span><br><span class="line">                    spansLength &#x3D; 0;</span><br><span class="line">                    &#x2F;&#x2F; Duplication of the logic of getParagraphSpans</span><br><span class="line">                    if (start !&#x3D; end || start &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                        &#x2F;&#x2F; Equivalent to a getSpans(start, end), but filling the &#39;spans&#39; local</span><br><span class="line">                        &#x2F;&#x2F; array instead to reduce memory allocation</span><br><span class="line">                        for (int j &#x3D; 0; j &lt; mLineBackgroundSpans.numberOfSpans; j++) &#123;</span><br><span class="line">                            &#x2F;&#x2F; equal test is valid since both intervals are not empty by</span><br><span class="line">                            &#x2F;&#x2F; construction</span><br><span class="line">                            if (mLineBackgroundSpans.spanStarts[j] &gt;&#x3D; end ||</span><br><span class="line">                                    mLineBackgroundSpans.spanEnds[j] &lt;&#x3D; start) continue;</span><br><span class="line">                            spans &#x3D; GrowingArrayUtils.append(</span><br><span class="line">                                    spans, spansLength, mLineBackgroundSpans.spans[j]);</span><br><span class="line">                            spansLength++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                for (int n &#x3D; 0; n &lt; spansLength; n++) &#123;</span><br><span class="line">                    LineBackgroundSpan lineBackgroundSpan &#x3D; (LineBackgroundSpan) spans[n];</span><br><span class="line">                    lineBackgroundSpan.drawBackground(canvas, paint, 0, width,</span><br><span class="line">                            ltop, lbaseline, lbottom,</span><br><span class="line">                            buffer, start, end, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mLineBackgroundSpans.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; There can be a highlight even without spans if we are drawing</span><br><span class="line">    &#x2F;&#x2F; a non-spanned transformation of a spanned editing buffer.</span><br><span class="line">    if (highlight !&#x3D; null) &#123;</span><br><span class="line">        if (cursorOffsetVertical !&#x3D; 0) canvas.translate(0, cursorOffsetVertical);</span><br><span class="line">        canvas.drawPath(highlight, highlightPaint);</span><br><span class="line">        if (cursorOffsetVertical !&#x3D; 0) canvas.translate(0, -cursorOffsetVertical);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>代码不长，可以看到Layout的drawBackground()实际上是通过LineBackgroundSpan.drawBackground()来完成的，而LineBackgroundSpan只是一个接口，在Android源码中并没有实现类，因此drawBackground()的实际绘制效果是使用时自己定义的</li>
</ul>
<h3 id="Layout-drawText"><a href="#Layout-drawText" class="headerlink" title="Layout.drawText()"></a>Layout.drawText()</h3><p><img src="https://upload-images.jianshu.io/upload_images/5866715-104ca2a82c54aaac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>drawText()方法整体内容如图，主要的工作在for循环中，从注释中能看出，drawText()的过程是，逐行绘制，下面看下这个for循环内部的逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> start = previousLineEnd;</span><br><span class="line">previousLineEnd = getLineStart(lineNum + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> justify = isJustificationRequired(lineNum);</span><br><span class="line"><span class="keyword">int</span> end = getLineVisibleEnd(lineNum, start, previousLineEnd);</span><br><span class="line">paint.setHyphenEdit(getHyphen(lineNum));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ltop = previousLineBottom;</span><br><span class="line"><span class="keyword">int</span> lbottom = getLineTop(lineNum + <span class="number">1</span>);</span><br><span class="line">previousLineBottom = lbottom;</span><br><span class="line"><span class="keyword">int</span> lbaseline = lbottom - getLineDescent(lineNum);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dir = getParagraphDirection(lineNum);</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = mWidth;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mSpannedText) &#123;</span><br><span class="line">    Spanned sp = (Spanned) buf;</span><br><span class="line">    <span class="keyword">int</span> textLength = buf.length();</span><br><span class="line">    <span class="keyword">boolean</span> isFirstParaLine = (start == <span class="number">0</span> || buf.charAt(start - <span class="number">1</span>) == <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// New batch of paragraph styles, collect into spans array.</span></span><br><span class="line">    <span class="comment">// Compute the alignment, last alignment style wins.</span></span><br><span class="line">    <span class="comment">// Reset tabStops, we&#x27;ll rebuild if we encounter a line with</span></span><br><span class="line">    <span class="comment">// tabs.</span></span><br><span class="line">    <span class="comment">// We expect paragraph spans to be relatively infrequent, use</span></span><br><span class="line">    <span class="comment">// spanEnd so that we can check less frequently.  Since</span></span><br><span class="line">    <span class="comment">// paragraph styles ought to apply to entire paragraphs, we can</span></span><br><span class="line">    <span class="comment">// just collect the ones present at the start of the paragraph.</span></span><br><span class="line">    <span class="comment">// If spanEnd is before the end of the paragraph, that&#x27;s not</span></span><br><span class="line">    <span class="comment">// our problem.</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt;= spanEnd &amp;&amp; (lineNum == firstLine || isFirstParaLine)) &#123;</span><br><span class="line">        spanEnd = sp.nextSpanTransition(start, textLength,</span><br><span class="line">                                        ParagraphStyle.class);</span><br><span class="line">        spans = getParagraphSpans(sp, start, spanEnd, ParagraphStyle.class);</span><br><span class="line"></span><br><span class="line">        paraAlign = mAlignment;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = spans.length - <span class="number">1</span>; n &gt;= <span class="number">0</span>; n--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (spans[n] <span class="keyword">instanceof</span> AlignmentSpan) &#123;</span><br><span class="line">                paraAlign = ((AlignmentSpan) spans[n]).getAlignment();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tabStopsIsInitialized = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Draw all leading margin spans.  Adjust left or right according</span></span><br><span class="line">    <span class="comment">// to the paragraph direction of the line.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> length = spans.length;</span><br><span class="line">    <span class="keyword">boolean</span> useFirstLineMargin = isFirstParaLine;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; length; n++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (spans[n] <span class="keyword">instanceof</span> LeadingMarginSpan2) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = ((LeadingMarginSpan2) spans[n]).getLeadingMarginLineCount();</span><br><span class="line">            <span class="keyword">int</span> startLine = getLineForOffset(sp.getSpanStart(spans[n]));</span><br><span class="line">            <span class="comment">// if there is more than one LeadingMarginSpan2, use</span></span><br><span class="line">            <span class="comment">// the count that is greatest</span></span><br><span class="line">            <span class="keyword">if</span> (lineNum &lt; startLine + count) &#123;</span><br><span class="line">                useFirstLineMargin = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; length; n++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (spans[n] <span class="keyword">instanceof</span> LeadingMarginSpan) &#123;</span><br><span class="line">            LeadingMarginSpan margin = (LeadingMarginSpan) spans[n];</span><br><span class="line">            <span class="keyword">if</span> (dir == DIR_RIGHT_TO_LEFT) &#123;</span><br><span class="line">                margin.drawLeadingMargin(canvas, paint, right, dir, ltop,</span><br><span class="line">                                         lbaseline, lbottom, buf,</span><br><span class="line">                                         start, end, isFirstParaLine, <span class="keyword">this</span>);</span><br><span class="line">                right -= margin.getLeadingMargin(useFirstLineMargin);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                margin.drawLeadingMargin(canvas, paint, left, dir, ltop,</span><br><span class="line">                                         lbaseline, lbottom, buf,</span><br><span class="line">                                         start, end, isFirstParaLine, <span class="keyword">this</span>);</span><br><span class="line">                left += margin.getLeadingMargin(useFirstLineMargin);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第1部分，主要是判断是不是Spanned，是的话需要获取影响ParagraphStyle的Span，然后判断其中是否有LeadingMarginSpan，有的话会调用其drawLeadingMargin()方法来绘制其段首的缩进效果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean hasTab &#x3D; getLineContainsTab(lineNum);</span><br><span class="line">&#x2F;&#x2F; Can&#39;t tell if we have tabs for sure, currently</span><br><span class="line">if (hasTab &amp;&amp; !tabStopsIsInitialized) &#123;</span><br><span class="line">    if (tabStops &#x3D;&#x3D; null) &#123;</span><br><span class="line">        tabStops &#x3D; new TabStops(TAB_INCREMENT, spans);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        tabStops.reset(TAB_INCREMENT, spans);</span><br><span class="line">    &#125;</span><br><span class="line">    tabStopsIsInitialized &#x3D; true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Determine whether the line aligns to normal, opposite, or center.</span><br><span class="line">Alignment align &#x3D; paraAlign;</span><br><span class="line">if (align &#x3D;&#x3D; Alignment.ALIGN_LEFT) &#123;</span><br><span class="line">    align &#x3D; (dir &#x3D;&#x3D; DIR_LEFT_TO_RIGHT) ?</span><br><span class="line">        Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;</span><br><span class="line">&#125; else if (align &#x3D;&#x3D; Alignment.ALIGN_RIGHT) &#123;</span><br><span class="line">    align &#x3D; (dir &#x3D;&#x3D; DIR_LEFT_TO_RIGHT) ?</span><br><span class="line">        Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int x;</span><br><span class="line">final int indentWidth;</span><br><span class="line">if (align &#x3D;&#x3D; Alignment.ALIGN_NORMAL) &#123;</span><br><span class="line">    if (dir &#x3D;&#x3D; DIR_LEFT_TO_RIGHT) &#123;</span><br><span class="line">        indentWidth &#x3D; getIndentAdjust(lineNum, Alignment.ALIGN_LEFT);</span><br><span class="line">        x &#x3D; left + indentWidth;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        indentWidth &#x3D; -getIndentAdjust(lineNum, Alignment.ALIGN_RIGHT);</span><br><span class="line">        x &#x3D; right - indentWidth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    int max &#x3D; (int)getLineExtent(lineNum, tabStops, false);</span><br><span class="line">    if (align &#x3D;&#x3D; Alignment.ALIGN_OPPOSITE) &#123;</span><br><span class="line">        if (dir &#x3D;&#x3D; DIR_LEFT_TO_RIGHT) &#123;</span><br><span class="line">            indentWidth &#x3D; -getIndentAdjust(lineNum, Alignment.ALIGN_RIGHT);</span><br><span class="line">            x &#x3D; right - max - indentWidth;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            indentWidth &#x3D; getIndentAdjust(lineNum, Alignment.ALIGN_LEFT);</span><br><span class="line">            x &#x3D; left - max + indentWidth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123; &#x2F;&#x2F; Alignment.ALIGN_CENTER</span><br><span class="line">        indentWidth &#x3D; getIndentAdjust(lineNum, Alignment.ALIGN_CENTER);</span><br><span class="line">        max &#x3D; max &amp; ~1;</span><br><span class="line">        x &#x3D; ((right + left - max) &gt;&gt; 1) + indentWidth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Directions directions &#x3D; getLineDirections(lineNum);</span><br></pre></td></tr></table></figure>
<ul>
<li>第2部分，确定该行中是否有Tab，以及对其方式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (directions == DIRS_ALL_LEFT_TO_RIGHT &amp;&amp; !mSpannedText &amp;&amp; !hasTab &amp;&amp; !justify) &#123;</span><br><span class="line">     <span class="comment">// <span class="doctag">XXX:</span> assumes there&#x27;s nothing additional to be done</span></span><br><span class="line">     canvas.drawText(buf, start, end, x, lbaseline, paint);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     tl.set(paint, buf, start, end, dir, directions, hasTab, tabStops);</span><br><span class="line">     <span class="keyword">if</span> (justify) &#123;</span><br><span class="line">         tl.justify(right - left - indentWidth);</span><br><span class="line">     &#125;</span><br><span class="line">     tl.draw(canvas, x, ltop, lbaseline, lbottom);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第3部分，根据前面的信息，如果是布局从左到右并且是普通文本而且没有tab而且不需要对齐，则调用canvas.drawText来绘制，否则调用的是TextLine的draw()方法来进行绘制</li>
</ul>
]]></content>
      <tags>
        <tag>Android源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Android TextView源码浅析之顶层流程</title>
    <url>/2021/04/16/Android-TextView%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90%E4%B9%8B%E9%A1%B6%E5%B1%82%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="OverView"><a href="#OverView" class="headerlink" title="OverView"></a>OverView</h3><p>TextView应该是Android中最基础也是使用最广的控件，其能力简单来说就是将一段文本显示出来，但TextView可能也是最复杂的控件之一，涉及到的类众多，我们来采取自顶向下的方式来学习一下TextView的源码，这一篇先从最顶层开始，整体熟悉TextView的工作过程。</p>
<h3 id="继承层次"><a href="#继承层次" class="headerlink" title="继承层次"></a>继承层次</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextView</span> <span class="keyword">extends</span> <span class="title">View</span> <span class="keyword">implements</span> <span class="title">ViewTreeObserver</span>.<span class="title">OnPreDrawListener</span></span></span><br></pre></td></tr></table></figure>
<p>继承层次很简单，是View的直接子类，实现了ViewTreeObserver.OnPreDrawListener接口<br>而在官方的文档中，能看到其子类有：<br><img src="https://upload-images.jianshu.io/upload_images/5866715-b2cf6bc1d5ff0566.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>基础控件中常用的Button, EditText都是派生自TextView，这也说明了学习TextView的源码是大有裨益的。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TextView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TextView</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, attrs, com.android.internal.R.attr.textViewStyle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TextView</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, attrs, defStyleAttr, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TextView</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    // ^</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;  </span></span></span><br></pre></td></tr></table></figure>
<p>TextView的构造函数也是模板化的，有1~4个参数的构造函数，单参数的调用二参数然后以此类推，最终都会调用到4参数的构造函数<br>4参数的构造函数实现较长，分段来看下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">super</span>(context, attrs, defStyleAttr, defStyleRes);</span><br><span class="line"></span><br><span class="line"><span class="comment">// TextView is important by default, unless app developer overrode attribute.</span></span><br><span class="line"><span class="keyword">if</span> (getImportantForAutofill() == IMPORTANT_FOR_AUTOFILL_AUTO) &#123;</span><br><span class="line">    setImportantForAutofill(IMPORTANT_FOR_AUTOFILL_YES);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTextInternal(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Resources res = getResources();</span><br><span class="line"><span class="keyword">final</span> CompatibilityInfo compat = res.getCompatibilityInfo();</span><br><span class="line"></span><br><span class="line">mTextPaint = <span class="keyword">new</span> TextPaint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">mTextPaint.density = res.getDisplayMetrics().density;</span><br><span class="line">mTextPaint.setCompatibilityScaling(compat.applicationScale);</span><br><span class="line"></span><br><span class="line">mHighlightPaint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">mHighlightPaint.setCompatibilityScaling(compat.applicationScale);</span><br><span class="line"></span><br><span class="line">mMovement = getDefaultMovementMethod();</span><br><span class="line"></span><br><span class="line">mTransformation = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> TextAppearanceAttributes attributes = <span class="keyword">new</span> TextAppearanceAttributes();</span><br><span class="line">attributes.mTextColor = ColorStateList.valueOf(<span class="number">0xFF000000</span>);</span><br><span class="line">attributes.mTextSize = <span class="number">15</span>;</span><br><span class="line">mBreakStrategy = Layout.BREAK_STRATEGY_SIMPLE;</span><br><span class="line">mHyphenationFrequency = Layout.HYPHENATION_FREQUENCY_NONE;</span><br><span class="line">mJustificationMode = Layout.JUSTIFICATION_MODE_NONE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Resources.Theme theme = context.getTheme();</span><br></pre></td></tr></table></figure>
<ul>
<li>第1部分主要是相关类和变量的初始化<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TypedArray a = theme.obtainStyledAttributes(attrs,</span><br><span class="line">        com.android.internal.R.styleable.TextViewAppearance, defStyleAttr, defStyleRes);</span><br><span class="line">TypedArray appearance = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> ap = a.getResourceId(</span><br><span class="line">        com.android.internal.R.styleable.TextViewAppearance_textAppearance, -<span class="number">1</span>);</span><br><span class="line">a.recycle();</span><br><span class="line"><span class="keyword">if</span> (ap != -<span class="number">1</span>) &#123;</span><br><span class="line">    appearance = theme.obtainStyledAttributes(</span><br><span class="line">            ap, com.android.internal.R.styleable.TextAppearance);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (appearance != <span class="keyword">null</span>) &#123;</span><br><span class="line">    readTextAppearance(context, appearance, attributes, <span class="keyword">false</span> <span class="comment">/* styleArray */</span>);</span><br><span class="line">    attributes.mFontFamilyExplicit = <span class="keyword">false</span>;</span><br><span class="line">    appearance.recycle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> editable = getDefaultEditable();</span><br><span class="line">CharSequence inputMethod = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> numeric = <span class="number">0</span>;</span><br><span class="line">CharSequence digits = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> phone = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span> autotext = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> autocap = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> buffertype = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span> selectallonfocus = <span class="keyword">false</span>;</span><br><span class="line">Drawable drawableLeft = <span class="keyword">null</span>, drawableTop = <span class="keyword">null</span>, drawableRight = <span class="keyword">null</span>,</span><br><span class="line">        drawableBottom = <span class="keyword">null</span>, drawableStart = <span class="keyword">null</span>, drawableEnd = <span class="keyword">null</span>;</span><br><span class="line">ColorStateList drawableTint = <span class="keyword">null</span>;</span><br><span class="line">PorterDuff.Mode drawableTintMode = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> drawablePadding = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ellipsize = ELLIPSIZE_NOT_SET;</span><br><span class="line"><span class="keyword">boolean</span> singleLine = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> maxlength = -<span class="number">1</span>;</span><br><span class="line">CharSequence text = <span class="string">&quot;&quot;</span>;</span><br><span class="line">CharSequence hint = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> password = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">float</span> autoSizeMinTextSizeInPx = UNSET_AUTO_SIZE_UNIFORM_CONFIGURATION_VALUE;</span><br><span class="line"><span class="keyword">float</span> autoSizeMaxTextSizeInPx = UNSET_AUTO_SIZE_UNIFORM_CONFIGURATION_VALUE;</span><br><span class="line"><span class="keyword">float</span> autoSizeStepGranularityInPx = UNSET_AUTO_SIZE_UNIFORM_CONFIGURATION_VALUE;</span><br><span class="line"><span class="keyword">int</span> inputType = EditorInfo.TYPE_NULL;</span><br><span class="line">a = theme.obtainStyledAttributes(</span><br><span class="line">            attrs, com.android.internal.R.styleable.TextView, defStyleAttr, defStyleRes);</span><br><span class="line"><span class="keyword">int</span> firstBaselineToTopHeight = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> lastBaselineToBottomHeight = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> lineHeight = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">readTextAppearance(context, a, attributes, <span class="keyword">true</span> <span class="comment">/* styleArray */</span>);</span><br></pre></td></tr></table></figure></li>
<li>第2部分主要是获取应用的theme等全局属性，来初始化TextView的一些样式相关的变量<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = a.getIndexCount();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Must set id in a temporary variable because it will be reset by setText()</span></span><br><span class="line"><span class="keyword">boolean</span> textIsSetFromXml = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> attr = a.getIndex(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (attr) &#123;</span><br><span class="line">        <span class="keyword">case</span> com.android.internal.R.styleable.TextView_editable:</span><br><span class="line">            editable = a.getBoolean(attr, editable);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> com.android.internal.R.styleable.TextView_inputMethod:</span><br><span class="line">            inputMethod = a.getText(attr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> com.android.internal.R.styleable.TextView_numeric:</span><br><span class="line">            numeric = a.getInt(attr, numeric);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">        <span class="keyword">case</span> com.android.internal.R.styleable.TextView_lineHeight:</span><br><span class="line">            lineHeight = a.getDimensionPixelSize(attr, -<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.recycle();</span><br></pre></td></tr></table></figure></li>
<li>第3部分就是在XML中解析出对应的属性然后赋值到相关变量上<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> variation =</span><br><span class="line">        inputType &amp; (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_MASK_VARIATION);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> passwordInputType = variation</span><br><span class="line">        == (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> webPasswordInputType = variation</span><br><span class="line">        == (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_WEB_PASSWORD);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> numberPasswordInputType = variation</span><br><span class="line">        == (EditorInfo.TYPE_CLASS_NUMBER | EditorInfo.TYPE_NUMBER_VARIATION_PASSWORD);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> targetSdkVersion = context.getApplicationInfo().targetSdkVersion;</span><br><span class="line">mUseInternationalizedInput = targetSdkVersion &gt;= VERSION_CODES.O;</span><br><span class="line">mUseFallbackLineSpacing = targetSdkVersion &gt;= VERSION_CODES.P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (inputMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Class&lt;?&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        c = Class.forName(inputMethod.toString());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        createEditorIfNeeded();</span><br><span class="line">        mEditor.mKeyListener = (KeyListener) c.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mEditor.mInputType = inputType != EditorInfo.TYPE_NULL</span><br><span class="line">                ? inputType</span><br><span class="line">                : mEditor.mKeyListener.getInputType();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IncompatibleClassChangeError e) &#123;</span><br><span class="line">        mEditor.mInputType = EditorInfo.TYPE_CLASS_TEXT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (digits != <span class="keyword">null</span>) &#123;</span><br><span class="line">    createEditorIfNeeded();</span><br><span class="line">    mEditor.mKeyListener = DigitsKeyListener.getInstance(digits.toString());</span><br><span class="line">    <span class="comment">// If no input type was specified, we will default to generic</span></span><br><span class="line">    <span class="comment">// text, since we can&#x27;t tell the IME about the set of digits</span></span><br><span class="line">    <span class="comment">// that was selected.</span></span><br><span class="line">    mEditor.mInputType = inputType != EditorInfo.TYPE_NULL</span><br><span class="line">            ? inputType : EditorInfo.TYPE_CLASS_TEXT;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (inputType != EditorInfo.TYPE_NULL) &#123;</span><br><span class="line">    setInputType(inputType, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// If set, the input type overrides what was set using the deprecated singleLine flag.</span></span><br><span class="line">    singleLine = !isMultilineInputType(inputType);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (phone) &#123;</span><br><span class="line">    createEditorIfNeeded();</span><br><span class="line">    mEditor.mKeyListener = DialerKeyListener.getInstance();</span><br><span class="line">    mEditor.mInputType = inputType = EditorInfo.TYPE_CLASS_PHONE;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (numeric != <span class="number">0</span>) &#123;</span><br><span class="line">    createEditorIfNeeded();</span><br><span class="line">    mEditor.mKeyListener = DigitsKeyListener.getInstance(</span><br><span class="line">            <span class="keyword">null</span>,  <span class="comment">// locale</span></span><br><span class="line">            (numeric &amp; SIGNED) != <span class="number">0</span>,</span><br><span class="line">            (numeric &amp; DECIMAL) != <span class="number">0</span>);</span><br><span class="line">    inputType = mEditor.mKeyListener.getInputType();</span><br><span class="line">    mEditor.mInputType = inputType;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (autotext || autocap != -<span class="number">1</span>) &#123;</span><br><span class="line">    TextKeyListener.Capitalize cap;</span><br><span class="line"></span><br><span class="line">    inputType = EditorInfo.TYPE_CLASS_TEXT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (autocap) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            cap = TextKeyListener.Capitalize.SENTENCES;</span><br><span class="line">            inputType |= EditorInfo.TYPE_TEXT_FLAG_CAP_SENTENCES;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            cap = TextKeyListener.Capitalize.WORDS;</span><br><span class="line">            inputType |= EditorInfo.TYPE_TEXT_FLAG_CAP_WORDS;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            cap = TextKeyListener.Capitalize.CHARACTERS;</span><br><span class="line">            inputType |= EditorInfo.TYPE_TEXT_FLAG_CAP_CHARACTERS;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            cap = TextKeyListener.Capitalize.NONE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEditorIfNeeded();</span><br><span class="line">    mEditor.mKeyListener = TextKeyListener.getInstance(autotext, cap);</span><br><span class="line">    mEditor.mInputType = inputType;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (editable) &#123;</span><br><span class="line">    createEditorIfNeeded();</span><br><span class="line">    mEditor.mKeyListener = TextKeyListener.getInstance();</span><br><span class="line">    mEditor.mInputType = EditorInfo.TYPE_CLASS_TEXT;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (isTextSelectable()) &#123;</span><br><span class="line">    <span class="comment">// Prevent text changes from keyboard.</span></span><br><span class="line">    <span class="keyword">if</span> (mEditor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mEditor.mKeyListener = <span class="keyword">null</span>;</span><br><span class="line">        mEditor.mInputType = EditorInfo.TYPE_NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    bufferType = BufferType.SPANNABLE;</span><br><span class="line">    <span class="comment">// So that selection can be changed using arrow keys and touch is handled.</span></span><br><span class="line">    setMovementMethod(ArrowKeyMovementMethod.getInstance());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mEditor != <span class="keyword">null</span>) mEditor.mKeyListener = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (buffertype) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            bufferType = BufferType.NORMAL;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            bufferType = BufferType.SPANNABLE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            bufferType = BufferType.EDITABLE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mEditor != <span class="keyword">null</span>) &#123;</span><br><span class="line">    mEditor.adjustInputType(password, passwordInputType, webPasswordInputType,</span><br><span class="line">            numberPasswordInputType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (selectallonfocus) &#123;</span><br><span class="line">    createEditorIfNeeded();</span><br><span class="line">    mEditor.mSelectAllOnFocus = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bufferType == BufferType.NORMAL) &#123;</span><br><span class="line">        bufferType = BufferType.SPANNABLE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第4部分是和输入编辑相关的初始化，涉及到的Editor类，负责的功能就是处理文本的区域选择处理和判断、拼写检查、弹出文本菜单等<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Set up the tint (if needed) before setting the drawables so that it</span></span><br><span class="line"><span class="comment">// gets applied correctly.</span></span><br><span class="line"><span class="keyword">if</span> (drawableTint != <span class="keyword">null</span> || drawableTintMode != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mDrawables == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mDrawables = <span class="keyword">new</span> Drawables(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (drawableTint != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mDrawables.mTintList = drawableTint;</span><br><span class="line">        mDrawables.mHasTint = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (drawableTintMode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mDrawables.mTintMode = drawableTintMode;</span><br><span class="line">        mDrawables.mHasTintMode = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This call will save the initial left/right drawables</span></span><br><span class="line">setCompoundDrawablesWithIntrinsicBounds(</span><br><span class="line">        drawableLeft, drawableTop, drawableRight, drawableBottom);</span><br><span class="line">setRelativeDrawablesIfNeeded(drawableStart, drawableEnd);</span><br><span class="line">setCompoundDrawablePadding(drawablePadding);</span><br></pre></td></tr></table></figure></li>
<li>第5部分的工作是，设置对应位置的Drawable<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Same as setSingleLine(), but make sure the transformation method and the maximum number</span></span><br><span class="line"> <span class="comment">// of lines of height are unchanged for multi-line TextViews.</span></span><br><span class="line"> setInputTypeSingleLine(singleLine);</span><br><span class="line"> applySingleLine(singleLine, singleLine, singleLine);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (singleLine &amp;&amp; getKeyListener() == <span class="keyword">null</span> &amp;&amp; ellipsize == ELLIPSIZE_NOT_SET) &#123;</span><br><span class="line">     ellipsize = ELLIPSIZE_END;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">switch</span> (ellipsize) &#123;</span><br><span class="line">     <span class="keyword">case</span> ELLIPSIZE_START:</span><br><span class="line">         setEllipsize(TextUtils.TruncateAt.START);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> ELLIPSIZE_MIDDLE:</span><br><span class="line">         setEllipsize(TextUtils.TruncateAt.MIDDLE);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> ELLIPSIZE_END:</span><br><span class="line">         setEllipsize(TextUtils.TruncateAt.END);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> ELLIPSIZE_MARQUEE:</span><br><span class="line">         <span class="keyword">if</span> (ViewConfiguration.get(context).isFadingMarqueeEnabled()) &#123;</span><br><span class="line">             setHorizontalFadingEdgeEnabled(<span class="keyword">true</span>);</span><br><span class="line">             mMarqueeFadeMode = MARQUEE_FADE_NORMAL;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             setHorizontalFadingEdgeEnabled(<span class="keyword">false</span>);</span><br><span class="line">             mMarqueeFadeMode = MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS;</span><br><span class="line">         &#125;</span><br><span class="line">         setEllipsize(TextUtils.TruncateAt.MARQUEE);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">boolean</span> isPassword = password || passwordInputType || webPasswordInputType</span><br><span class="line">         || numberPasswordInputType;</span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">boolean</span> isMonospaceEnforced = isPassword || (mEditor != <span class="keyword">null</span></span><br><span class="line">         &amp;&amp; (mEditor.mInputType</span><br><span class="line">         &amp; (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_MASK_VARIATION))</span><br><span class="line">         == (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD));</span><br><span class="line"> <span class="keyword">if</span> (isMonospaceEnforced) &#123;</span><br><span class="line">     attributes.mTypefaceIndex = MONOSPACE;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> applyTextAppearance(attributes);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (isPassword) &#123;</span><br><span class="line">     setTransformationMethod(PasswordTransformationMethod.getInstance());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (maxlength &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">     setFilters(<span class="keyword">new</span> InputFilter[] &#123; <span class="keyword">new</span> InputFilter.LengthFilter(maxlength) &#125;);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     setFilters(NO_FILTERS);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> setText(text, bufferType);</span><br><span class="line"> <span class="keyword">if</span> (textIsSetFromXml) &#123;</span><br><span class="line">     mTextSetFromXmlOrResourceId = <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (hint != <span class="keyword">null</span>) setHint(hint);</span><br></pre></td></tr></table></figure></li>
<li>第6部分，是比较关键的设置文字的部分，先是确定好是否单行，然后设置省略方式，最后调用setText()，如果有必要还会设置hint<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Views are not normally clickable unless specified to be.</span><br><span class="line"> * However, TextViews that have input or movement methods *are*</span><br><span class="line"> * clickable by default. By setting clickable here, we implicitly set focusable as well</span><br><span class="line"> * if not overridden by the developer.</span><br><span class="line"> *&#x2F;</span><br><span class="line">a &#x3D; context.obtainStyledAttributes(</span><br><span class="line">        attrs, com.android.internal.R.styleable.View, defStyleAttr, defStyleRes);</span><br><span class="line">boolean canInputOrMove &#x3D; (mMovement !&#x3D; null || getKeyListener() !&#x3D; null);</span><br><span class="line">boolean clickable &#x3D; canInputOrMove || isClickable();</span><br><span class="line">boolean longClickable &#x3D; canInputOrMove || isLongClickable();</span><br><span class="line">int focusable &#x3D; getFocusable();</span><br><span class="line"></span><br><span class="line">n &#x3D; a.getIndexCount();</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">    int attr &#x3D; a.getIndex(i);</span><br><span class="line"></span><br><span class="line">    switch (attr) &#123;</span><br><span class="line">        case com.android.internal.R.styleable.View_focusable:</span><br><span class="line">            TypedValue val &#x3D; new TypedValue();</span><br><span class="line">            if (a.getValue(attr, val)) &#123;</span><br><span class="line">                focusable &#x3D; (val.type &#x3D;&#x3D; TypedValue.TYPE_INT_BOOLEAN)</span><br><span class="line">                        ? (val.data &#x3D;&#x3D; 0 ? NOT_FOCUSABLE : FOCUSABLE)</span><br><span class="line">                        : val.data;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case com.android.internal.R.styleable.View_clickable:</span><br><span class="line">            clickable &#x3D; a.getBoolean(attr, clickable);</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case com.android.internal.R.styleable.View_longClickable:</span><br><span class="line">            longClickable &#x3D; a.getBoolean(attr, longClickable);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">a.recycle();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Some apps were relying on the undefined behavior of focusable winning over</span><br><span class="line">&#x2F;&#x2F; focusableInTouchMode !&#x3D; focusable in TextViews if both were specified in XML (usually</span><br><span class="line">&#x2F;&#x2F; when starting with EditText and setting only focusable&#x3D;false). To keep those apps from</span><br><span class="line">&#x2F;&#x2F; breaking, re-apply the focusable attribute here.</span><br><span class="line">if (focusable !&#x3D; getFocusable()) &#123;</span><br><span class="line">    setFocusable(focusable);</span><br><span class="line">&#125;</span><br><span class="line">setClickable(clickable);</span><br><span class="line">setLongClickable(longClickable);</span><br></pre></td></tr></table></figure></li>
<li>第7部分是设置能否点击的相关属性<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mEditor != <span class="keyword">null</span>) mEditor.prepareCursorControllers();</span><br><span class="line"></span><br><span class="line"><span class="comment">// If not explicitly specified this view is important for accessibility.</span></span><br><span class="line"><span class="keyword">if</span> (getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) &#123;</span><br><span class="line">    setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (supportsAutoSizeText()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mAutoSizeTextType == AUTO_SIZE_TEXT_TYPE_UNIFORM) &#123;</span><br><span class="line">        <span class="comment">// If uniform auto-size has been specified but preset values have not been set then</span></span><br><span class="line">        <span class="comment">// replace the auto-size configuration values that have not been specified with the</span></span><br><span class="line">        <span class="comment">// defaults.</span></span><br><span class="line">        <span class="keyword">if</span> (!mHasPresetAutoSizeValues) &#123;</span><br><span class="line">            <span class="keyword">final</span> DisplayMetrics displayMetrics = getResources().getDisplayMetrics();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (autoSizeMinTextSizeInPx == UNSET_AUTO_SIZE_UNIFORM_CONFIGURATION_VALUE) &#123;</span><br><span class="line">                autoSizeMinTextSizeInPx = TypedValue.applyDimension(</span><br><span class="line">                        TypedValue.COMPLEX_UNIT_SP,</span><br><span class="line">                        DEFAULT_AUTO_SIZE_MIN_TEXT_SIZE_IN_SP,</span><br><span class="line">                        displayMetrics);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (autoSizeMaxTextSizeInPx == UNSET_AUTO_SIZE_UNIFORM_CONFIGURATION_VALUE) &#123;</span><br><span class="line">                autoSizeMaxTextSizeInPx = TypedValue.applyDimension(</span><br><span class="line">                        TypedValue.COMPLEX_UNIT_SP,</span><br><span class="line">                        DEFAULT_AUTO_SIZE_MAX_TEXT_SIZE_IN_SP,</span><br><span class="line">                        displayMetrics);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (autoSizeStepGranularityInPx</span><br><span class="line">                    == UNSET_AUTO_SIZE_UNIFORM_CONFIGURATION_VALUE) &#123;</span><br><span class="line">                autoSizeStepGranularityInPx = DEFAULT_AUTO_SIZE_GRANULARITY_IN_PX;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            validateAndSetAutoSizeTextTypeUniformConfiguration(autoSizeMinTextSizeInPx,</span><br><span class="line">                    autoSizeMaxTextSizeInPx,</span><br><span class="line">                    autoSizeStepGranularityInPx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setupAutoSizeText();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mAutoSizeTextType = AUTO_SIZE_TEXT_TYPE_NONE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (firstBaselineToTopHeight &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    setFirstBaselineToTopHeight(firstBaselineToTopHeight);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (lastBaselineToBottomHeight &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    setLastBaselineToBottomHeight(lastBaselineToBottomHeight);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (lineHeight &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    setLineHeight(lineHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>最后第8部分是设置AutoSize/BaseLine/LineHeight等外观相关的属性</li>
</ul>
<h3 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure()"></a>onMeasure()</h3><p>对于onMeasure()源码的解析，同样还是分段来看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line"><span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line"><span class="keyword">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line"><span class="keyword">int</span> heightSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> width;</span><br><span class="line"><span class="keyword">int</span> height;</span><br><span class="line"></span><br><span class="line">BoringLayout.Metrics boring = UNKNOWN_BORING;</span><br><span class="line">BoringLayout.Metrics hintBoring = UNKNOWN_BORING;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mTextDir == <span class="keyword">null</span>) &#123;</span><br><span class="line">    mTextDir = getTextDirectionHeuristic();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第1部分是相关变量的初始化，这里涉及到一个BoringLayout的概念，在这一层先不去管其实现，知道它的作用是对最简单的文本进行排版<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> des = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">boolean</span> fromexisting = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> widthLimit = (widthMode == MeasureSpec.AT_MOST)</span><br><span class="line">        ?  (<span class="keyword">float</span>) widthSize : Float.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (widthMode == MeasureSpec.EXACTLY) &#123;</span><br><span class="line">    <span class="comment">// Parent has told us how big to be. So be it.</span></span><br><span class="line">    width = widthSize;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mLayout != <span class="keyword">null</span> &amp;&amp; mEllipsize == <span class="keyword">null</span>) &#123;</span><br><span class="line">        des = desired(mLayout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (des &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        boring = BoringLayout.isBoring(mTransformed, mTextPaint, mTextDir, mBoring);</span><br><span class="line">        <span class="keyword">if</span> (boring != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mBoring = boring;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fromexisting = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (boring == <span class="keyword">null</span> || boring == UNKNOWN_BORING) &#123;</span><br><span class="line">        <span class="keyword">if</span> (des &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            des = (<span class="keyword">int</span>) Math.ceil(Layout.getDesiredWidthWithLimit(mTransformed, <span class="number">0</span>,</span><br><span class="line">                    mTransformed.length(), mTextPaint, mTextDir, widthLimit));</span><br><span class="line">        &#125;</span><br><span class="line">        width = des;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        width = boring.width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Drawables dr = mDrawables;</span><br><span class="line">    <span class="keyword">if</span> (dr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        width = Math.max(width, dr.mDrawableWidthTop);</span><br><span class="line">        width = Math.max(width, dr.mDrawableWidthBottom);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mHint != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> hintDes = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> hintWidth;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mHintLayout != <span class="keyword">null</span> &amp;&amp; mEllipsize == <span class="keyword">null</span>) &#123;</span><br><span class="line">            hintDes = desired(mHintLayout);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hintDes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            hintBoring = BoringLayout.isBoring(mHint, mTextPaint, mTextDir, mHintBoring);</span><br><span class="line">            <span class="keyword">if</span> (hintBoring != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mHintBoring = hintBoring;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hintBoring == <span class="keyword">null</span> || hintBoring == UNKNOWN_BORING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hintDes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                hintDes = (<span class="keyword">int</span>) Math.ceil(Layout.getDesiredWidthWithLimit(mHint, <span class="number">0</span>,</span><br><span class="line">                        mHint.length(), mTextPaint, mTextDir, widthLimit));</span><br><span class="line">            &#125;</span><br><span class="line">            hintWidth = hintDes;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hintWidth = hintBoring.width;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hintWidth &gt; width) &#123;</span><br><span class="line">            width = hintWidth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    width += getCompoundPaddingLeft() + getCompoundPaddingRight();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mMaxWidthMode == EMS) &#123;</span><br><span class="line">        width = Math.min(width, mMaxWidth * getLineHeight());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        width = Math.min(width, mMaxWidth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mMinWidthMode == EMS) &#123;</span><br><span class="line">        width = Math.max(width, mMinWidth * getLineHeight());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        width = Math.max(width, mMinWidth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check against our minimum width</span></span><br><span class="line">    width = Math.max(width, getSuggestedMinimumWidth());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (widthMode == MeasureSpec.AT_MOST) &#123;</span><br><span class="line">        width = Math.min(widthSize, width);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> want = width - getCompoundPaddingLeft() - getCompoundPaddingRight();</span><br><span class="line"><span class="keyword">int</span> unpaddedWidth = want;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mHorizontallyScrolling) want = VERY_WIDE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> hintWant = want;</span><br><span class="line"><span class="keyword">int</span> hintWidth = (mHintLayout == <span class="keyword">null</span>) ? hintWant : mHintLayout.getWidth();</span><br></pre></td></tr></table></figure>
第2部分是对宽度的计算，如果MeasureMode是EXCACTLY，那直接用父View指定的宽度，否则需要通过Layout来计算，这里再重复一次Layout的概念——Layout负责TextView的排版，包括折行省略等；在计算宽度时，会在正文和hint都会产生一个对应的宽度，取两者最大值作为TextView的宽度<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mLayout == <span class="keyword">null</span>) &#123;</span><br><span class="line">     makeNewLayout(want, hintWant, boring, hintBoring,</span><br><span class="line">                   width - getCompoundPaddingLeft() - getCompoundPaddingRight(), <span class="keyword">false</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">boolean</span> layoutChanged = (mLayout.getWidth() != want) || (hintWidth != hintWant)</span><br><span class="line">             || (mLayout.getEllipsizedWidth()</span><br><span class="line">                     != width - getCompoundPaddingLeft() - getCompoundPaddingRight());</span><br><span class="line"></span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">boolean</span> widthChanged = (mHint == <span class="keyword">null</span>) &amp;&amp; (mEllipsize == <span class="keyword">null</span>)</span><br><span class="line">             &amp;&amp; (want &gt; mLayout.getWidth())</span><br><span class="line">             &amp;&amp; (mLayout <span class="keyword">instanceof</span> BoringLayout</span><br><span class="line">                     || (fromexisting &amp;&amp; des &gt;= <span class="number">0</span> &amp;&amp; des &lt;= want));</span><br><span class="line"></span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">boolean</span> maximumChanged = (mMaxMode != mOldMaxMode) || (mMaximum != mOldMaximum);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (layoutChanged || maximumChanged) &#123;</span><br><span class="line">         <span class="keyword">if</span> (!maximumChanged &amp;&amp; widthChanged) &#123;</span><br><span class="line">             mLayout.increaseWidthTo(want);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             makeNewLayout(want, hintWant, boring, hintBoring,</span><br><span class="line">                     width - getCompoundPaddingLeft() - getCompoundPaddingRight(), <span class="keyword">false</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// Nothing has changed</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li>第3部分也仍然是宽度的相关计算，根据Layout的内容对宽度进行调整，这里涉及到比较关键的方法是makeNewLayout()，关于这个方法，在下一层讲Layout时再展开说。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (heightMode == MeasureSpec.EXACTLY) &#123;</span><br><span class="line">    <span class="comment">// Parent has told us how big to be. So be it.</span></span><br><span class="line">    height = heightSize;</span><br><span class="line">    mDesiredHeightAtMeasure = -<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> desired = getDesiredHeight();</span><br><span class="line"></span><br><span class="line">    height = desired;</span><br><span class="line">    mDesiredHeightAtMeasure = desired;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (heightMode == MeasureSpec.AT_MOST) &#123;</span><br><span class="line">        height = Math.min(desired, heightSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> unpaddedHeight = height - getCompoundPaddingTop() - getCompoundPaddingBottom();</span><br><span class="line"><span class="keyword">if</span> (mMaxMode == LINES &amp;&amp; mLayout.getLineCount() &gt; mMaximum) &#123;</span><br><span class="line">    unpaddedHeight = Math.min(unpaddedHeight, mLayout.getLineTop(mMaximum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第4部分是对高度的计算，内容比宽度的处理少很多，主要通过getDesiredHeight()获得高度；篇幅比width少的原因在于，在计算width的时候，实际上已经通过Layout处理完了排版，完成了height所需的部分工作，getDesiredHeight()的内部实现实际上也是通过mLayout来获得高度的<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We didn&#x27;t let makeNewLayout() register to bring the cursor into view,</span></span><br><span class="line"><span class="comment"> * so do it here if there is any possibility that it is needed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (mMovement != <span class="keyword">null</span></span><br><span class="line">        || mLayout.getWidth() &gt; unpaddedWidth</span><br><span class="line">        || mLayout.getHeight() &gt; unpaddedHeight) &#123;</span><br><span class="line">    registerForPreDraw();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    scrollTo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setMeasuredDimension(width, height);</span><br></pre></td></tr></table></figure></li>
<li>第5部分是最终width和height的结果处理</li>
</ul>
<h3 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout()"></a>onLayout()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onLayout(changed, left, top, right, bottom);</span><br><span class="line">    <span class="keyword">if</span> (mDeferScroll &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> curs = mDeferScroll;</span><br><span class="line">        mDeferScroll = -<span class="number">1</span>;</span><br><span class="line">        bringPointIntoView(Math.min(curs, mText.length()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Call auto-size after the width and height have been calculated.</span></span><br><span class="line">    autoSizeText();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常View的直接子类很少重写onLayout()函数，但TextView就重写了，主要工作就是在onLayout()中调用autoSizeText()</p>
<h3 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw()"></a>onDraw()</h3><p>onDraw()函数同样也分段来看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">restartMarqueeIfNeeded();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Draw the background for this view</span></span><br><span class="line"><span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> compoundPaddingLeft = getCompoundPaddingLeft();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> compoundPaddingTop = getCompoundPaddingTop();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> compoundPaddingRight = getCompoundPaddingRight();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> compoundPaddingBottom = getCompoundPaddingBottom();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> scrollX = mScrollX;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> scrollY = mScrollY;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> right = mRight;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> left = mLeft;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> bottom = mBottom;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> top = mTop;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> isLayoutRtl = isLayoutRtl();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> offset = getHorizontalOffsetForDrawables();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> leftOffset = isLayoutRtl ? <span class="number">0</span> : offset;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> rightOffset = isLayoutRtl ? offset : <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>第1部分，是相关变量的初始化<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Drawables dr = mDrawables;</span><br><span class="line"><span class="keyword">if</span> (dr != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Compound, not extended, because the icon is not clipped</span></span><br><span class="line"><span class="comment">     * if the text height is smaller.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> vspace = bottom - top - compoundPaddingBottom - compoundPaddingTop;</span><br><span class="line">    <span class="keyword">int</span> hspace = right - left - compoundPaddingRight - compoundPaddingLeft;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IMPORTANT: The coordinates computed are also used in invalidateDrawable()</span></span><br><span class="line">    <span class="comment">// Make sure to update invalidateDrawable() when changing this code.</span></span><br><span class="line">    <span class="keyword">if</span> (dr.mShowing[Drawables.LEFT] != <span class="keyword">null</span>) &#123;</span><br><span class="line">        canvas.save();</span><br><span class="line">        canvas.translate(scrollX + mPaddingLeft + leftOffset,</span><br><span class="line">                scrollY + compoundPaddingTop + (vspace - dr.mDrawableHeightLeft) / <span class="number">2</span>);</span><br><span class="line">        dr.mShowing[Drawables.LEFT].draw(canvas);</span><br><span class="line">        canvas.restore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IMPORTANT: The coordinates computed are also used in invalidateDrawable()</span></span><br><span class="line">    <span class="comment">// Make sure to update invalidateDrawable() when changing this code.</span></span><br><span class="line">    <span class="keyword">if</span> (dr.mShowing[Drawables.RIGHT] != <span class="keyword">null</span>) &#123;</span><br><span class="line">        canvas.save();</span><br><span class="line">        canvas.translate(scrollX + right - left - mPaddingRight</span><br><span class="line">                - dr.mDrawableSizeRight - rightOffset,</span><br><span class="line">                 scrollY + compoundPaddingTop + (vspace - dr.mDrawableHeightRight) / <span class="number">2</span>);</span><br><span class="line">        dr.mShowing[Drawables.RIGHT].draw(canvas);</span><br><span class="line">        canvas.restore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IMPORTANT: The coordinates computed are also used in invalidateDrawable()</span></span><br><span class="line">    <span class="comment">// Make sure to update invalidateDrawable() when changing this code.</span></span><br><span class="line">    <span class="keyword">if</span> (dr.mShowing[Drawables.TOP] != <span class="keyword">null</span>) &#123;</span><br><span class="line">        canvas.save();</span><br><span class="line">        canvas.translate(scrollX + compoundPaddingLeft</span><br><span class="line">                + (hspace - dr.mDrawableWidthTop) / <span class="number">2</span>, scrollY + mPaddingTop);</span><br><span class="line">        dr.mShowing[Drawables.TOP].draw(canvas);</span><br><span class="line">        canvas.restore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IMPORTANT: The coordinates computed are also used in invalidateDrawable()</span></span><br><span class="line">    <span class="comment">// Make sure to update invalidateDrawable() when changing this code.</span></span><br><span class="line">    <span class="keyword">if</span> (dr.mShowing[Drawables.BOTTOM] != <span class="keyword">null</span>) &#123;</span><br><span class="line">        canvas.save();</span><br><span class="line">        canvas.translate(scrollX + compoundPaddingLeft</span><br><span class="line">                + (hspace - dr.mDrawableWidthBottom) / <span class="number">2</span>,</span><br><span class="line">                 scrollY + bottom - top - mPaddingBottom - dr.mDrawableSizeBottom);</span><br><span class="line">        dr.mShowing[Drawables.BOTTOM].draw(canvas);</span><br><span class="line">        canvas.restore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第2部分，对上下左右的Drawable进行绘制<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> color = mCurTextColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mLayout == <span class="keyword">null</span>) &#123;</span><br><span class="line">    assumeLayout();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Layout layout = mLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mHint != <span class="keyword">null</span> &amp;&amp; mText.length() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mHintTextColor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        color = mCurHintTextColor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    layout = mHintLayout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mTextPaint.setColor(color);</span><br><span class="line">mTextPaint.drawableState = getDrawableState();</span><br><span class="line"></span><br><span class="line">canvas.save();</span><br></pre></td></tr></table></figure></li>
<li>第3部分，确定此时绘制的是hint还是正文，设置对应的颜色和Layout<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> extendedPaddingTop = getExtendedPaddingTop();</span><br><span class="line"><span class="keyword">int</span> extendedPaddingBottom = getExtendedPaddingBottom();</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> vspace = mBottom - mTop - compoundPaddingBottom - compoundPaddingTop;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> maxScrollY = mLayout.getHeight() - vspace;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> clipLeft = compoundPaddingLeft + scrollX;</span><br><span class="line"><span class="keyword">float</span> clipTop = (scrollY == <span class="number">0</span>) ? <span class="number">0</span> : extendedPaddingTop + scrollY;</span><br><span class="line"><span class="keyword">float</span> clipRight = right - left - getCompoundPaddingRight() + scrollX;</span><br><span class="line"><span class="keyword">float</span> clipBottom = bottom - top + scrollY</span><br><span class="line">        - ((scrollY == maxScrollY) ? <span class="number">0</span> : extendedPaddingBottom);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mShadowRadius != <span class="number">0</span>) &#123;</span><br><span class="line">    clipLeft += Math.min(<span class="number">0</span>, mShadowDx - mShadowRadius);</span><br><span class="line">    clipRight += Math.max(<span class="number">0</span>, mShadowDx + mShadowRadius);</span><br><span class="line"></span><br><span class="line">    clipTop += Math.min(<span class="number">0</span>, mShadowDy - mShadowRadius);</span><br><span class="line">    clipBottom += Math.max(<span class="number">0</span>, mShadowDy + mShadowRadius);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">canvas.clipRect(clipLeft, clipTop, clipRight, clipBottom);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> voffsetText = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> voffsetCursor = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// translate in by our padding</span></span><br><span class="line"><span class="comment">/* shortcircuit calling getVerticaOffset() */</span></span><br><span class="line"><span class="keyword">if</span> ((mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK) != Gravity.TOP) &#123;</span><br><span class="line">    voffsetText = getVerticalOffset(<span class="keyword">false</span>);</span><br><span class="line">    voffsetCursor = getVerticalOffset(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">canvas.translate(compoundPaddingLeft, extendedPaddingTop + voffsetText);</span><br></pre></td></tr></table></figure></li>
<li>第4部分，是对padding的相关处理，主要是和阴影效果相关<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = getLayoutDirection();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> absoluteGravity = Gravity.getAbsoluteGravity(mGravity, layoutDirection);</span><br><span class="line"><span class="keyword">if</span> (isMarqueeFadeEnabled()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mSingleLine &amp;&amp; getLineCount() == <span class="number">1</span> &amp;&amp; canMarquee()</span><br><span class="line">            &amp;&amp; (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) != Gravity.LEFT) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> width = mRight - mLeft;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> padding = getCompoundPaddingLeft() + getCompoundPaddingRight();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> dx = mLayout.getLineRight(<span class="number">0</span>) - (width - padding);</span><br><span class="line">        canvas.translate(layout.getParagraphDirection(<span class="number">0</span>) * dx, <span class="number">0.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mMarquee != <span class="keyword">null</span> &amp;&amp; mMarquee.isRunning()) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> dx = -mMarquee.getScroll();</span><br><span class="line">        canvas.translate(layout.getParagraphDirection(<span class="number">0</span>) * dx, <span class="number">0.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第5部分，主要是走马灯效果的相关处理<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> cursorOffsetVertical = voffsetCursor - voffsetText;</span><br><span class="line"></span><br><span class="line">  Path highlight = getUpdatedHighlightPath();</span><br><span class="line">  <span class="keyword">if</span> (mEditor != <span class="keyword">null</span>) &#123;</span><br><span class="line">      mEditor.onDraw(canvas, layout, highlight, mHighlightPaint, cursorOffsetVertical);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      layout.draw(canvas, highlight, mHighlightPaint, cursorOffsetVertical);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mMarquee != <span class="keyword">null</span> &amp;&amp; mMarquee.shouldDrawGhost()) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">float</span> dx = mMarquee.getGhostOffset();</span><br><span class="line">      canvas.translate(layout.getParagraphDirection(<span class="number">0</span>) * dx, <span class="number">0.0f</span>);</span><br><span class="line">      layout.draw(canvas, highlight, mHighlightPaint, cursorOffsetVertical);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  canvas.restore();</span><br></pre></td></tr></table></figure></li>
<li>第6部分，真正绘制文字的地方，实际上是通过mEditor.draw()或者layout.draw()来进行绘制</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在TextView这一层，整体流程如上文所示，从源码学习的过程中能看到，实际上测量和绘制的逻辑都在Layout/Editor这些类里面，在下一篇我们具体看下它们的实现。</p>
]]></content>
      <tags>
        <tag>Android源码</tag>
      </tags>
  </entry>
</search>
