<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android FrameLayout源码学习</title>
    <url>/2021/04/16/Android-FrameLayout%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="OverView"><a href="#OverView" class="headerlink" title="OverView"></a>OverView</h3><p>FrameLayout也是Android开发中常用的布局之一，其特征是子View层层相叠，通过源码来了解其工作原理。</p>
<h3 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h3><p>一个布局容器的工作原理无非就是onMeasure()/onLayout()/onDraw()3个阶段的处理，先来直接看下onMeasure()的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = getChildCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> measureMatchParentChildren =</span><br><span class="line">            MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY ||</span><br><span class="line">            MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY;</span><br><span class="line">    mMatchParentChildren.clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxHeight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxWidth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> childState = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = getChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (mMeasureAllChildren || child.getVisibility() != GONE) &#123;</span><br><span class="line">            measureChildWithMargins(child, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">            maxWidth = Math.max(maxWidth,</span><br><span class="line">                    child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);</span><br><span class="line">            maxHeight = Math.max(maxHeight,</span><br><span class="line">                    child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);</span><br><span class="line">            childState = combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line">            <span class="keyword">if</span> (measureMatchParentChildren) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT ||</span><br><span class="line">                        lp.height == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                    mMatchParentChildren.add(child);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FrameLayout的onMeasure()过程比LinearLayout/RelativeLayout都要简洁，分成两部分，上面是第一部分的源码，其处理过程很简单：</p>
<ul>
<li>遍历一次子View，通过调用measureChildWithMargins()方法，完成了对子View的一次测量</li>
<li>随后会判断子View是否需要match_parent，如需要将加入到mMatchParentChildren集合中，待下一阶段处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">    count = mMatchParentChildren.size();</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = mMatchParentChildren.get(i);</span><br><span class="line">            <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec;</span><br><span class="line">            <span class="keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> width = Math.max(<span class="number">0</span>, getMeasuredWidth()</span><br><span class="line">                        - getPaddingLeftWithForeground() - getPaddingRightWithForeground()</span><br><span class="line">                        - lp.leftMargin - lp.rightMargin);</span><br><span class="line">                childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                        width, MeasureSpec.EXACTLY);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,</span><br><span class="line">                        getPaddingLeftWithForeground() + getPaddingRightWithForeground() +</span><br><span class="line">                        lp.leftMargin + lp.rightMargin,</span><br><span class="line">                        lp.width);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec;</span><br><span class="line">            <span class="keyword">if</span> (lp.height == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> height = Math.max(<span class="number">0</span>, getMeasuredHeight()</span><br><span class="line">                        - getPaddingTopWithForeground() - getPaddingBottomWithForeground()</span><br><span class="line">                        - lp.topMargin - lp.bottomMargin);</span><br><span class="line">                childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                        height, MeasureSpec.EXACTLY);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec,</span><br><span class="line">                        getPaddingTopWithForeground() + getPaddingBottomWithForeground() +</span><br><span class="line">                        lp.topMargin + lp.bottomMargin,</span><br><span class="line">                        lp.height);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在onMeasure()的第二部分，会将之前一次遍历中发现的需要将width或者height设置成match_parent的子View再进行一次处理，对其再进行一次正确宽高值的measure调用。</p>
<h3 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    layoutChildren(left, top, right, bottom, <span class="keyword">false</span> <span class="comment">/* no force left gravity */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void layoutChildren(int left, int top, int right, int bottom, boolean forceLeftGravity) &#123;</span><br><span class="line">    final int count &#x3D; getChildCount();</span><br><span class="line"></span><br><span class="line">    final int parentLeft &#x3D; getPaddingLeftWithForeground();</span><br><span class="line">    final int parentRight &#x3D; right - left - getPaddingRightWithForeground();</span><br><span class="line"></span><br><span class="line">    final int parentTop &#x3D; getPaddingTopWithForeground();</span><br><span class="line">    final int parentBottom &#x3D; bottom - top - getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">        final View child &#x3D; getChildAt(i);</span><br><span class="line">        if (child.getVisibility() !&#x3D; GONE) &#123;</span><br><span class="line">            final LayoutParams lp &#x3D; (LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">            final int width &#x3D; child.getMeasuredWidth();</span><br><span class="line">            final int height &#x3D; child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">            int childLeft;</span><br><span class="line">            int childTop;</span><br><span class="line"></span><br><span class="line">            int gravity &#x3D; lp.gravity;</span><br><span class="line">            if (gravity &#x3D;&#x3D; -1) &#123;</span><br><span class="line">                gravity &#x3D; DEFAULT_CHILD_GRAVITY;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final int layoutDirection &#x3D; getLayoutDirection();</span><br><span class="line">            final int absoluteGravity &#x3D; Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line">            final int verticalGravity &#x3D; gravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line"></span><br><span class="line">            switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">                case Gravity.CENTER_HORIZONTAL:</span><br><span class="line">                    childLeft &#x3D; parentLeft + (parentRight - parentLeft - width) &#x2F; 2 +</span><br><span class="line">                    lp.leftMargin - lp.rightMargin;</span><br><span class="line">                    break;</span><br><span class="line">                case Gravity.RIGHT:</span><br><span class="line">                    if (!forceLeftGravity) &#123;</span><br><span class="line">                        childLeft &#x3D; parentRight - width - lp.rightMargin;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                case Gravity.LEFT:</span><br><span class="line">                default:</span><br><span class="line">                    childLeft &#x3D; parentLeft + lp.leftMargin;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            switch (verticalGravity) &#123;</span><br><span class="line">                case Gravity.TOP:</span><br><span class="line">                    childTop &#x3D; parentTop + lp.topMargin;</span><br><span class="line">                    break;</span><br><span class="line">                case Gravity.CENTER_VERTICAL:</span><br><span class="line">                    childTop &#x3D; parentTop + (parentBottom - parentTop - height) &#x2F; 2 +</span><br><span class="line">                    lp.topMargin - lp.bottomMargin;</span><br><span class="line">                    break;</span><br><span class="line">                case Gravity.BOTTOM:</span><br><span class="line">                    childTop &#x3D; parentBottom - height - lp.bottomMargin;</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    childTop &#x3D; parentTop + lp.topMargin;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            child.layout(childLeft, childTop, childLeft + width, childTop + height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FrameLayout的onLayout()过程也很清晰：</p>
<ul>
<li>遍历子View，根据gravity值的不同进行相应的childLeft/childTop值的处理</li>
<li>通过调整后的childLeft/childTop值，调用child的layout方法，进行布局</li>
</ul>
<h3 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw"></a>onDraw</h3><p>FrameLayout没有重写onDraw()方法</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>相对LinearLayout和RelativeLayout而言，FrameLayout的功能比较简单，因此onMeasure()和onLayout()的实现都比较简洁，在onMeasure()过程，最好情况是测量一次子View，最坏情况是两次。</p>
]]></content>
      <tags>
        <tag>Android布局</tag>
      </tags>
  </entry>
  <entry>
    <title>Android GridLayout源码学习</title>
    <url>/2021/04/16/Android-GridLayout%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="OverView"><a href="#OverView" class="headerlink" title="OverView"></a>OverView</h3><p>GridLayout是Android4.0引入的网格控件，可以方便地实现网格式布局，减少嵌套层级，这周看下GridLayout具体的工作原理。</p>
<h3 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h3><p>照例从测量阶段开始，看下GridLayout在测量阶段进行了什么操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthSpec, <span class="keyword">int</span> heightSpec)</span> </span>&#123;</span><br><span class="line">    consistencyCheck();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** If we have been called by &#123;<span class="doctag">@link</span> View#measure(int, int)&#125;, one of width or height</span></span><br><span class="line"><span class="comment">     *  is  likely to have changed. We must invalidate if so. */</span></span><br><span class="line">    invalidateValues();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> hPadding = getPaddingLeft() + getPaddingRight();</span><br><span class="line">    <span class="keyword">int</span> vPadding = getPaddingTop()  + getPaddingBottom();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> widthSpecSansPadding =  adjust( widthSpec, -hPadding);</span><br><span class="line">    <span class="keyword">int</span> heightSpecSansPadding = adjust(heightSpec, -vPadding);</span><br><span class="line"></span><br><span class="line">    measureChildrenWithMargins(widthSpecSansPadding, heightSpecSansPadding, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> widthSansPadding;</span><br><span class="line">    <span class="keyword">int</span> heightSansPadding;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the orientation property to decide which axis should be laid out first.</span></span><br><span class="line">    <span class="keyword">if</span> (mOrientation == HORIZONTAL) &#123;</span><br><span class="line">        widthSansPadding = mHorizontalAxis.getMeasure(widthSpecSansPadding);</span><br><span class="line">        measureChildrenWithMargins(widthSpecSansPadding, heightSpecSansPadding, <span class="keyword">false</span>);</span><br><span class="line">        heightSansPadding = mVerticalAxis.getMeasure(heightSpecSansPadding);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        heightSansPadding = mVerticalAxis.getMeasure(heightSpecSansPadding);</span><br><span class="line">        measureChildrenWithMargins(widthSpecSansPadding, heightSpecSansPadding, <span class="keyword">false</span>);</span><br><span class="line">        widthSansPadding = mHorizontalAxis.getMeasure(widthSpecSansPadding);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> measuredWidth  = Math.max(widthSansPadding  + hPadding, getSuggestedMinimumWidth());</span><br><span class="line">    <span class="keyword">int</span> measuredHeight = Math.max(heightSansPadding + vPadding, getSuggestedMinimumHeight());</span><br><span class="line"></span><br><span class="line">    setMeasuredDimension(</span><br><span class="line">            resolveSizeAndState(measuredWidth,   widthSpec, <span class="number">0</span>),</span><br><span class="line">            resolveSizeAndState(measuredHeight, heightSpec, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GridLayout的onMeasure()方法并不长，可以分成以下3个部分：</p>
<ul>
<li>兼容性检查、参数校验、padding的计算与调整</li>
<li>对子View进行第一次测量</li>
<li>对子View进行第二次测量</li>
</ul>
<p>其中对子View的测量是通过调用measureChildrenWithMargins()实现的，看下这个函数的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">measureChildrenWithMargins</span><span class="params">(<span class="keyword">int</span> widthSpec, <span class="keyword">int</span> heightSpec, <span class="keyword">boolean</span> firstPass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, N = getChildCount(); i &lt; N; i++) &#123;</span><br><span class="line">            View c = getChildAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c.getVisibility() == View.GONE) <span class="keyword">continue</span>;</span><br><span class="line">            LayoutParams lp = getLayoutParams(c);</span><br><span class="line">            <span class="keyword">if</span> (firstPass) &#123;</span><br><span class="line">                measureChildWithMargins2(c, widthSpec, heightSpec, lp.width, lp.height);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">boolean</span> horizontal = (mOrientation == HORIZONTAL);</span><br><span class="line">                Spec spec = horizontal ? lp.columnSpec : lp.rowSpec;</span><br><span class="line">                <span class="keyword">if</span> (spec.getAbsoluteAlignment(horizontal) == FILL) &#123;</span><br><span class="line">                    Interval span = spec.span;</span><br><span class="line">                    Axis axis = horizontal ? mHorizontalAxis : mVerticalAxis;</span><br><span class="line">                    <span class="keyword">int</span>[] locations = axis.getLocations();</span><br><span class="line">                    <span class="keyword">int</span> cellSize = locations[span.max] - locations[span.min];</span><br><span class="line">                    <span class="keyword">int</span> viewSize = cellSize - getTotalMargin(c, horizontal);</span><br><span class="line">                    <span class="keyword">if</span> (horizontal) &#123;</span><br><span class="line">                        measureChildWithMargins2(c, widthSpec, heightSpec, viewSize, lp.height);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        measureChildWithMargins2(c, widthSpec, heightSpec, lp.width, viewSize);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在这个函数中，可以看到有1个for循环来遍历子View，然后通过firstPass参数判断是第一轮测量还是第二轮测量，如果是第一轮测量，传入的参数是lp.width/lp.height来对子View进行测量；<br>关键在于第二轮测量的处理，可以看到如果spec.getAbsoluteAlignment(horizontal) == FILL这个条件不成立的话，第二轮测量实际上是没有对子View进行测量操作的。</p>
<p>我们来看下spec.getAbsoluteAlignment(horizontal) 这个的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Alignment <span class="title">getAbsoluteAlignment</span><span class="params">(<span class="keyword">boolean</span> horizontal)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (alignment != UNDEFINED_ALIGNMENT) &#123;</span><br><span class="line">                <span class="keyword">return</span> alignment;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (weight == <span class="number">0f</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> horizontal ? START : BASELINE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> FILL;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这个函数的返回结果和alignment与weight的值有关，weight的值就是我们设置给某个单元格的行/列权重，alignment与设置的gravity有关：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Alignment <span class="title">getAlignment</span><span class="params">(<span class="keyword">int</span> gravity, <span class="keyword">boolean</span> horizontal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mask = horizontal ? HORIZONTAL_GRAVITY_MASK : VERTICAL_GRAVITY_MASK;</span><br><span class="line">    <span class="keyword">int</span> shift = horizontal ? AXIS_X_SHIFT : AXIS_Y_SHIFT;</span><br><span class="line">    <span class="keyword">int</span> flags = (gravity &amp; mask) &gt;&gt; shift;</span><br><span class="line">    <span class="keyword">switch</span> (flags) &#123;</span><br><span class="line">        <span class="keyword">case</span> (AXIS_SPECIFIED | AXIS_PULL_BEFORE):</span><br><span class="line">            <span class="keyword">return</span> horizontal ? LEFT : TOP;</span><br><span class="line">        <span class="keyword">case</span> (AXIS_SPECIFIED | AXIS_PULL_AFTER):</span><br><span class="line">            <span class="keyword">return</span> horizontal ? RIGHT : BOTTOM;</span><br><span class="line">        <span class="keyword">case</span> (AXIS_SPECIFIED | AXIS_PULL_BEFORE | AXIS_PULL_AFTER):</span><br><span class="line">            <span class="keyword">return</span> FILL;</span><br><span class="line">        <span class="keyword">case</span> AXIS_SPECIFIED:</span><br><span class="line">            <span class="keyword">return</span> CENTER;</span><br><span class="line">        <span class="keyword">case</span> (AXIS_SPECIFIED | AXIS_PULL_BEFORE | RELATIVE_LAYOUT_DIRECTION):</span><br><span class="line">            <span class="keyword">return</span> START;</span><br><span class="line">        <span class="keyword">case</span> (AXIS_SPECIFIED | AXIS_PULL_AFTER | RELATIVE_LAYOUT_DIRECTION):</span><br><span class="line">            <span class="keyword">return</span> END;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> UNDEFINED_ALIGNMENT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可以得出，<strong>第二轮测量，实际上是根据gravity和weight值的设定，将多余的空间再次分配给子单元格</strong></p>
<h3 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout()"></a>onLayout()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    consistencyCheck();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> targetWidth = right - left;</span><br><span class="line">    <span class="keyword">int</span> targetHeight = bottom - top;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> paddingLeft = getPaddingLeft();</span><br><span class="line">    <span class="keyword">int</span> paddingTop = getPaddingTop();</span><br><span class="line">    <span class="keyword">int</span> paddingRight = getPaddingRight();</span><br><span class="line">    <span class="keyword">int</span> paddingBottom = getPaddingBottom();</span><br><span class="line"></span><br><span class="line">    mHorizontalAxis.layout(targetWidth - paddingLeft - paddingRight);</span><br><span class="line">    mVerticalAxis.layout(targetHeight - paddingTop - paddingBottom);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] hLocations = mHorizontalAxis.getLocations();</span><br><span class="line">    <span class="keyword">int</span>[] vLocations = mVerticalAxis.getLocations();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, N = getChildCount(); i &lt; N; i++) &#123;</span><br><span class="line">        View c = getChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (c.getVisibility() == View.GONE) <span class="keyword">continue</span>;</span><br><span class="line">        LayoutParams lp = getLayoutParams(c);</span><br><span class="line">        Spec columnSpec = lp.columnSpec;</span><br><span class="line">        Spec rowSpec = lp.rowSpec;</span><br><span class="line"></span><br><span class="line">        Interval colSpan = columnSpec.span;</span><br><span class="line">        Interval rowSpan = rowSpec.span;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> x1 = hLocations[colSpan.min];</span><br><span class="line">        <span class="keyword">int</span> y1 = vLocations[rowSpan.min];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> x2 = hLocations[colSpan.max];</span><br><span class="line">        <span class="keyword">int</span> y2 = vLocations[rowSpan.max];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cellWidth = x2 - x1;</span><br><span class="line">        <span class="keyword">int</span> cellHeight = y2 - y1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pWidth = getMeasurement(c, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">int</span> pHeight = getMeasurement(c, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        Alignment hAlign = columnSpec.getAbsoluteAlignment(<span class="keyword">true</span>);</span><br><span class="line">        Alignment vAlign = rowSpec.getAbsoluteAlignment(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        Bounds boundsX = mHorizontalAxis.getGroupBounds().getValue(i);</span><br><span class="line">        Bounds boundsY = mVerticalAxis.getGroupBounds().getValue(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Gravity offsets: the location of the alignment group relative to its cell group.</span></span><br><span class="line">        <span class="keyword">int</span> gravityOffsetX = hAlign.getGravityOffset(c, cellWidth - boundsX.size(<span class="keyword">true</span>));</span><br><span class="line">        <span class="keyword">int</span> gravityOffsetY = vAlign.getGravityOffset(c, cellHeight - boundsY.size(<span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftMargin = getMargin(c, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">int</span> topMargin = getMargin(c, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">int</span> rightMargin = getMargin(c, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">int</span> bottomMargin = getMargin(c, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sumMarginsX = leftMargin + rightMargin;</span><br><span class="line">        <span class="keyword">int</span> sumMarginsY = topMargin + bottomMargin;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Alignment offsets: the location of the view relative to its alignment group.</span></span><br><span class="line">        <span class="keyword">int</span> alignmentOffsetX = boundsX.getOffset(<span class="keyword">this</span>, c, hAlign, pWidth + sumMarginsX, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">int</span> alignmentOffsetY = boundsY.getOffset(<span class="keyword">this</span>, c, vAlign, pHeight + sumMarginsY, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> width = hAlign.getSizeInCell(c, pWidth, cellWidth - sumMarginsX);</span><br><span class="line">        <span class="keyword">int</span> height = vAlign.getSizeInCell(c, pHeight, cellHeight - sumMarginsY);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> dx = x1 + gravityOffsetX + alignmentOffsetX;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cx = !isLayoutRtl() ? paddingLeft + leftMargin + dx :</span><br><span class="line">                targetWidth - width - paddingRight - rightMargin - dx;</span><br><span class="line">        <span class="keyword">int</span> cy = paddingTop + y1 + gravityOffsetY + alignmentOffsetY + topMargin;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (width != c.getMeasuredWidth() || height != c.getMeasuredHeight()) &#123;</span><br><span class="line">            c.measure(makeMeasureSpec(width, EXACTLY), makeMeasureSpec(height, EXACTLY));</span><br><span class="line">        &#125;</span><br><span class="line">        c.layout(cx, cy, cx + width, cy + height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GridLayout的onLayout()函数乍看起来有点长，但明确onLayout()阶段目的之后就可以很好地梳理该函数的实现，onLayout()阶段的目的是确定好各个子View的位置，而对于GridLayout来说，子View的位置是通过x行y列这样的方式来设置的，因此只要计算出x行y列相应的坐标即可。</p>
<p>在onLayout()函数中需要特别注意的一点是，如果某个子View算出来的width和测量得到的width不一致时，会将算出的width传入子View再调用1次measure</p>
<h3 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw()"></a>onDraw()</h3><p>GridLayout作为容器布局，也没有重写onDraw()函数。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>GridLayout的实现相对简单，主要注意几个点：</p>
<ul>
<li>测量阶段会循环遍历2次子View，但第2次循环不一定会对子View进行测量</li>
<li>布局阶段有可能还会对子View进行measure()方法的调用。</li>
</ul>
]]></content>
      <tags>
        <tag>Android布局</tag>
      </tags>
  </entry>
  <entry>
    <title>Android ListView源码学习</title>
    <url>/2021/04/16/Android-ListView%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="OverView"><a href="#OverView" class="headerlink" title="OverView"></a>OverView</h3><p>Android ListView 是Android中常用的长列表组件，其继承层次如下：<br><img src="https://raw.githubusercontent.com/SysuCodeMan/PicBed/main/20210506174447.png"></p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>通常在业务代码中使用ListView的常用姿势是：</p>
<ul>
<li>创建1个ListView</li>
<li>创建1个BaseAdapter的子类，实现getCount/getItem/getItemId/getView这4个方法，有时候还会实现getItemViewType/getViewTypeCount方法来满足有多种ItemView样式的需求</li>
<li>将BaseAdatper的子类实例通过ListView的setAdapter()方法，设置给ListView实例</li>
</ul>
<h3 id="常用优化"><a href="#常用优化" class="headerlink" title="常用优化"></a>常用优化</h3><p>通常的ListView在View的复用上有2种优化：</p>
<ul>
<li>public View getView(int position, View convertView, ViewGroup parent)这个方法在实现是，首先判断一下传入的convertView是否为null，不为null即可复用，无需调用inflate或者new来新创建1个View</li>
<li>可以通过ViewHoloder的方法，将convertView的子View直接存一个引用在ViewHolder中，然后将ViewHolder通过convertView的setTag方法存储在convertView上；这种做法的好处在于，通过对子View的直接引用访问，避免了findViewById的耗时操作</li>
</ul>
<h3 id="源码浅析"><a href="#源码浅析" class="headerlink" title="源码浅析"></a>源码浅析</h3><p>ListView的源码比较长，暂时先把精力放在理解Adapter的6个方法(getViewTypeCount/getItemViewType/getCount/getItem/getItemId/getView)被调用的时机上，更详细的源码分析文章已经很多了，比较经典的有郭霖前辈的<a href="https://blog.csdn.net/sinyu890807/article/details/44996879">https://blog.csdn.net/sinyu890807/article/details/44996879</a></p>
<h3 id="int-getViewTypeCount"><a href="#int-getViewTypeCount" class="headerlink" title="int getViewTypeCount()"></a>int getViewTypeCount()</h3><p>在源码中搜索getViewTypeCount()被引用的位置，得到的和ListView相关的结果是在setAdapter(ListAdapter adapter)方法中有1行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mRecycler.setViewTypeCount(mAdapter.getViewTypeCount());</span><br></pre></td></tr></table></figure>
<p>这个mRecycler成员是RecycleBin类型，RecycleBin的定义在AbsListView中，其作用顾名思义，就是起到1个回收的垃圾箱作用，其setViewTypeCount(int viewTypeCount)方法的实现为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setViewTypeCount</span><span class="params">(<span class="keyword">int</span> viewTypeCount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (viewTypeCount &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Can&#x27;t have a viewTypeCount &lt; 1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//noinspection unchecked</span></span><br><span class="line">    ArrayList&lt;View&gt;[] scrapViews = <span class="keyword">new</span> ArrayList[viewTypeCount];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; viewTypeCount; i++) &#123;</span><br><span class="line">        scrapViews[i] = <span class="keyword">new</span> ArrayList&lt;View&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    mViewTypeCount = viewTypeCount;</span><br><span class="line">    mCurrentScrap = scrapViews[<span class="number">0</span>];</span><br><span class="line">    mScrapViews = scrapViews;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RecycleBin回收废弃View的实现是通过其scrapViews数组实现的，而传入的viewTypeCount决定了这个数组的长度，注意scrapViews的每一个成员是一个ArrayList<View>；在这里我的理解是，viewTypeCount决定了有多少种View会被回收，而每1个被回收的View会根据viewType进入到对应的ArrayList<View>中去，方便在复用时从正确的类型中取出对应的View来进行复用。</p>
<h3 id="int-getItemViewType-int-position"><a href="#int-getItemViewType-int-position" class="headerlink" title="int getItemViewType(int position)"></a>int getItemViewType(int position)</h3><p>在源码中搜索该函数，有好几处调用的地方，但多数调用都是得到viewType之后设置到AbsListView.LayoutParams的viewType属性上使用，这种使用并不是非常重要，真正关键的调用在AbsListView的getScrapView(position)函数中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">View <span class="title">getScrapView</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> whichScrap = mAdapter.getItemViewType(position);</span><br><span class="line">    <span class="keyword">if</span> (whichScrap &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mViewTypeCount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> retrieveFromScrap(mCurrentScrap, position);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (whichScrap &lt; mScrapViews.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> retrieveFromScrap(mScrapViews[whichScrap], position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getScrapView(int position)函数的作用在于，从废弃的View中获取一个View，准备复用，从实现上可以看出，getItemViewType的作用在于，得到正确的ViewType，从而从对应的mScrapViews数组中取出1个ScrapView</p>
<h3 id="int-getCount"><a href="#int-getCount" class="headerlink" title="int getCount()"></a>int getCount()</h3><p>getCount()的调用在源码中的搜索结果就实在是太多了，粗略浏览的一下，把觉得比较关键的点记录下来</p>
<ul>
<li><p>首先是ListView的setAdatper()函数中有这么一句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mItemCount = mAdapter.getCount();</span><br></pre></td></tr></table></figure>
<p>这个mItemCount是ListView的祖先类AdapterView的成员，设置到这上面之后就能更加方便地使用了</p>
</li>
<li><p>然后是ListView的layoutChildren()函数中有这么一段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mItemCount == <span class="number">0</span>) &#123;</span><br><span class="line">    resetList();</span><br><span class="line">    invokeOnItemScrollListener();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mItemCount != mAdapter.getCount()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The content of the adapter has changed but &quot;</span></span><br><span class="line">            + <span class="string">&quot;ListView did not receive a notification. Make sure the content of &quot;</span></span><br><span class="line">            + <span class="string">&quot;your adapter is not modified from a background thread, but only from &quot;</span></span><br><span class="line">            + <span class="string">&quot;the UI thread. Make sure your adapter calls notifyDataSetChanged() &quot;</span></span><br><span class="line">            + <span class="string">&quot;when its content changes. [in ListView(&quot;</span> + getId() + <span class="string">&quot;, &quot;</span> + getClass()</span><br><span class="line">            + <span class="string">&quot;) with Adapter(&quot;</span> + mAdapter.getClass() + <span class="string">&quot;)]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在layoutChildren()过程中需要检查mItemCount和mAdapter.getCount()是否一致，如果不一致，证明数据源被改变了却没有调用notifyDataSetChanged()通知观察方</p>
</li>
</ul>
<h3 id="Object-getItem-int-position"><a href="#Object-getItem-int-position" class="headerlink" title="Object getItem(int position)"></a>Object getItem(int position)</h3><p>getItem(int position)方法主要被调用的地方在AdapterView的getItemAtPosition(int position)函数中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getItemAtPosition</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    T adapter = getAdapter();</span><br><span class="line">    <span class="keyword">return</span> (adapter == <span class="keyword">null</span> || position &lt; <span class="number">0</span>) ? <span class="keyword">null</span> : adapter.getItem(position);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，在源码中再没找到getItem(int position)的相关调用，这也可以理解，因为getItem(int position)更主要的使用场景是我们在业务代码中调用，通过该方法，能够从Adapter里拿出数据项，而不需要直接跟数据源接触。</p>
<h3 id="long-getItemId-int-position"><a href="#long-getItemId-int-position" class="headerlink" title="long getItemId(int position)"></a>long getItemId(int position)</h3><p>getItemId(int postion)函数在源码中搜索，ListView中的调用已经被标注为@Deprecate，其余主要的调用都在AbsListView中，选择其中一处来看下这个方法的作用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setItemChecked</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (mChoiceMode == CHOICE_MODE_NONE) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Start selection mode if needed. We don&#x27;t need to if we&#x27;re unchecking something.</span></span><br><span class="line">     <span class="keyword">if</span> (value &amp;&amp; mChoiceMode == CHOICE_MODE_MULTIPLE_MODAL &amp;&amp; mChoiceActionMode == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (mMultiChoiceModeCallback == <span class="keyword">null</span> ||</span><br><span class="line">                 !mMultiChoiceModeCallback.hasWrappedCallback()) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;AbsListView: attempted to start selection mode &quot;</span> +</span><br><span class="line">                     <span class="string">&quot;for CHOICE_MODE_MULTIPLE_MODAL but no choice mode callback was &quot;</span> +</span><br><span class="line">                     <span class="string">&quot;supplied. Call setMultiChoiceModeListener to set a callback.&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         mChoiceActionMode = startActionMode(mMultiChoiceModeCallback);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">boolean</span> itemCheckChanged;</span><br><span class="line">     <span class="keyword">if</span> (mChoiceMode == CHOICE_MODE_MULTIPLE || mChoiceMode == CHOICE_MODE_MULTIPLE_MODAL) &#123;</span><br><span class="line">         <span class="keyword">boolean</span> oldValue = mCheckStates.get(position);</span><br><span class="line">         mCheckStates.put(position, value);</span><br><span class="line">         <span class="keyword">if</span> (mCheckedIdStates != <span class="keyword">null</span> &amp;&amp; mAdapter.hasStableIds()) &#123;</span><br><span class="line">             <span class="keyword">if</span> (value) &#123;</span><br><span class="line">                 mCheckedIdStates.put(mAdapter.getItemId(position), position);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 mCheckedIdStates.delete(mAdapter.getItemId(position));</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         itemCheckChanged = oldValue != value;</span><br><span class="line">         <span class="keyword">if</span> (itemCheckChanged) &#123;</span><br><span class="line">             <span class="keyword">if</span> (value) &#123;</span><br><span class="line">                 mCheckedItemCount++;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 mCheckedItemCount--;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (mChoiceActionMode != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">final</span> <span class="keyword">long</span> id = mAdapter.getItemId(position);</span><br><span class="line">             mMultiChoiceModeCallback.onItemCheckedStateChanged(mChoiceActionMode,</span><br><span class="line">                     position, id, value);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ……</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// this may end up selecting the value we just cleared but this way</span></span><br><span class="line">         <span class="comment">// we ensure length of mCheckStates is 1, a fact getCheckedItemPosition relies on</span></span><br><span class="line">         <span class="keyword">if</span> (value) &#123;</span><br><span class="line">             mCheckStates.put(position, <span class="keyword">true</span>);</span><br><span class="line">             <span class="keyword">if</span> (updateIds) &#123;</span><br><span class="line">                 mCheckedIdStates.put(mAdapter.getItemId(position), position);</span><br><span class="line">             &#125;</span><br><span class="line">             mCheckedItemCount = <span class="number">1</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mCheckStates.size() == <span class="number">0</span> || !mCheckStates.valueAt(<span class="number">0</span>)) &#123;</span><br><span class="line">             mCheckedItemCount = <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Do not generate a data change while we are in the layout phase or data has not changed</span></span><br><span class="line">     <span class="keyword">if</span> (!mInLayout &amp;&amp; !mBlockLayoutRequests &amp;&amp; itemCheckChanged) &#123;</span><br><span class="line">         mDataChanged = <span class="keyword">true</span>;</span><br><span class="line">         rememberSyncState();</span><br><span class="line">         requestLayout();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，主要是通过该方法，获得对应位置的id后，能够作为一个索引，用于增删改查等快速操作。</p>
<h3 id="View-getView-int-position-View-convertView-ViewGroup-parent"><a href="#View-getView-int-position-View-convertView-ViewGroup-parent" class="headerlink" title="View getView(int position, View convertView, ViewGroup parent)"></a>View getView(int position, View convertView, ViewGroup parent)</h3><p>最后Adapter中最重要的方法，getView方法的作用是返回某一项对应的ItemView，在源码中关键的调用是AbsListView中的obtainView()方法中的调用：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">final View scrapView = mRecycler.get<span class="constructor">ScrapView(<span class="params">position</span>)</span>;</span><br><span class="line">final View child = mAdapter.get<span class="constructor">View(<span class="params">position</span>, <span class="params">scrapView</span>, <span class="params">this</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (scrapView != null) &#123;</span><br><span class="line">    <span class="keyword">if</span> (child != scrapView) &#123;</span><br><span class="line">        <span class="comment">// Failed to re-bind the data, return scrap to the heap.</span></span><br><span class="line">        mRecycler.add<span class="constructor">ScrapView(<span class="params">scrapView</span>, <span class="params">position</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.is<span class="constructor">TemporarilyDetached()</span>) &#123;</span><br><span class="line">        outMetadata<span class="literal">[<span class="number">0</span>]</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Finish the temporary detach started in addScrapView().</span></span><br><span class="line">        child.dispatch<span class="constructor">FinishTemporaryDetach()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbsListView的obtainView函数的作用就是构建出某一position对应的View，首先会从mRecycler中取出一个对应的废弃View，这个废弃View就是传入Adapter的getView()方法中的convertView，这里也就解释了为什么需要判空——在首次布局时，实际上是还没有废弃的View可用的，而后面布局时就有废弃的View可复用，无需重新构建了。</p>
]]></content>
      <tags>
        <tag>Android控件</tag>
      </tags>
  </entry>
  <entry>
    <title>Android TableLayout源码学习</title>
    <url>/2021/04/16/Android-TableLayout%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="OverView"><a href="#OverView" class="headerlink" title="OverView"></a>OverView</h3><p>TableLayout是Android的六大布局容器之一，不过日常开发中使用得并不多，顾名思义，其主要特点是像表格一样，有行和列的概念。</p>
<h3 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h3><p>TableLayout有以下重要属性：</p>
<ul>
<li>android:shrinkColumns属性，当TableRow里边的空间布满布局的时候，指定列自动延伸以填充可用部分。当TableRow里边的控件还没有布满布局时，android:shrinkColumns不起作用。</li>
<li>android:stretchColumns属性，用于指定列对空白部分进行填充</li>
<li>android:collapseColumns属性，用于隐藏指定的列</li>
</ul>
<h3 id="继承层次及构造函数"><a href="#继承层次及构造函数" class="headerlink" title="继承层次及构造函数"></a>继承层次及构造函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TableLayout</span> <span class="keyword">extends</span> <span class="title">LinearLayout</span></span></span><br></pre></td></tr></table></figure>
<p>从继承层次上能够看到，TableLayout实际上是继承自LinearLayout的，直观上可以理解成，TableLayout就是一行行的TableRow线性排列而成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TableLayout</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line"></span><br><span class="line">        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.TableLayout);</span><br><span class="line"></span><br><span class="line">        String stretchedColumns = a.getString(R.styleable.TableLayout_stretchColumns);</span><br><span class="line">        <span class="keyword">if</span> (stretchedColumns != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stretchedColumns.charAt(<span class="number">0</span>) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                mStretchAllColumns = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mStretchableColumns = parseColumns(stretchedColumns);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String shrinkedColumns = a.getString(R.styleable.TableLayout_shrinkColumns);</span><br><span class="line">        <span class="keyword">if</span> (shrinkedColumns != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (shrinkedColumns.charAt(<span class="number">0</span>) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                mShrinkAllColumns = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mShrinkableColumns = parseColumns(shrinkedColumns);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String collapsedColumns = a.getString(R.styleable.TableLayout_collapseColumns);</span><br><span class="line">        <span class="keyword">if</span> (collapsedColumns != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mCollapsedColumns = parseColumns(collapsedColumns);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        a.recycle();</span><br><span class="line">        initTableLayout();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>构造函数也不长，主要就是对前文提到过的几个重要属性的分析，看下里面的parseColumns的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SparseBooleanArray <span class="title">parseColumns</span><span class="params">(String sequence)</span> </span>&#123;</span><br><span class="line">        SparseBooleanArray columns = <span class="keyword">new</span> SparseBooleanArray();</span><br><span class="line">        Pattern pattern = Pattern.compile(<span class="string">&quot;\\s*,\\s*&quot;</span>);</span><br><span class="line">        String[] columnDefs = pattern.split(sequence);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String columnIdentifier : columnDefs) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> columnIndex = Integer.parseInt(columnIdentifier);</span><br><span class="line">                <span class="comment">// only valid, i.e. positive, columns indexes are handled</span></span><br><span class="line">                <span class="keyword">if</span> (columnIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// putting true in this sparse array indicates that the</span></span><br><span class="line">                    <span class="comment">// column index was defined in the XML file</span></span><br><span class="line">                    columns.put(columnIndex, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                <span class="comment">// we just ignore columns that don&#x27;t exist</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> columns;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在设置shrinkColumns时都是可以设置多个值的，值之间通过逗号分隔，如”0,2”，在parseColumns中就将其中的值解析出来了。</p>
<h3 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h3><p>接下来看下TableLayout的测量过程做了什么：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// enforce vertical layout</span></span><br><span class="line">    measureVertical(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">measureVertical</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        findLargestCells(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        shrinkAndStretchColumns(widthMeasureSpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.measureVertical(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>TableLayout的onMeasure()过程很清晰，分别是自身两个方法findLargestCells()和shrinkAndStretchColumns()的调用，随后再调用父类LinearLayout的measureVertical()方法<br>先看下findLargestCells()的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Finds the largest cell in each column. For each column, the width of</span></span><br><span class="line"><span class="comment">     * the largest cell is applied to all the other cells.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> widthMeasureSpec the measure constraint imposed by our parent</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findLargestCells</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> firstRow = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find the maximum width for each column</span></span><br><span class="line">        <span class="comment">// the total number of columns is dynamically changed if we find</span></span><br><span class="line">        <span class="comment">// wider rows as we go through the children</span></span><br><span class="line">        <span class="comment">// the array is reused for each layout operation; the array can grow</span></span><br><span class="line">        <span class="comment">// but never shrinks. Unused extra cells in the array are just ignored</span></span><br><span class="line">        <span class="comment">// this behavior avoids to unnecessary grow the array after the first</span></span><br><span class="line">        <span class="comment">// layout operation</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> count = getChildCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = getChildAt(i);</span><br><span class="line">            <span class="keyword">if</span> (child.getVisibility() == GONE) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (child <span class="keyword">instanceof</span> TableRow) &#123;</span><br><span class="line">                <span class="keyword">final</span> TableRow row = (TableRow) child;</span><br><span class="line">                <span class="comment">// forces the row&#x27;s height</span></span><br><span class="line">                <span class="keyword">final</span> ViewGroup.LayoutParams layoutParams = row.getLayoutParams();</span><br><span class="line">                layoutParams.height = LayoutParams.WRAP_CONTENT;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span>[] widths = row.getColumnsWidths(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> newLength = widths.length;</span><br><span class="line">                <span class="comment">// this is the first row, we just need to copy the values</span></span><br><span class="line">                <span class="keyword">if</span> (firstRow) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mMaxWidths == <span class="keyword">null</span> || mMaxWidths.length != newLength) &#123;</span><br><span class="line">                        mMaxWidths = <span class="keyword">new</span> <span class="keyword">int</span>[newLength];</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.arraycopy(widths, <span class="number">0</span>, mMaxWidths, <span class="number">0</span>, newLength);</span><br><span class="line">                    firstRow = <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> length = mMaxWidths.length;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> difference = newLength - length;</span><br><span class="line">                    <span class="comment">// the current row is wider than the previous rows, so</span></span><br><span class="line">                    <span class="comment">// we just grow the array and copy the values</span></span><br><span class="line">                    <span class="keyword">if</span> (difference &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span>[] oldMaxWidths = mMaxWidths;</span><br><span class="line">                        mMaxWidths = <span class="keyword">new</span> <span class="keyword">int</span>[newLength];</span><br><span class="line">                        System.arraycopy(oldMaxWidths, <span class="number">0</span>, mMaxWidths, <span class="number">0</span>,</span><br><span class="line">                                oldMaxWidths.length);</span><br><span class="line">                        System.arraycopy(widths, oldMaxWidths.length,</span><br><span class="line">                                mMaxWidths, oldMaxWidths.length, difference);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// the row is narrower or of the same width as the previous</span></span><br><span class="line">                    <span class="comment">// rows, so we find the maximum width for each column</span></span><br><span class="line">                    <span class="comment">// if the row is narrower than the previous ones,</span></span><br><span class="line">                    <span class="comment">// difference will be negative</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span>[] maxWidths = mMaxWidths;</span><br><span class="line">                    length = Math.min(length, newLength);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                        maxWidths[j] = Math.max(maxWidths[j], widths[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从方法前的注释可以看出，该方法的作用是，找出每一列最宽的单元格，从方法的具体实现中能看到，最终每一列的最宽宽度会存储到maxWidth这个数组中。</p>
<p>接下来看下为何要找到每一列的最大宽度，答案在shrinkAndStretchColumns()方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shrinkAndStretchColumns</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// when we have no row, mMaxWidths is not initialized and the loop</span></span><br><span class="line">    <span class="comment">// below could cause a NPE</span></span><br><span class="line">    <span class="keyword">if</span> (mMaxWidths == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// should we honor AT_MOST, EXACTLY and UNSPECIFIED?</span></span><br><span class="line">    <span class="keyword">int</span> totalWidth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> width : mMaxWidths) &#123;</span><br><span class="line">        totalWidth += width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = MeasureSpec.getSize(widthMeasureSpec) - mPaddingLeft - mPaddingRight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((totalWidth &gt; size) &amp;&amp; (mShrinkAllColumns || mShrinkableColumns.size() &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// oops, the largest columns are wider than the row itself</span></span><br><span class="line">        <span class="comment">// fairly redistribute the row&#x27;s width among the columns</span></span><br><span class="line">        mutateColumnsWidth(mShrinkableColumns, mShrinkAllColumns, size, totalWidth);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((totalWidth &lt; size) &amp;&amp; (mStretchAllColumns || mStretchableColumns.size() &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// if we have some space left, we distribute it among the</span></span><br><span class="line">        <span class="comment">// expandable columns</span></span><br><span class="line">        mutateColumnsWidth(mStretchableColumns, mStretchAllColumns, size, totalWidth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这个函数中可以看到上述maxWidth的作用：</p>
<ul>
<li>将各列的maxWidth累加得到占据的总宽度</li>
<li>根据总宽度和容器宽度的大小关系，分别调用mutateColumnsWidth方法对此前设置的可伸缩列进行宽度调整，以达到设置前文提到的重要属性的设置效果</li>
</ul>
<h3 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// enforce horizontal layout</span></span><br><span class="line">    layoutHorizontal(l, t, r, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在onLayout()阶段，调用的是LinearLayout中的layoutHorizontal()实现，再一次说明，TableLayout其实就是竖直方向上的LinearLayout。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>TableLayout继承自LinearLayout，可以看做是竖直方向的LinearLayout</li>
<li>TableLayout的测量阶段，主要的工作是，将各列的宽度之和和容器宽度相比，根据大小关系对列进行拉伸调整</li>
</ul>
]]></content>
      <tags>
        <tag>Android布局</tag>
      </tags>
  </entry>
  <entry>
    <title>ViewGroup绘制源码学习</title>
    <url>/2021/04/13/ViewGroup%E7%BB%98%E5%88%B6%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>ViewGroup </p>
<blockquote>
<p>A ViewGroup is a special view that can contain other views. The view group is the base class for layouts and views containers. This class also defines the<br>  android.view.ViewGroup.LayoutParams class which serves as the base class for layouts parameters.</p>
</blockquote>
<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>首先看下ViewGroup的继承层次：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewGroup</span> <span class="keyword">extends</span> <span class="title">View</span> <span class="keyword">implements</span> <span class="title">ViewParent</span>, <span class="title">ViewManager</span> </span></span><br></pre></td></tr></table></figure>
<p>可以看到ViewGroup与View第一个不同点在于，ViewGroup是一个抽象类，继承自View，实现了ViewParent和ViewManager两个接口</p>
<h3 id="ViewParent和ViewManager"><a href="#ViewParent和ViewManager" class="headerlink" title="ViewParent和ViewManager"></a>ViewParent和ViewManager</h3><p>首先是ViewParent这个接口，内含的部分方法如下：<br><img src="https://raw.githubusercontent.com/SysuCodeMan/PicBed/main/20210506172925.png" alt="ViewParent部分方法"></p>
<p>其次是ViewManager的方法：<br><img src="https://raw.githubusercontent.com/SysuCodeMan/PicBed/main/20210506173006.png" alt="ViewManager"><br>ViewManager的方法很好理解，对View进行的增删改3个操作</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>和View类似，ViewGroup也有4个构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewGroup</span><span class="params">(Context context)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewGroup</span><span class="params">(Context context, AttributeSet attrs)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewGroup</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewGroup</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span></span></span><br></pre></td></tr></table></figure>
<p>但是实际上，前3个构造函数最终也只是调用到第4个，而第4个构造函数的实现也非常简单明了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewGroup</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr, defStyleRes);</span><br><span class="line"></span><br><span class="line">        initViewGroup();</span><br><span class="line">        initFromAttributes(context, attrs, defStyleAttr, defStyleRes);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>即两个init方法的调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initViewGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ViewGroup doesn&#x27;t draw by default</span></span><br><span class="line">        <span class="keyword">if</span> (!debugDraw()) &#123;</span><br><span class="line">            setFlags(WILL_NOT_DRAW, DRAW_MASK);</span><br><span class="line">        &#125;</span><br><span class="line">        mGroupFlags |= FLAG_CLIP_CHILDREN;</span><br><span class="line">        mGroupFlags |= FLAG_CLIP_TO_PADDING;</span><br><span class="line">        mGroupFlags |= FLAG_ANIMATION_DONE;</span><br><span class="line">        mGroupFlags |= FLAG_ANIMATION_CACHE;</span><br><span class="line">        mGroupFlags |= FLAG_ALWAYS_DRAWN_WITH_CACHE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mContext.getApplicationInfo().targetSdkVersion &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">            mGroupFlags |= FLAG_SPLIT_MOTION_EVENTS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setDescendantFocusability(FOCUS_BEFORE_DESCENDANTS);</span><br><span class="line"></span><br><span class="line">        mChildren = <span class="keyword">new</span> View[ARRAY_INITIAL_CAPACITY];</span><br><span class="line">        mChildrenCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        mPersistentDrawingCache = PERSISTENT_SCROLLING_CACHE;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先initViewGroup()方法对其自身的一些标志位等做了初始操作；然后调用initFromAttributes()，从函数名称也可以猜到，这个函数作用是从xml属性中进行初始化操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initFromAttributes</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ViewGroup, defStyleAttr,</span><br><span class="line">                defStyleRes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = a.getIndexCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> attr = a.getIndex(i);</span><br><span class="line">            <span class="keyword">switch</span> (attr) &#123;</span><br><span class="line">                <span class="keyword">case</span> R.styleable.ViewGroup_clipChildren:</span><br><span class="line">                    setClipChildren(a.getBoolean(attr, <span class="keyword">true</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> R.styleable.ViewGroup_clipToPadding:</span><br><span class="line">                    setClipToPadding(a.getBoolean(attr, <span class="keyword">true</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> R.styleable.ViewGroup_animationCache:</span><br><span class="line">                    setAnimationCacheEnabled(a.getBoolean(attr, <span class="keyword">true</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                ……</span><br><span class="line">                <span class="keyword">case</span> R.styleable.ViewGroup_touchscreenBlocksFocus:</span><br><span class="line">                    setTouchscreenBlocksFocus(a.getBoolean(attr, <span class="keyword">false</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        a.recycle();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="绘制相关"><a href="#绘制相关" class="headerlink" title="绘制相关"></a>绘制相关</h3><p>从View的绘制源码学习中已经知道，一个View的绘制，包括measure/layout/draw三个阶段，那么作为View的子类，ViewGroup的绘制也无非这3个阶段：</p>
<h5 id="measure"><a href="#measure" class="headerlink" title="measure"></a>measure</h5><p>因为View的measure()方法是个final方法，因此在ViewGroup中不能重写改方法，而ViewGroup中也没有实现onMeasure()方法，但在measure阶段，ViewGroup提供了几个measure相关的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildren</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> parentHeightMeasureSpec)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed)</span> </span></span><br></pre></td></tr></table></figure>
<p>这几个方法在实现上，关键的点是一致的，因此选择相对简洁的measureChild()来看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> parentHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">                mPaddingLeft + mPaddingRight, lp.width);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">                mPaddingTop + mPaddingBottom, lp.height);</span><br><span class="line"></span><br><span class="line">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>最关键的点在于最后一句，child.measure()，从View绘制过程已经知道，measure阶段的目的在于，让View得到自己所占据的大小，因此对ViewGroup来说，measure阶段，就需要让自己的所有子View知道自己的大小。</p>
<h5 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h5><p>在layout阶段，ViewGroup重写了View的layout()和onlayout()方法</p>
<p>实际上layout并没有做什么实质的工作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mSuppressLayout &amp;&amp; (mTransition == <span class="keyword">null</span> || !mTransition.isChangingLayout())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mTransition != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mTransition.layoutChange(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">super</span>.layout(l, t, r, b);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// record the fact that we noop&#x27;d it; request layout when transition finishes</span></span><br><span class="line">            mLayoutCalledWhileSuppressed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>更加关键的是onLayout()方法，这里变成了abstract抽象方法，这也是为什么ViewGroup是一个抽象类的原因</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(b</span></span></span><br><span class="line"><span class="function"><span class="params">        oolean changed,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="draw"><a href="#draw" class="headerlink" title="draw"></a>draw</h5><p>在draw阶段，ViewGroup里相关的函数是dispatchDraw()，drawChild()：在dispatchDraw()中遍历所有的子View，对所有子View执行drawChild()方法，而drawChild()方法的实现非常简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">drawChild</span><span class="params">(Canvas canvas, View child, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> child.draw(canvas, <span class="keyword">this</span>, drawingTime);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>ViewGroup的绘制，最终也就是各个子View自身的绘制。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后总结一下ViewGroup和View的差异：</p>
<ul>
<li>View是一个普通类，而ViewGroup是一个抽象类</li>
<li>measure阶段，View通过measure()和onMeasure()来确定自身的占据范围，ViewGroup通过measureChild()等方法来确定各个子View的占据范围</li>
<li>layout阶段，View通过layout()和onLayout()函数来确定位置，而ViewGroup中onLayout()变成抽象方法，需要子类实现；</li>
<li>draw阶段，View通过draw()和onDraw()方法来实现绘制，ViewGroup通过dispatchDraw()和drawChild()方法来让各个子View绘制自身。</li>
</ul>
]]></content>
      <tags>
        <tag>Android Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Android AbsoluteLayout源码学习</title>
    <url>/2021/04/16/Android-AbsoluteLayout%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="OverView"><a href="#OverView" class="headerlink" title="OverView"></a>OverView</h3><p>Android AbsoluteLayout是Android六大布局之一，但目前已经处于Deprecated状态，废弃的原因在于，绝对布局使用的是绝对坐标进行定位，而Android的屏幕大小各种各样，使用绝对坐标必然在兼容性上有极大问题。尽管如此，还是了解一下其实现。（整个类代码也不足300行）</p>
<h3 id="继承层次及构造函数"><a href="#继承层次及构造函数" class="headerlink" title="继承层次及构造函数"></a>继承层次及构造函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsoluteLayout</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span></span></span><br></pre></td></tr></table></figure>
<p>AbsoluteLayout也是继承自ViewGroup，在六大布局中，只有TableLayout是继承自LinearLayout，其余均继承自ViewGroup</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbsoluteLayout</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbsoluteLayout</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbsoluteLayout</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, attrs, defStyleAttr, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbsoluteLayout</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, attrs, defStyleAttr, defStyleRes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbsoluteLayout的4个构造函数，便是最简单的1个入参至4个入参的实现，最终调用到的是父类即ViewGroup的构造方法，没有进行额外的操作。</p>
<h3 id="AbsoluteLayout-LayoutParams"><a href="#AbsoluteLayout-LayoutParams" class="headerlink" title="AbsoluteLayout.LayoutParams"></a>AbsoluteLayout.LayoutParams</h3><p>布局容器一般都有自己对应的LayoutParams，用于实现自己特定支持的布局方法，相比LinearLayout.LayoutParams和RelativeLayout.LayoutParams，AbsoluteLayout.LayoutParams的结构简单很多，因为只要支持x,y坐标即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LayoutParams</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span>.<span class="title">LayoutParams</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The horizontal, or X, location of the child within the view group.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@InspectableProperty(name = &quot;layout_x&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> x;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The vertical, or Y, location of the child within the view group.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@InspectableProperty(name = &quot;layout_y&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LayoutParams</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(width, height);</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LayoutParams</span><span class="params">(Context c, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(c, attrs);</span><br><span class="line">            TypedArray a = c.obtainStyledAttributes(attrs,</span><br><span class="line">                    com.android.internal.R.styleable.AbsoluteLayout_Layout);</span><br><span class="line">            x = a.getDimensionPixelOffset(</span><br><span class="line">                    com.android.internal.R.styleable.AbsoluteLayout_Layout_layout_x, <span class="number">0</span>);</span><br><span class="line">            y = a.getDimensionPixelOffset(</span><br><span class="line">                    com.android.internal.R.styleable.AbsoluteLayout_Layout_layout_y, <span class="number">0</span>);</span><br><span class="line">            a.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LayoutParams</span><span class="params">(ViewGroup.LayoutParams source)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(source);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">debug</span><span class="params">(String output)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> output + <span class="string">&quot;Absolute.LayoutParams=&#123;width=&quot;</span></span><br><span class="line">                    + sizeToString(width) + <span class="string">&quot;, height=&quot;</span> + sizeToString(height)</span><br><span class="line">                    + <span class="string">&quot; x=&quot;</span> + x + <span class="string">&quot; y=&quot;</span> + y + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面就是AbsoluteLayout.LayoutParams的全部代码，可以看到其构造函数也就是从xml中解析出x、y的值。</p>
<h3 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure()"></a>onMeasure()</h3><p>接下来看下AbsoluteLayout的onMeasure()函数实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = getChildCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxHeight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxWidth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find out how big everyone wants to be</span></span><br><span class="line">    measureChildren(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find rightmost and bottom-most child</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        View child = getChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">            <span class="keyword">int</span> childRight;</span><br><span class="line">            <span class="keyword">int</span> childBottom;</span><br><span class="line"></span><br><span class="line">            AbsoluteLayout.LayoutParams lp</span><br><span class="line">                    = (AbsoluteLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">            childRight = lp.x + child.getMeasuredWidth();</span><br><span class="line">            childBottom = lp.y + child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">            maxWidth = Math.max(maxWidth, childRight);</span><br><span class="line">            maxHeight = Math.max(maxHeight, childBottom);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Account for padding too</span></span><br><span class="line">    maxWidth += mPaddingLeft + mPaddingRight;</span><br><span class="line">    maxHeight += mPaddingTop + mPaddingBottom;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check against minimum height and width</span></span><br><span class="line">    maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());</span><br><span class="line">    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</span><br><span class="line">    </span><br><span class="line">    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, <span class="number">0</span>),</span><br><span class="line">            resolveSizeAndState(maxHeight, heightMeasureSpec, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中主要的点有：</p>
<ul>
<li>先调用一次measureChildren()，完成了对子View的测量</li>
<li>随后的for循环会遍历一次子View，其目的在于，通过子View的x坐标值加上子View的宽，能得到子View最右端的值，同理也可以通过y坐标和高得到最小的坐标值；遍历所有子View得到所有子View中最右和最下的的坐标，即AbsoluteLayout所需要的宽和高</li>
<li>最后通过setMeasureDimension把宽高设置进去</li>
</ul>
<h3 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout()"></a>onLayout()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = getChildCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        View child = getChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line"></span><br><span class="line">            AbsoluteLayout.LayoutParams lp =</span><br><span class="line">                    (AbsoluteLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> childLeft = mPaddingLeft + lp.x;</span><br><span class="line">            <span class="keyword">int</span> childTop = mPaddingTop + lp.y;</span><br><span class="line">            child.layout(childLeft, childTop,</span><br><span class="line">                    childLeft + child.getMeasuredWidth(),</span><br><span class="line">                    childTop + child.getMeasuredHeight());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbsoluteLayout的onLayout()方法则更加直观了，因为本来onLayout()方法传入的left/top/right/bottom参数，就是一种绝对坐标的形式，因此只要拿到x/y坐标，加上相应的宽高，即可得到onLayout所需的参数。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>AbsoluteLayout的测量阶段，确定自身宽高的方式是，先测量子View，然后遍历一次子View找到所有子View中最右和最下的坐标，即为父容器自身的宽高。</li>
</ul>
]]></content>
      <tags>
        <tag>Android布局</tag>
      </tags>
  </entry>
  <entry>
    <title>Android ImageView源码浅析</title>
    <url>/2021/04/16/Android-ImageView%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h3 id="OverView"><a href="#OverView" class="headerlink" title="OverView"></a>OverView</h3><p>官方文档中关于ImageView的介绍是：<br>Displays image resources, for example Bitmap or Drawable resources. ImageView is also commonly used to apply tints to an image and handle image scaling.<br>即用来展示图像资源的控件。<br>其继承层次为<br><img src="https://raw.githubusercontent.com/SysuCodeMan/PicBed/main/20210506175117.png"></p>
<h3 id="ImageView-ScaleType"><a href="#ImageView-ScaleType" class="headerlink" title="ImageView.ScaleType"></a>ImageView.ScaleType</h3><p>在ImageView中有一个内部枚举类ScaleType，用来控制图像和ImageView的尺寸不一致时的拉伸规则：<br>| 枚举值 | 含义<br>| —-    | —- |<br>| CENTER| 不拉伸图像，居中置于ImageView中|<br>|CENTER_CROP|等比例拉伸图像，直至长和宽都等于或者大于ImageView的对应边，然后居中置于ImageView，（如果本来的长宽就都大于ImageView的对应边，则不拉伸）|<br>|CENTER_INSIDE|等比例拉伸图像，直至长和宽都等于或者小于ImageView的对应边，然后居中置于ImageView(如果本来的长宽就都小于ImageView的对应边，则不拉伸)|<br>|FILL_XY|图像的长和宽都拉伸到和ImageView一致，以充满ImageView，这种情况下会改变图像的比例|<br>|FILL_CENTER|等比例拉伸图片，直到某一边刚好和ImageView一致，然后居中置于ImageView|<br>|FILL_START|等比例拉伸图片，直到某一边刚好和ImageView一致，然后靠开始位置置于ImageView|<br>|FILL_END|等比例拉伸图片，直到某一边刚好和ImageView一致，然后靠结束位置置于ImageView|<br>|MATRIX|从左上角开始平铺图像|</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ImageView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">        initImageView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageView</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageView</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, defStyleAttr, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageView</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs, <span class="keyword">int</span> defStyleAttr,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr, defStyleRes);</span><br><span class="line"></span><br><span class="line">        initImageView();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (getImportantForAutofill() == IMPORTANT_FOR_AUTOFILL_AUTO) &#123;</span><br><span class="line">            setImportantForAutofill(IMPORTANT_FOR_AUTOFILL_NO);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> TypedArray a = context.obtainStyledAttributes(</span><br><span class="line">                attrs, R.styleable.ImageView, defStyleAttr, defStyleRes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Drawable d = a.getDrawable(R.styleable.ImageView_src);</span><br><span class="line">        <span class="keyword">if</span> (d != <span class="keyword">null</span>) &#123;</span><br><span class="line">            setImageDrawable(d);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mBaselineAlignBottom = a.getBoolean(R.styleable.ImageView_baselineAlignBottom, <span class="keyword">false</span>);</span><br><span class="line">        mBaseline = a.getDimensionPixelSize(R.styleable.ImageView_baseline, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        setAdjustViewBounds(a.getBoolean(R.styleable.ImageView_adjustViewBounds, <span class="keyword">false</span>));</span><br><span class="line">        setMaxWidth(a.getDimensionPixelSize(R.styleable.ImageView_maxWidth, Integer.MAX_VALUE));</span><br><span class="line">        setMaxHeight(a.getDimensionPixelSize(R.styleable.ImageView_maxHeight, Integer.MAX_VALUE));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> index = a.getInt(R.styleable.ImageView_scaleType, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            setScaleType(sScaleTypeArray[index]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a.hasValue(R.styleable.ImageView_tint)) &#123;</span><br><span class="line">            mDrawableTintList = a.getColorStateList(R.styleable.ImageView_tint);</span><br><span class="line">            mHasDrawableTint = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            mDrawableTintMode = PorterDuff.Mode.SRC_ATOP;</span><br><span class="line">            mHasDrawableTintMode = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a.hasValue(R.styleable.ImageView_tintMode)) &#123;</span><br><span class="line">            mDrawableTintMode = Drawable.parseTintMode(a.getInt(</span><br><span class="line">                    R.styleable.ImageView_tintMode, -<span class="number">1</span>), mDrawableTintMode);</span><br><span class="line">            mHasDrawableTintMode = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        applyImageTint();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> alpha = a.getInt(R.styleable.ImageView_drawableAlpha, <span class="number">255</span>);</span><br><span class="line">        <span class="keyword">if</span> (alpha != <span class="number">255</span>) &#123;</span><br><span class="line">            setImageAlpha(alpha);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mCropToPadding = a.getBoolean(</span><br><span class="line">                R.styleable.ImageView_cropToPadding, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        a.recycle();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>View的构造函数的写法都比较模板化，4个构造函数，2参数和3参数最终调用到的是4参数的构造函数，4参数的构造函数从xml中解析出各个属性也和其他View的构造函数是相同套路<br>单参数和4参数的构造函数，主要的工作都是调用了initImageView()函数<br>看下initImageView()函数的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initImageView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     mMatrix = <span class="keyword">new</span> Matrix();</span><br><span class="line">     mScaleType = ScaleType.FIT_CENTER;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!sCompatDone) &#123;</span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">int</span> targetSdkVersion = mContext.getApplicationInfo().targetSdkVersion;</span><br><span class="line">         sCompatAdjustViewBounds = targetSdkVersion &lt;= Build.VERSION_CODES.JELLY_BEAN_MR1;</span><br><span class="line">         sCompatUseCorrectStreamDensity = targetSdkVersion &gt; Build.VERSION_CODES.M;</span><br><span class="line">         sCompatDrawableVisibilityDispatch = targetSdkVersion &lt; Build.VERSION_CODES.N;</span><br><span class="line">         sCompatDone = <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>initImageView()函数也很简单，初始化了一个mMatrix变量，将mScaleType设置成默认的ScaleType.FIT_CENTER（后面展开说下ScaleType这个枚举类）<br>接下来看下4参数中调用的setImageDrawable(Drawable d)的调用，因为在实际使用中，ImageView的最关键就在于把图像展示出来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImageDrawable</span><span class="params">(<span class="meta">@Nullable</span> Drawable drawable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDrawable != drawable) &#123;</span><br><span class="line">        mResource = <span class="number">0</span>;</span><br><span class="line">        mUri = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldWidth = mDrawableWidth;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldHeight = mDrawableHeight;</span><br><span class="line"></span><br><span class="line">        updateDrawable(drawable);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (oldWidth != mDrawableWidth || oldHeight != mDrawableHeight) &#123;</span><br><span class="line">            requestLayout();</span><br><span class="line">        &#125;</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要逻辑在updateDrawable(Drawable d)里面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateDrawable</span><span class="params">(Drawable d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d != mRecycleableBitmapDrawable &amp;&amp; mRecycleableBitmapDrawable != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mRecycleableBitmapDrawable.setBitmap(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> sameDrawable = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDrawable != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sameDrawable = mDrawable == d;</span><br><span class="line">        mDrawable.setCallback(<span class="keyword">null</span>);</span><br><span class="line">        unscheduleDrawable(mDrawable);</span><br><span class="line">        <span class="keyword">if</span> (!sCompatDrawableVisibilityDispatch &amp;&amp; !sameDrawable &amp;&amp; isAttachedToWindow()) &#123;</span><br><span class="line">            mDrawable.setVisible(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDrawable = d;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d != <span class="keyword">null</span>) &#123;</span><br><span class="line">        d.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        d.setLayoutDirection(getLayoutDirection());</span><br><span class="line">        <span class="keyword">if</span> (d.isStateful()) &#123;</span><br><span class="line">            d.setState(getDrawableState());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!sameDrawable || sCompatDrawableVisibilityDispatch) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> visible = sCompatDrawableVisibilityDispatch</span><br><span class="line">                    ? getVisibility() == VISIBLE</span><br><span class="line">                    : isAttachedToWindow() &amp;&amp; getWindowVisibility() == VISIBLE &amp;&amp; isShown();</span><br><span class="line">            d.setVisible(visible, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        d.setLevel(mLevel);</span><br><span class="line">        mDrawableWidth = d.getIntrinsicWidth();</span><br><span class="line">        mDrawableHeight = d.getIntrinsicHeight();</span><br><span class="line">        applyImageTint();</span><br><span class="line">        applyColorMod();</span><br><span class="line"></span><br><span class="line">        configureBounds();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mDrawableWidth = mDrawableHeight = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的applyImageTint()和applyColorMod()函数的作用是设置着色、颜色相关的属性，比较关键的函数调用是configureBounds()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureBounds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDrawable == <span class="keyword">null</span> || !mHaveFrame) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> dwidth = mDrawableWidth;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> dheight = mDrawableHeight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> vwidth = getWidth() - mPaddingLeft - mPaddingRight;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> vheight = getHeight() - mPaddingTop - mPaddingBottom;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> fits = (dwidth &lt; <span class="number">0</span> || vwidth == dwidth)</span><br><span class="line">            &amp;&amp; (dheight &lt; <span class="number">0</span> || vheight == dheight);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dwidth &lt;= <span class="number">0</span> || dheight &lt;= <span class="number">0</span> || ScaleType.FIT_XY == mScaleType) &#123;</span><br><span class="line">        <span class="comment">/* If the drawable has no intrinsic size, or we&#x27;re told to</span></span><br><span class="line"><span class="comment">            scaletofit, then we just fill our entire view.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        mDrawable.setBounds(<span class="number">0</span>, <span class="number">0</span>, vwidth, vheight);</span><br><span class="line">        mDrawMatrix = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// We need to do the scaling ourself, so have the drawable</span></span><br><span class="line">        <span class="comment">// use its native size.</span></span><br><span class="line">        mDrawable.setBounds(<span class="number">0</span>, <span class="number">0</span>, dwidth, dheight);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ScaleType.MATRIX == mScaleType) &#123;</span><br><span class="line">            <span class="comment">// Use the specified matrix as-is.</span></span><br><span class="line">            <span class="keyword">if</span> (mMatrix.isIdentity()) &#123;</span><br><span class="line">                mDrawMatrix = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mDrawMatrix = mMatrix;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fits) &#123;</span><br><span class="line">            <span class="comment">// The bitmap fits exactly, no transform needed.</span></span><br><span class="line">            mDrawMatrix = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ScaleType.CENTER == mScaleType) &#123;</span><br><span class="line">            <span class="comment">// Center bitmap in view, no scaling.</span></span><br><span class="line">            mDrawMatrix = mMatrix;</span><br><span class="line">            mDrawMatrix.setTranslate(Math.round((vwidth - dwidth) * <span class="number">0.5f</span>),</span><br><span class="line">                                     Math.round((vheight - dheight) * <span class="number">0.5f</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ScaleType.CENTER_CROP == mScaleType) &#123;</span><br><span class="line">            mDrawMatrix = mMatrix;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> scale;</span><br><span class="line">            <span class="keyword">float</span> dx = <span class="number">0</span>, dy = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dwidth * vheight &gt; vwidth * dheight) &#123;</span><br><span class="line">                scale = (<span class="keyword">float</span>) vheight / (<span class="keyword">float</span>) dheight;</span><br><span class="line">                dx = (vwidth - dwidth * scale) * <span class="number">0.5f</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                scale = (<span class="keyword">float</span>) vwidth / (<span class="keyword">float</span>) dwidth;</span><br><span class="line">                dy = (vheight - dheight * scale) * <span class="number">0.5f</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mDrawMatrix.setScale(scale, scale);</span><br><span class="line">            mDrawMatrix.postTranslate(Math.round(dx), Math.round(dy));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ScaleType.CENTER_INSIDE == mScaleType) &#123;</span><br><span class="line">            mDrawMatrix = mMatrix;</span><br><span class="line">            <span class="keyword">float</span> scale;</span><br><span class="line">            <span class="keyword">float</span> dx;</span><br><span class="line">            <span class="keyword">float</span> dy;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dwidth &lt;= vwidth &amp;&amp; dheight &lt;= vheight) &#123;</span><br><span class="line">                scale = <span class="number">1.0f</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                scale = Math.min((<span class="keyword">float</span>) vwidth / (<span class="keyword">float</span>) dwidth,</span><br><span class="line">                        (<span class="keyword">float</span>) vheight / (<span class="keyword">float</span>) dheight);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dx = Math.round((vwidth - dwidth * scale) * <span class="number">0.5f</span>);</span><br><span class="line">            dy = Math.round((vheight - dheight * scale) * <span class="number">0.5f</span>);</span><br><span class="line"></span><br><span class="line">            mDrawMatrix.setScale(scale, scale);</span><br><span class="line">            mDrawMatrix.postTranslate(dx, dy);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Generate the required transform.</span></span><br><span class="line">            mTempSrc.set(<span class="number">0</span>, <span class="number">0</span>, dwidth, dheight);</span><br><span class="line">            mTempDst.set(<span class="number">0</span>, <span class="number">0</span>, vwidth, vheight);</span><br><span class="line"></span><br><span class="line">            mDrawMatrix = mMatrix;</span><br><span class="line">            mDrawMatrix.setRectToRect(mTempSrc, mTempDst, scaleTypeToScaleToFit(mScaleType));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的主要部分是一大堆的if条件对ScaleType的判断，对相应的ScaleType进行图像的矩阵Matrix处理</p>
<h3 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure()"></a>onMeasure()</h3><p>看完构造函数，接下来开始看绘制相关的内容，首先是第一阶段的onMeasure()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    resolveUri();</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Desired aspect ratio of the view&#x27;s contents (not including padding)</span></span><br><span class="line">    <span class="keyword">float</span> desiredAspect = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We are allowed to change the view&#x27;s width</span></span><br><span class="line">    <span class="keyword">boolean</span> resizeWidth = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We are allowed to change the view&#x27;s height</span></span><br><span class="line">    <span class="keyword">boolean</span> resizeHeight = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDrawable == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If no drawable, its intrinsic size is 0.</span></span><br><span class="line">        mDrawableWidth = -<span class="number">1</span>;</span><br><span class="line">        mDrawableHeight = -<span class="number">1</span>;</span><br><span class="line">        w = h = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        w = mDrawableWidth;</span><br><span class="line">        h = mDrawableHeight;</span><br><span class="line">        <span class="keyword">if</span> (w &lt;= <span class="number">0</span>) w = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (h &lt;= <span class="number">0</span>) h = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We are supposed to adjust view bounds to match the aspect</span></span><br><span class="line">        <span class="comment">// ratio of our drawable. See if that is possible.</span></span><br><span class="line">        <span class="keyword">if</span> (mAdjustViewBounds) &#123;</span><br><span class="line">            resizeWidth = widthSpecMode != MeasureSpec.EXACTLY;</span><br><span class="line">            resizeHeight = heightSpecMode != MeasureSpec.EXACTLY;</span><br><span class="line"></span><br><span class="line">            desiredAspect = (<span class="keyword">float</span>) w / (<span class="keyword">float</span>) h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> pleft = mPaddingLeft;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> pright = mPaddingRight;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> ptop = mPaddingTop;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> pbottom = mPaddingBottom;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> widthSize;</span><br><span class="line">    <span class="keyword">int</span> heightSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resizeWidth || resizeHeight) &#123;</span><br><span class="line">        <span class="comment">/* If we get here, it means we want to resize to match the</span></span><br><span class="line"><span class="comment">            drawables aspect ratio, and we have the freedom to change at</span></span><br><span class="line"><span class="comment">            least one dimension.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the max possible width given our constraints</span></span><br><span class="line">        widthSize = resolveAdjustedSize(w + pleft + pright, mMaxWidth, widthMeasureSpec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the max possible height given our constraints</span></span><br><span class="line">        heightSize = resolveAdjustedSize(h + ptop + pbottom, mMaxHeight, heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (desiredAspect != <span class="number">0.0f</span>) &#123;</span><br><span class="line">            <span class="comment">// See what our actual aspect ratio is</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> actualAspect = (<span class="keyword">float</span>)(widthSize - pleft - pright) /</span><br><span class="line">                                    (heightSize - ptop - pbottom);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Math.abs(actualAspect - desiredAspect) &gt; <span class="number">0.0000001</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Try adjusting width to be proportional to height</span></span><br><span class="line">                <span class="keyword">if</span> (resizeWidth) &#123;</span><br><span class="line">                    <span class="keyword">int</span> newWidth = (<span class="keyword">int</span>)(desiredAspect * (heightSize - ptop - pbottom)) +</span><br><span class="line">                            pleft + pright;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Allow the width to outgrow its original estimate if height is fixed.</span></span><br><span class="line">                    <span class="keyword">if</span> (!resizeHeight &amp;&amp; !sCompatAdjustViewBounds) &#123;</span><br><span class="line">                        widthSize = resolveAdjustedSize(newWidth, mMaxWidth, widthMeasureSpec);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (newWidth &lt;= widthSize) &#123;</span><br><span class="line">                        widthSize = newWidth;</span><br><span class="line">                        done = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Try adjusting height to be proportional to width</span></span><br><span class="line">                <span class="keyword">if</span> (!done &amp;&amp; resizeHeight) &#123;</span><br><span class="line">                    <span class="keyword">int</span> newHeight = (<span class="keyword">int</span>)((widthSize - pleft - pright) / desiredAspect) +</span><br><span class="line">                            ptop + pbottom;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Allow the height to outgrow its original estimate if width is fixed.</span></span><br><span class="line">                    <span class="keyword">if</span> (!resizeWidth &amp;&amp; !sCompatAdjustViewBounds) &#123;</span><br><span class="line">                        heightSize = resolveAdjustedSize(newHeight, mMaxHeight,</span><br><span class="line">                                heightMeasureSpec);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (newHeight &lt;= heightSize) &#123;</span><br><span class="line">                        heightSize = newHeight;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* We are either don&#x27;t want to preserve the drawables aspect ratio,</span></span><br><span class="line"><span class="comment">           or we are not allowed to change view dimensions. Just measure in</span></span><br><span class="line"><span class="comment">           the normal way.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        w += pleft + pright;</span><br><span class="line">        h += ptop + pbottom;</span><br><span class="line"></span><br><span class="line">        w = Math.max(w, getSuggestedMinimumWidth());</span><br><span class="line">        h = Math.max(h, getSuggestedMinimumHeight());</span><br><span class="line"></span><br><span class="line">        widthSize = resolveSizeAndState(w, widthMeasureSpec, <span class="number">0</span>);</span><br><span class="line">        heightSize = resolveSizeAndState(h, heightMeasureSpec, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setMeasuredDimension(widthSize, heightSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先会调用一次 resolveUri()，这个函数的作用是，确保在进行onMeasure()时已经有mDrawble，resolveUri()会在未设置mDrawble的情况下通过Uri来获取Drawable</li>
<li>通过mDrawable的宽高来设置w和h</li>
<li>默认情况下resizeWidth/resizeHeight取值为false，这样只会走最下面的一段else分支，w/h加上对应的padding，然后通过resolveSizeAndState产生相应的<br>MeasureSpec</li>
<li>假如resizeWidth/resizeHeight为true，会走到中间的if代码块中，这个代码块的作用是，根据比例规则重算宽高</li>
</ul>
<h3 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout()"></a>onLayout()</h3><p>因为ImageView只是普通View的子类，因此没有重写onLayout()</p>
<h3 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw()"></a>onDraw()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDrawable == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// couldn&#x27;t resolve the URI</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDrawableWidth == <span class="number">0</span> || mDrawableHeight == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;     <span class="comment">// nothing to draw (empty bounds)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDrawMatrix == <span class="keyword">null</span> &amp;&amp; mPaddingTop == <span class="number">0</span> &amp;&amp; mPaddingLeft == <span class="number">0</span>) &#123;</span><br><span class="line">        mDrawable.draw(canvas);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> saveCount = canvas.getSaveCount();</span><br><span class="line">        canvas.save();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mCropToPadding) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> scrollX = mScrollX;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> scrollY = mScrollY;</span><br><span class="line">            canvas.clipRect(scrollX + mPaddingLeft, scrollY + mPaddingTop,</span><br><span class="line">                    scrollX + mRight - mLeft - mPaddingRight,</span><br><span class="line">                    scrollY + mBottom - mTop - mPaddingBottom);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        canvas.translate(mPaddingLeft, mPaddingTop);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mDrawMatrix != <span class="keyword">null</span>) &#123;</span><br><span class="line">            canvas.concat(mDrawMatrix);</span><br><span class="line">        &#125;</span><br><span class="line">        mDrawable.draw(canvas);</span><br><span class="line">        canvas.restoreToCount(saveCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在onDraw()的源码可以看出，ImageView的绘制，最终是通过Drawable的draw(Canvas canvas)方法完成的。</p>
]]></content>
      <tags>
        <tag>Android控件</tag>
      </tags>
  </entry>
  <entry>
    <title>Android LinearLayout源码学习</title>
    <url>/2021/04/13/Android-LinearLayout%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>LinearLayout应该是Android开发中最常见的布局容器控件，可以实现子View的线性排列，通过layout_weight的可以方便地控制子View的大小。这篇文档目的在于通过对LinearLayout的源码阅读，理解LinearLayout的工作原理。</p>
<p>###onMeasure<br>在Android中，一个控件的工作过程分为测量、布局、绘制3大阶段，从onMeasure()函数入手，看下LinearLayout是如何完成测量工作的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">            measureVertical(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            measureHorizontal(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>根据设定的方向不同，会调用对应的measure方法，选取VERTICAL来进行解析：</p>
<h5 id="measureVertical-int-widthMeasureSpec-int-heightMeasureSpec"><a href="#measureVertical-int-widthMeasureSpec-int-heightMeasureSpec" class="headerlink" title="measureVertical(int widthMeasureSpec, int heightMeasureSpec)"></a>measureVertical(int widthMeasureSpec, int heightMeasureSpec)</h5><p>整个函数主要分成以下几点：</p>
<ul>
<li>变量声明</li>
<li>遍历子View，确定各个子View所需大小</li>
<li>如有需要，再次遍历子View，更新mTotalLength</li>
<li>再次遍历子View，将多余的空间根据layout_weight分配给子View</li>
</ul>
<p><strong>变量声明部分</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">measureVertical</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        mTotalLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxWidth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> childState = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> alternativeMaxWidth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> weightedMaxWidth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> allFillParent = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">float</span> totalWeight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> count = getVirtualChildCount();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> matchWidth = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> skippedMeasure = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> baselineChildIndex = mBaselineAlignedChildIndex;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> useLargestChild = mUseLargestChild;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> largestChildHeight = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> consumedExcessSpace = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nonSkippedChildCount = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一部分从变量名自身都能够猜到这些变量的意义</p>
<p>**初次遍历子View，确定子View所需大小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">measureVertical</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">        <span class="comment">// See how tall everyone is. Also remember max width.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = getVirtualChildAt(i);</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mTotalLength += measureNullChild(i);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (child.getVisibility() == View.GONE) &#123;</span><br><span class="line">               i += getChildrenSkipCount(child, i);</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nonSkippedChildCount++;</span><br><span class="line">            <span class="keyword">if</span> (hasDividerBeforeChildAt(i)) &#123;</span><br><span class="line">                mTotalLength += mDividerHeight;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">            totalWeight += lp.weight;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> useExcessSpace = lp.height == <span class="number">0</span> &amp;&amp; lp.weight &gt; <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (heightMode == MeasureSpec.EXACTLY &amp;&amp; useExcessSpace) &#123;</span><br><span class="line">                <span class="comment">// Optimization: don&#x27;t bother measuring children who are only</span></span><br><span class="line">                <span class="comment">// laid out using excess space. These views will get measured</span></span><br><span class="line">                <span class="comment">// later if we have space to distribute.</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</span><br><span class="line">                mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);</span><br><span class="line">                skippedMeasure = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (useExcessSpace) &#123;</span><br><span class="line">                    <span class="comment">// The heightMode is either UNSPECIFIED or AT_MOST, and</span></span><br><span class="line">                    <span class="comment">// this child is only laid out using excess space. Measure</span></span><br><span class="line">                    <span class="comment">// using WRAP_CONTENT so that we can find out the view&#x27;s</span></span><br><span class="line">                    <span class="comment">// optimal height. We&#x27;ll restore the original height of 0</span></span><br><span class="line">                    <span class="comment">// after measurement.</span></span><br><span class="line">                    lp.height = LayoutParams.WRAP_CONTENT;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Determine how big this child would like to be. If this or</span></span><br><span class="line">                <span class="comment">// previous children have given a weight, then we allow it to</span></span><br><span class="line">                <span class="comment">// use all available space (and we will shrink things later</span></span><br><span class="line">                <span class="comment">// if needed).</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> usedHeight = totalWeight == <span class="number">0</span> ? mTotalLength : <span class="number">0</span>;</span><br><span class="line">                measureChildBeforeLayout(child, i, widthMeasureSpec, <span class="number">0</span>,</span><br><span class="line">                        heightMeasureSpec, usedHeight);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</span><br><span class="line">                <span class="keyword">if</span> (useExcessSpace) &#123;</span><br><span class="line">                    <span class="comment">// Restore the original height and record how much space</span></span><br><span class="line">                    <span class="comment">// we&#x27;ve allocated to excess-only children so that we can</span></span><br><span class="line">                    <span class="comment">// match the behavior of EXACTLY measurement.</span></span><br><span class="line">                    lp.height = <span class="number">0</span>;</span><br><span class="line">                    consumedExcessSpace += childHeight;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</span><br><span class="line">                mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +</span><br><span class="line">                       lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (useLargestChild) &#123;</span><br><span class="line">                    largestChildHeight = Math.max(childHeight, largestChildHeight);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * If applicable, compute the additional offset to the child&#x27;s baseline</span></span><br><span class="line"><span class="comment">             * we&#x27;ll need later when asked &#123;<span class="doctag">@link</span> #getBaseline&#125;.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> ((baselineChildIndex &gt;= <span class="number">0</span>) &amp;&amp; (baselineChildIndex == i + <span class="number">1</span>)) &#123;</span><br><span class="line">               mBaselineChildTop = mTotalLength;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if we are trying to use a child index for our baseline, the above</span></span><br><span class="line">            <span class="comment">// book keeping only works if there are no children above it with</span></span><br><span class="line">            <span class="comment">// weight.  fail fast to aid the developer.</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; baselineChildIndex &amp;&amp; lp.weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;A child of LinearLayout with index &quot;</span></span><br><span class="line">                        + <span class="string">&quot;less than mBaselineAlignedChildIndex has weight &gt; 0, which &quot;</span></span><br><span class="line">                        + <span class="string">&quot;won&#x27;t work.  Either remove the weight, or don&#x27;t set &quot;</span></span><br><span class="line">                        + <span class="string">&quot;mBaselineAlignedChildIndex.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> matchWidthLocally = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (widthMode != MeasureSpec.EXACTLY &amp;&amp; lp.width == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                <span class="comment">// The width of the linear layout will scale, and at least one</span></span><br><span class="line">                <span class="comment">// child said it wanted to match our width. Set a flag</span></span><br><span class="line">                <span class="comment">// indicating that we need to remeasure at least that view when</span></span><br><span class="line">                <span class="comment">// we know our width.</span></span><br><span class="line">                matchWidth = <span class="keyword">true</span>;</span><br><span class="line">                matchWidthLocally = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> margin = lp.leftMargin + lp.rightMargin;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> measuredWidth = child.getMeasuredWidth() + margin;</span><br><span class="line">            maxWidth = Math.max(maxWidth, measuredWidth);</span><br><span class="line">            childState = combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line"></span><br><span class="line">            allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line">            <span class="keyword">if</span> (lp.weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Widths of weighted Views are bogus if we end up</span></span><br><span class="line"><span class="comment">                 * remeasuring, so keep them separate.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                weightedMaxWidth = Math.max(weightedMaxWidth,</span><br><span class="line">                        matchWidthLocally ? margin : measuredWidth);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                        matchWidthLocally ? margin : measuredWidth);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            i += getChildrenSkipCount(child, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ……</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在初次遍历子View中，关键需要理解的代码在于：</p>
<ul>
<li>如果heightMode为EXCATLY，并且遍历到的子View的height为0，而且weight大于0这个条件成立，将会将skippedMeasure设置为true，然后将<strong>不会</strong>对该子View进行测量</li>
<li>如果上述条件不成立，将会调用measureChildBeforeLayout()方法对该子View进行一次测量</li>
<li>如果对子View进行过测量，会将该子View的高度添加到mTotalLength上记录下来</li>
</ul>
<p><strong>如有需要，再次遍历子View，更新mTotalLength</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (useLargestChild &amp;&amp;</span><br><span class="line">                (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) &#123;</span><br><span class="line">            mTotalLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">                <span class="keyword">final</span> View child = getVirtualChildAt(i);</span><br><span class="line">                <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mTotalLength += measureNullChild(i);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (child.getVisibility() == GONE) &#123;</span><br><span class="line">                    i += getChildrenSkipCount(child, i);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams)</span><br><span class="line">                        child.getLayoutParams();</span><br><span class="line">                <span class="comment">// Account for negative margins</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</span><br><span class="line">                mTotalLength = Math.max(totalLength, totalLength + largestChildHeight +</span><br><span class="line">                        lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这里是如果设置了useLargestChild才会走到的逻辑</p>
<p><strong>再次遍历子View，将多余的空间根据layout_weight分配给子View</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">measureVertical</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> heightSize = mTotalLength;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check against our minimum height</span></span><br><span class="line">        heightSize = Math.max(heightSize, getSuggestedMinimumHeight());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reconcile our calculated size with the heightMeasureSpec</span></span><br><span class="line">        <span class="keyword">int</span> heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, <span class="number">0</span>);</span><br><span class="line">        heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;</span><br><span class="line">        <span class="comment">// Either expand children with weight to take up available space or</span></span><br><span class="line">        <span class="comment">// shrink them if they extend beyond our current bounds. If we skipped</span></span><br><span class="line">        <span class="comment">// measurement on any children, we need to measure them now.</span></span><br><span class="line">        <span class="keyword">int</span> remainingExcess = heightSize - mTotalLength</span><br><span class="line">                + (mAllowInconsistentMeasurement ? <span class="number">0</span> : consumedExcessSpace);</span><br><span class="line">        <span class="keyword">if</span> (skippedMeasure</span><br><span class="line">                || ((sRemeasureWeightedChildren || remainingExcess != <span class="number">0</span>) &amp;&amp; totalWeight &gt; <span class="number">0.0f</span>)) &#123;</span><br><span class="line">            <span class="keyword">float</span> remainingWeightSum = mWeightSum &gt; <span class="number">0.0f</span> ? mWeightSum : totalWeight;</span><br><span class="line"></span><br><span class="line">            mTotalLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">                <span class="keyword">final</span> View child = getVirtualChildAt(i);</span><br><span class="line">                <span class="keyword">if</span> (child == <span class="keyword">null</span> || child.getVisibility() == View.GONE) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> childWeight = lp.weight;</span><br><span class="line">                <span class="keyword">if</span> (childWeight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> share = (<span class="keyword">int</span>) (childWeight * remainingExcess / remainingWeightSum);</span><br><span class="line">                    remainingExcess -= share;</span><br><span class="line">                    remainingWeightSum -= childWeight;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> childHeight;</span><br><span class="line">                    <span class="keyword">if</span> (mUseLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">                        childHeight = largestChildHeight;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lp.height == <span class="number">0</span> &amp;&amp; (!mAllowInconsistentMeasurement</span><br><span class="line">                            || heightMode == MeasureSpec.EXACTLY)) &#123;</span><br><span class="line">                        <span class="comment">// This child needs to be laid out from scratch using</span></span><br><span class="line">                        <span class="comment">// only its share of excess space.</span></span><br><span class="line">                        childHeight = share;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// This child had some intrinsic height to which we</span></span><br><span class="line">                        <span class="comment">// need to add its share of excess space.</span></span><br><span class="line">                        childHeight = child.getMeasuredHeight() + share;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                            Math.max(<span class="number">0</span>, childHeight), MeasureSpec.EXACTLY);</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,</span><br><span class="line">                            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin,</span><br><span class="line">                            lp.width);</span><br><span class="line">                    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Child may now not fit in vertical dimension.</span></span><br><span class="line">                    childState = combineMeasuredStates(childState, child.getMeasuredState()</span><br><span class="line">                            &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> margin =  lp.leftMargin + lp.rightMargin;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> measuredWidth = child.getMeasuredWidth() + margin;</span><br><span class="line">                maxWidth = Math.max(maxWidth, measuredWidth);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">boolean</span> matchWidthLocally = widthMode != MeasureSpec.EXACTLY &amp;&amp;</span><br><span class="line">                        lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line"></span><br><span class="line">                alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                        matchWidthLocally ? margin : measuredWidth);</span><br><span class="line"></span><br><span class="line">                allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</span><br><span class="line">                mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() +</span><br><span class="line">                        lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add in our padding</span></span><br><span class="line">            mTotalLength += mPaddingTop + mPaddingBottom;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Should we recompute the heightSpec based on the new total length?</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                                           weightedMaxWidth);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// We have no limit, so make all weighted views as tall as the largest child.</span></span><br><span class="line">            <span class="comment">// Children will have already been measured once.</span></span><br><span class="line">            <span class="keyword">if</span> (useLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                    <span class="keyword">final</span> View child = getVirtualChildAt(i);</span><br><span class="line">                    <span class="keyword">if</span> (child == <span class="keyword">null</span> || child.getVisibility() == View.GONE) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> LinearLayout.LayoutParams lp =</span><br><span class="line">                            (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">float</span> childExtra = lp.weight;</span><br><span class="line">                    <span class="keyword">if</span> (childExtra &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        child.measure(</span><br><span class="line">                                MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(),</span><br><span class="line">                                        MeasureSpec.EXACTLY),</span><br><span class="line">                                MeasureSpec.makeMeasureSpec(largestChildHeight,</span><br><span class="line">                                        MeasureSpec.EXACTLY));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!allFillParent &amp;&amp; widthMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">            maxWidth = alternativeMaxWidth;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        maxWidth += mPaddingLeft + mPaddingRight;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check against our minimum width</span></span><br><span class="line">        maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</span><br><span class="line"></span><br><span class="line">        setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class="line">                heightSizeAndState);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (matchWidth) &#123;</span><br><span class="line">            forceUniformWidth(count, heightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这一阶段最终要的代码在于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (childWeight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> share = (<span class="keyword">int</span>) (childWeight * remainingExcess / remainingWeightSum);</span><br><span class="line">                    remainingExcess -= share;</span><br><span class="line">                    remainingWeightSum -= childWeight;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> childHeight;</span><br><span class="line">                    <span class="keyword">if</span> (mUseLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">                        childHeight = largestChildHeight;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lp.height == <span class="number">0</span> &amp;&amp; (!mAllowInconsistentMeasurement</span><br><span class="line">                            || heightMode == MeasureSpec.EXACTLY)) &#123;</span><br><span class="line">                        <span class="comment">// This child needs to be laid out from scratch using</span></span><br><span class="line">                        <span class="comment">// only its share of excess space.</span></span><br><span class="line">                        childHeight = share;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// This child had some intrinsic height to which we</span></span><br><span class="line">                        <span class="comment">// need to add its share of excess space.</span></span><br><span class="line">                        childHeight = child.getMeasuredHeight() + share;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                            Math.max(<span class="number">0</span>, childHeight), MeasureSpec.EXACTLY);</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,</span><br><span class="line">                            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin,</span><br><span class="line">                            lp.width);</span><br><span class="line">                    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果子View设置了大于0的layout_weight，将在这里计算出对应的share值</li>
<li>根据share值和原本子View测量到的高度，再次调用子View的measure方法进行测量</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>根据以上源码的阅读，我们可以总结一下在不同情况下，LinearLayout需要测量多少次子View：</p>
<ul>
<li>如果所有的子View都没有设置layout_weight，测量1次</li>
<li>如果有子View设置了layout_weight，设置了layout_weight的子View将测量2次</li>
</ul>
]]></content>
      <tags>
        <tag>Android布局</tag>
      </tags>
  </entry>
  <entry>
    <title>Android RecyclerView源码浅析</title>
    <url>/2021/04/16/Android-RecyclerView%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h3 id="OverView"><a href="#OverView" class="headerlink" title="OverView"></a>OverView</h3><p>RecyclerView是Android5.0推出的新组件，可以认为是更加灵活强大的ListView，在日常开发中基本上已经取代了ListView成为长列表控件的首选。<br>其继承结构如下：<br><img src="https://raw.githubusercontent.com/SysuCodeMan/PicBed/main/20210506174618.png"><br>从继承结构可以看到，RecyclerView是ViewGroup的直接子类，这里就是RecyclerView与ListView第一点大不同，ListView和ViewGroup之间隔了两层，其实个人认为在继承结构上揭露了RecyclerView相比ListView的优点：由于RecyclerView这么简单的继承结构，说明了其主要功能都是通过<strong>组合</strong>来实现的，而ListView是通过<strong>继承</strong>实现的。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>通常来说，在业务代码中使用RecyclerView，主要有以下几个步骤：</p>
<ul>
<li>创建RecyclerView实例</li>
<li>为RecyclerView设置LayoutManager，LayoutManager是一个抽象类，常用的实现类有LinearLayoutManager</li>
<li>如有必要，为RecyclerView设置ItemAnimator</li>
<li>如有必要，为RecyclerView设置ItemDecoration</li>
<li>继承RecyclerView.Adapter<VH extends ViewHolder>，实现getItemCount()/onCreateViewHolder(ViewGroup parent, int viewType)/onBindViewHolder(VH holder, int position)</li>
<li>在RecyclerView.Adapter中使用到的VH是ViewHolder的实现类，但ViewHolder虽然是一个抽象类，其中却没有需要我们实现的抽象方法，ViewHolder中关键的成员是itemView，即其承载的视图，可见性为public，可以直接获取</li>
</ul>
<h3 id="源码浅析"><a href="#源码浅析" class="headerlink" title="源码浅析"></a>源码浅析</h3><p>这部分跟随RecyclerView使用到的各个类的方法，看下这些关键方法是在何时被调用的</p>
<h3 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h3><ul>
<li><p>public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType)<br>在源码中查找onCreateViewHolder(ViewGroup parent, int viewType)的调用，能得到下图<br><img src="https://raw.githubusercontent.com/SysuCodeMan/PicBed/main/20210506174636.png">内一层是外一层的调用，最终可以看到主要的调用在LinearLayoutManager的onLayoutChildren()；直接的调用方法是在RecyclerView的tryGetViewHolderForPositionByDeadline(int position, boolean dryRun, long deadlineNs)中有这么1段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">long</span> start = getNanoTime();</span><br><span class="line">    <span class="keyword">if</span> (deadlineNs != FOREVER_NS</span><br><span class="line">            &amp;&amp; !mRecyclerPool.willCreateInTime(type, start, deadlineNs)) &#123;</span><br><span class="line">        <span class="comment">// abort - we have a deadline we can&#x27;t meet</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    holder = mAdapter.createViewHolder(RecyclerView.<span class="keyword">this</span>, type);</span><br><span class="line">    <span class="keyword">if</span> (ALLOW_THREAD_GAP_WORK) &#123;</span><br><span class="line">        <span class="comment">// only bother finding nested RV if prefetching</span></span><br><span class="line">        RecyclerView innerView = findNestedRecyclerView(holder.itemView);</span><br><span class="line">        <span class="keyword">if</span> (innerView != <span class="keyword">null</span>) &#123;</span><br><span class="line">            holder.mNestedRecyclerView = <span class="keyword">new</span> WeakReference&lt;&gt;(innerView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> end = getNanoTime();</span><br><span class="line">    mRecyclerPool.factorInCreateTime(type, end - start);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;tryGetViewHolderForPositionByDeadline created new ViewHolder&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单来说，就是在layout()过程，如果holder为null，就调用这个方法来创建一个ViewHolder</p>
</li>
<li><p>public void onBindViewHolder(RecyclerView.ViewHolder holder, int position)<br>首先在RecyclerView.Adapter的bindViewHolder(VH holder, int position)中有直接调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bindViewHolder</span><span class="params">(VH holder, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    holder.mPosition = position;</span><br><span class="line">    <span class="keyword">if</span> (hasStableIds()) &#123;</span><br><span class="line">        holder.mItemId = getItemId(position);</span><br><span class="line">    &#125;</span><br><span class="line">    holder.setFlags(ViewHolder.FLAG_BOUND,</span><br><span class="line">            ViewHolder.FLAG_BOUND | ViewHolder.FLAG_UPDATE | ViewHolder.FLAG_INVALID</span><br><span class="line">                    | ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN);</span><br><span class="line">    TraceCompat.beginSection(TRACE_BIND_VIEW_TAG);</span><br><span class="line">    onBindViewHolder(holder, position, holder.getUnmodifiedPayloads());</span><br><span class="line">    holder.clearPayload();</span><br><span class="line">    <span class="keyword">final</span> ViewGroup.LayoutParams layoutParams = holder.itemView.getLayoutParams();</span><br><span class="line">    <span class="keyword">if</span> (layoutParams <span class="keyword">instanceof</span> RecyclerView.LayoutParams) &#123;</span><br><span class="line">        ((LayoutParams) layoutParams).mInsetsDirty = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TraceCompat.endSection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用完之后从其itemView中取出LayoutParams来进行处理<br>然后再源码中查找最终的调用链，结果如下：<br><img src="https://upload-images.jianshu.io/upload_images/5866715-af28fd79ed1d96b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>调用链中关键的一环是在RecyclerView的View getViewForPosition(int position, boolean dryRun)中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">View <span class="title">getViewForPosition</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">boolean</span> dryRun)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面先调用了tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS)方法，在前面分析onCreateViewHolder()的时候已经看到了，这个方法里尝试获取holder，取不到就创建holder，创建后就进行onBindViewHolder()的操作，bind完之后在这里可以看到，返回的是holder.itemView，因此在布局过程中，就是从这里获得了正确的itemView</p>
</li>
<li><p>int getItemCount()<br>这个方法的调用，在源码里看都是直接调用<br><img src="https://raw.githubusercontent.com/SysuCodeMan/PicBed/main/20210506174757.png"></p>
</li>
<li><p>int getItemViewType(int position)<br>这个方法在源码中的被调用位置主要是RecyclerView的tryGetViewHolderForPositionByDeadline()函数，这个函数在上面也已经出现过了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> type = mAdapter.getItemViewType(offsetPosition);</span><br><span class="line"><span class="comment">// 2) Find from scrap/cache via stable ids, if exists</span></span><br><span class="line"><span class="keyword">if</span> (mAdapter.hasStableIds()) &#123;</span><br><span class="line">    holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),</span><br><span class="line">            type, dryRun);</span><br><span class="line">    <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// update position</span></span><br><span class="line">        holder.mPosition = offsetPosition;</span><br><span class="line">        fromScrapOrHiddenOrCache = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这个方法拿到的type，就是在onCreateViewHolder()/onBindViewHolder()函数中的入参type</p>
</li>
</ul>
<h3 id="LayoutManager"><a href="#LayoutManager" class="headerlink" title="LayoutManager"></a>LayoutManager</h3><ul>
<li>public abstract LayoutParams generateDefaultLayoutParams();<br>查找源码，这个方法被调用的位置为RecyclerView的同名函数中：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> ViewGroup.<span class="function">LayoutParams <span class="title">generateDefaultLayoutParams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mLayout == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;RecyclerView has no LayoutManager&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mLayout.generateDefaultLayoutParams();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>public void onLayoutChildren(Recycler recycler, State state)<br>这个方法本身并不是abstract函数，但在LayoutManager中必须重写：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLayoutChildren</span><span class="params">(Recycler recycler, State state)</span> </span>&#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;You must override onLayoutChildren(Recycler recycler, State state) &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在源码中查找其调用，可以看到被调用的地方主要有两处：<br>首先是RecyclerView的dispatchLayoutStep1()函数<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mState.assertLayoutStep(State.STEP_START);</span><br><span class="line">    mState.mIsMeasuring = <span class="keyword">false</span>;</span><br><span class="line">    eatRequestLayout();</span><br><span class="line">    mViewInfoStore.clear();</span><br><span class="line">    onEnterLayoutOrScroll();</span><br><span class="line">    processAdapterUpdatesAndSetAnimationFlags();</span><br><span class="line">    saveFocusInfo();</span><br><span class="line">    mState.mTrackOldChangeHolders = mState.mRunSimpleAnimations &amp;&amp; mItemsChanged;</span><br><span class="line">    mItemsAddedOrRemoved = mItemsChanged = <span class="keyword">false</span>;</span><br><span class="line">    mState.mInPreLayout = mState.mRunPredictiveAnimations;</span><br><span class="line">    mState.mItemCount = mAdapter.getItemCount();</span><br><span class="line">    findMinMaxChildLayoutPositions(mMinMaxLayoutPositions);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mState.mRunSimpleAnimations) &#123;</span><br><span class="line">        <span class="comment">// Step 0: Find out where all non-removed items are, pre-layout</span></span><br><span class="line">        <span class="keyword">int</span> count = mChildHelper.getChildCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            <span class="keyword">final</span> ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));</span><br><span class="line">            <span class="keyword">if</span> (holder.shouldIgnore() || (holder.isInvalid() &amp;&amp; !mAdapter.hasStableIds())) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> ItemHolderInfo animationInfo = mItemAnimator</span><br><span class="line">                    .recordPreLayoutInformation(mState, holder,</span><br><span class="line">                            ItemAnimator.buildAdapterChangeFlagsForAnimations(holder),</span><br><span class="line">                            holder.getUnmodifiedPayloads());</span><br><span class="line">            mViewInfoStore.addToPreLayout(holder, animationInfo);</span><br><span class="line">            <span class="keyword">if</span> (mState.mTrackOldChangeHolders &amp;&amp; holder.isUpdated() &amp;&amp; !holder.isRemoved()</span><br><span class="line">                    &amp;&amp; !holder.shouldIgnore() &amp;&amp; !holder.isInvalid()) &#123;</span><br><span class="line">                <span class="keyword">long</span> key = getChangedHolderKey(holder);</span><br><span class="line">                <span class="comment">// This is NOT the only place where a ViewHolder is added to old change holders</span></span><br><span class="line">                <span class="comment">// list. There is another case where:</span></span><br><span class="line">                <span class="comment">//    * A VH is currently hidden but not deleted</span></span><br><span class="line">                <span class="comment">//    * The hidden item is changed in the adapter</span></span><br><span class="line">                <span class="comment">//    * Layout manager decides to layout the item in the pre-Layout pass (step1)</span></span><br><span class="line">                <span class="comment">// When this case is detected, RV will un-hide that view and add to the old</span></span><br><span class="line">                <span class="comment">// change holders list.</span></span><br><span class="line">                mViewInfoStore.addToOldChangeHolders(key, holder);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mState.mRunPredictiveAnimations) &#123;</span><br><span class="line">        <span class="comment">// Step 1: run prelayout: This will use the old positions of items. The layout manager</span></span><br><span class="line">        <span class="comment">// is expected to layout everything, even removed items (though not to add removed</span></span><br><span class="line">        <span class="comment">// items back to the container). This gives the pre-layout position of APPEARING views</span></span><br><span class="line">        <span class="comment">// which come into existence as part of the real layout.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save old positions so that LayoutManager can run its mapping logic.</span></span><br><span class="line">        saveOldPositions();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> didStructureChange = mState.mStructureChanged;</span><br><span class="line">        mState.mStructureChanged = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// temporarily disable flag because we are asking for previous layout</span></span><br><span class="line">        mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class="line">        mState.mStructureChanged = didStructureChange;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mChildHelper.getChildCount(); ++i) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = mChildHelper.getChildAt(i);</span><br><span class="line">            <span class="keyword">final</span> ViewHolder viewHolder = getChildViewHolderInt(child);</span><br><span class="line">            <span class="keyword">if</span> (viewHolder.shouldIgnore()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!mViewInfoStore.isInPreLayout(viewHolder)) &#123;</span><br><span class="line">                <span class="keyword">int</span> flags = ItemAnimator.buildAdapterChangeFlagsForAnimations(viewHolder);</span><br><span class="line">                <span class="keyword">boolean</span> wasHidden = viewHolder</span><br><span class="line">                        .hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);</span><br><span class="line">                <span class="keyword">if</span> (!wasHidden) &#123;</span><br><span class="line">                    flags |= ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">final</span> ItemHolderInfo animationInfo = mItemAnimator.recordPreLayoutInformation(</span><br><span class="line">                        mState, viewHolder, flags, viewHolder.getUnmodifiedPayloads());</span><br><span class="line">                <span class="keyword">if</span> (wasHidden) &#123;</span><br><span class="line">                    recordAnimationInfoIfBouncedHiddenView(viewHolder, animationInfo);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mViewInfoStore.addToAppearedInPreLayoutHolders(viewHolder, animationInfo);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// we don&#x27;t process disappearing list because they may re-appear in post layout pass.</span></span><br><span class="line">        clearOldPositions();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clearOldPositions();</span><br><span class="line">    &#125;</span><br><span class="line">    onExitLayoutOrScroll();</span><br><span class="line">    resumeRequestLayout(<span class="keyword">false</span>);</span><br><span class="line">    mState.mLayoutStep = State.STEP_LAYOUT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其次是dispatchLayoutStep2()中：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    eatRequestLayout();</span><br><span class="line">    onEnterLayoutOrScroll();</span><br><span class="line">    mState.assertLayoutStep(State.STEP_LAYOUT | State.STEP_ANIMATIONS);</span><br><span class="line">    mAdapterHelper.consumeUpdatesInOnePass();</span><br><span class="line">    mState.mItemCount = mAdapter.getItemCount();</span><br><span class="line">    mState.mDeletedInvisibleItemCountSincePreviousLayout = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2: Run layout</span></span><br><span class="line">    mState.mInPreLayout = <span class="keyword">false</span>;</span><br><span class="line">    mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class="line"></span><br><span class="line">    mState.mStructureChanged = <span class="keyword">false</span>;</span><br><span class="line">    mPendingSavedState = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// onLayoutChildren may have caused client code to disable item animations; re-check</span></span><br><span class="line">    mState.mRunSimpleAnimations = mState.mRunSimpleAnimations &amp;&amp; mItemAnimator != <span class="keyword">null</span>;</span><br><span class="line">    mState.mLayoutStep = State.STEP_ANIMATIONS;</span><br><span class="line">    onExitLayoutOrScroll();</span><br><span class="line">    resumeRequestLayout(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="ItemDecoration"><a href="#ItemDecoration" class="headerlink" title="ItemDecoration"></a>ItemDecoration</h3><ul>
<li><p>onDraw(Canvas c, RecyclerView parent, RecyclerView.State state)<br>这个函数作用在于绘制分割线，在源码中被调用的地方在RecyclerView中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDraw(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = mItemDecorations.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        mItemDecorations.get(i).onDraw(c, <span class="keyword">this</span>, mState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是RecyclerView的onDraw()函数中进行了分割线的绘制</p>
</li>
<li><p>public void getItemOffsets(Rect outRect, View view, RecyclerView parent, State state)<br>这个函数是，在每一项itemView绘制的时候，通过控制outRect的left/top/right/bottom值，来确定itemView四周留出来的范围，效果类似于padding或margin<br>在源码中被调用的地方有：<br><img src="https://raw.githubusercontent.com/SysuCodeMan/PicBed/main/20210506174826.png"></p>
</li>
</ul>
<p>可以看到，主要是和measure有关的函数，很容易理解，因为就是在measure过程确定一个itemView占据多少空间</p>
<h3 id="ItemAnimator"><a href="#ItemAnimator" class="headerlink" title="ItemAnimator"></a>ItemAnimator</h3><p>ItemAnimator主要用于对item的插入、修改、删除动画处理主要有animateApprearance/animateDisappearance/animateChange/animatePersistence这几个在对应动作的函数</p>
<ul>
<li>public abstract boolean animateAppearance(@NonNull ViewHolder viewHolder, @Nullable ItemHolderInfo preLayoutInfo, @NonNull ItemHolderInfo postLayoutInfo);<br>在源码中查找animateAppearance的调用链为：<br><img src="https://raw.githubusercontent.com/SysuCodeMan/PicBed/main/20210506174844.png">最终又是在熟悉的dispatchLayoutStep3()中被调用<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Step 4: Process view info lists and trigger animations</span></span><br><span class="line">mViewInfoStore.process(mViewInfoProcessCallback);</span><br></pre></td></tr></table></figure>
但这一行并不是很能看出怎么就调用了animateAppearance，看下再上一步的调用：<br><img src="https://raw.githubusercontent.com/SysuCodeMan/PicBed/main/20210506174903.png"></li>
</ul>
<p>可以看到在调用process()函数的时候，是有根据record.flags来判断应该执行的是哪个处理</p>
<ul>
<li><p> public abstract boolean animateDisappearance(@NonNull ViewHolder viewHolder, @NonNull ItemHolderInfo preLayoutInfo, @Nullable ItemHolderInfo postLayoutInfo)<br>在源码中查找其调用位置：<br><img src="https://raw.githubusercontent.com/SysuCodeMan/PicBed/main/20210506174931.png">可以看到跟animateAppearance一样，最终都是被dispatchLayoutStep3()调用</p>
</li>
<li><p>public abstract boolean animateChange(@NonNull ViewHolder oldHolder,</p>
<pre><code>          @NonNull ViewHolder newHolder,
          @NonNull ItemHolderInfo preLayoutInfo, @NonNull ItemHolderInfo postLayoutInfo)
</code></pre>
<p>这个函数的调用链和上述一致，就不重复贴图了</p>
</li>
</ul>
<ul>
<li>public abstract boolean animatePersistence(@NonNull ViewHolder viewHolder,<pre><code>          @NonNull ItemHolderInfo preLayoutInfo, @NonNull ItemHolderInfo postLayoutInfo);
</code></pre>
这个函数的调用链依然和上述一致</li>
</ul>
]]></content>
      <tags>
        <tag>Android控件</tag>
      </tags>
  </entry>
  <entry>
    <title>Android RelativeLayout源码学习</title>
    <url>/2021/04/13/Android-RelativeLayout%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>RelativeLayout是Android中一种常用的布局，通过View之间的相互关系能够方便地确定子View的位置，通过源码的学习来看下Android是如何实现这一功能的。Android中的一个组件，工作原理主要在onMeasure(),onLayout(),onDraw()这3大阶段中。</p>
<p>###onMeasure()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mDirtyHierarchy) &#123;</span><br><span class="line">            mDirtyHierarchy = <span class="keyword">false</span>;</span><br><span class="line">            sortChildren();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测量过程的第一步是对子View进行排序</strong>，在这一步骤会设置一个标志位mDirtyHierarchy进行优化，下面看下sortChildren的具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sortChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> count = getChildCount();</span><br><span class="line">        <span class="keyword">if</span> (mSortedVerticalChildren == <span class="keyword">null</span> || mSortedVerticalChildren.length != count) &#123;</span><br><span class="line">            mSortedVerticalChildren = <span class="keyword">new</span> View[count];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mSortedHorizontalChildren == <span class="keyword">null</span> || mSortedHorizontalChildren.length != count) &#123;</span><br><span class="line">            mSortedHorizontalChildren = <span class="keyword">new</span> View[count];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> DependencyGraph graph = mGraph;</span><br><span class="line">        graph.clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            graph.add(getChildAt(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        graph.getSortedViews(mSortedVerticalChildren, RULES_VERTICAL);</span><br><span class="line">        graph.getSortedViews(mSortedHorizontalChildren, RULES_HORIZONTAL);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个函数包含以下步骤：</p>
<ul>
<li>初始化两个数组，分别用于记录水平方向和竖直方向的排序结果</li>
<li>初始化一个依赖图DependencyGraph，将子View都加入到依赖图中</li>
<li>调用DependencyGraph的getSortedViews方法，将两个方向的排序结果记录到对应数组中</li>
</ul>
<p>下面首先看下DependencyGraph的结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyGraph</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * List of all views in the graph.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> ArrayList&lt;Node&gt; mNodes = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * List of nodes in the graph. Each node is identified by its</span></span><br><span class="line"><span class="comment">         * view id (see View#getId()).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> SparseArray&lt;Node&gt; mKeyNodes = <span class="keyword">new</span> SparseArray&lt;Node&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Temporary data structure used to build the list of roots</span></span><br><span class="line"><span class="comment">         * for this graph.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> ArrayDeque&lt;Node&gt; mRoots = <span class="keyword">new</span> ArrayDeque&lt;Node&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果里每个成员代表的含义，其注释已经说清楚了；再具体看下Node的结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * The view representing this node in the layout.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            View view;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * The list of dependents for this node; a dependent is a node</span></span><br><span class="line"><span class="comment">             * that needs this node to be processed first.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">final</span> ArrayMap&lt;Node, DependencyGraph&gt; dependents =</span><br><span class="line">                    <span class="keyword">new</span> ArrayMap&lt;Node, DependencyGraph&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * The list of dependencies for this node.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">final</span> SparseArray&lt;Node&gt; dependencies = <span class="keyword">new</span> SparseArray&lt;Node&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据注释也能够明白每个成员的含义</p>
<p>接下来看下DependencyGraph是如何实现getSortedViews方法的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getSortedViews</span><span class="params">(View[] sorted, <span class="keyword">int</span>... rules)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 找出所有的不依赖其他节点的节点，即根节点</span></span><br><span class="line">            <span class="keyword">final</span> ArrayDeque&lt;Node&gt; roots = findRoots(rules);</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            Node node;</span><br><span class="line">            <span class="comment">// 循环从根节点的队尾中取出元素</span></span><br><span class="line">            <span class="keyword">while</span> ((node = roots.pollLast()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> View view = node.view;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> key = view.getId();</span><br><span class="line">                <span class="comment">// 将该节点加入排序结果</span></span><br><span class="line">                sorted[index++] = view;</span><br><span class="line">                <span class="comment">// 取出该节点的所有伴随节点</span></span><br><span class="line">                <span class="keyword">final</span> ArrayMap&lt;Node, DependencyGraph&gt; dependents = node.dependents;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> count = dependents.size();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                    <span class="comment">// 遍历伴随节点</span></span><br><span class="line">                    <span class="keyword">final</span> Node dependent = dependents.keyAt(i);</span><br><span class="line">                    <span class="comment">// 取出伴随节点的所有依赖节点集合</span></span><br><span class="line">                    <span class="keyword">final</span> SparseArray&lt;Node&gt; dependencies = dependent.dependencies;</span><br><span class="line">                    <span class="comment">// 将当前节点从伴随节点的依赖节点集合中去掉</span></span><br><span class="line">                    dependencies.remove(key);</span><br><span class="line">                    <span class="comment">// 如果该伴随节点去掉当前节点的依赖之后，没有再依赖其他节点，证明它是新的根节点，加入根节点集合</span></span><br><span class="line">                    <span class="keyword">if</span> (dependencies.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                        roots.add(dependent);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (index &lt; sorted.length) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Circular dependencies cannot exist&quot;</span></span><br><span class="line">                        + <span class="string">&quot; in RelativeLayout&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这个排序的过程已经在注释中说明，实现过程还是挺明确的。</p>
<p>再看完排序过程，我们回到onMeasure()方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// …… </span></span><br><span class="line">        <span class="keyword">int</span> myWidth = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> myHeight = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> width = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> heightSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Record our dimensions if they are known;</span></span><br><span class="line">        <span class="keyword">if</span> (widthMode != MeasureSpec.UNSPECIFIED) &#123;</span><br><span class="line">            myWidth = widthSize;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (heightMode != MeasureSpec.UNSPECIFIED) &#123;</span><br><span class="line">            myHeight = heightSize;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (widthMode == MeasureSpec.EXACTLY) &#123;</span><br><span class="line">            width = myWidth;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (heightMode == MeasureSpec.EXACTLY) &#123;</span><br><span class="line">            height = myHeight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        View ignore = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> gravity = mGravity &amp; Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> horizontalGravity = gravity != Gravity.START &amp;&amp; gravity != <span class="number">0</span>;</span><br><span class="line">        gravity = mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> verticalGravity = gravity != Gravity.TOP &amp;&amp; gravity != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> top = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> right = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> bottom = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> offsetHorizontalAxis = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> offsetVerticalAxis = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((horizontalGravity || verticalGravity) &amp;&amp; mIgnoreGravity != View.NO_ID) &#123;</span><br><span class="line">            ignore = findViewById(mIgnoreGravity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isWrapContentWidth = widthMode != MeasureSpec.EXACTLY;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isWrapContentHeight = heightMode != MeasureSpec.EXACTLY;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We need to know our size for doing the correct computation of children positioning in RTL</span></span><br><span class="line">        <span class="comment">// mode but there is no practical way to get it instead of running the code below.</span></span><br><span class="line">        <span class="comment">// So, instead of running the code twice, we just set the width to a &quot;default display width&quot;</span></span><br><span class="line">        <span class="comment">// before the computation and then, as a last pass, we will update their real position with</span></span><br><span class="line">        <span class="comment">// an offset equals to &quot;DEFAULT_WIDTH - width&quot;.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = getLayoutDirection();</span><br><span class="line">        <span class="keyword">if</span> (isLayoutRtl() &amp;&amp; myWidth == -<span class="number">1</span>) &#123;</span><br><span class="line">            myWidth = DEFAULT_WIDTH;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中间这段是一些辅助变量的初始化，就不多说了，继续往下看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// …… </span></span><br><span class="line">        View[] views = mSortedHorizontalChildren;</span><br><span class="line">        <span class="keyword">int</span> count = views.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            View child = views[i];</span><br><span class="line">            <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">                LayoutParams params = (LayoutParams) child.getLayoutParams();</span><br><span class="line">                <span class="keyword">int</span>[] rules = params.getRules(layoutDirection);</span><br><span class="line"></span><br><span class="line">                applyHorizontalSizeRules(params, myWidth, rules);</span><br><span class="line">                measureChildHorizontal(child, params, myWidth, myHeight);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (positionChildHorizontal(child, params, myWidth, isWrapContentWidth)) &#123;</span><br><span class="line">                    offsetHorizontalAxis = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测量过程的第二步是遍历子View进行水平方向的依赖测量</strong>，这一步通过3个函数进行，逐个看下函数的实现。</p>
<p>介绍函数实现之前先介绍一下rule的概念，在RelativeLayout.LayoutParams进行解析时，会将RelativeLayout中的子View的依赖关系通过rules数组存储起来，数组中的下标代表某条规则，例如LEFT_OF，对应的元素代表这条规则依赖的View id：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (attr) &#123;</span><br><span class="line">     <span class="keyword">case</span> com.android.internal.R.styleable.RelativeLayout_Layout_layout_toLeftOf:</span><br><span class="line">           rules[LEFT_OF] = a.getResourceId(attr, <span class="number">0</span>);</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">                    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>了解了rule的概念之后，看下遍历子View进行依赖测量时相关方法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applyHorizontalSizeRules</span><span class="params">(LayoutParams childParams, <span class="keyword">int</span> myWidth, <span class="keyword">int</span>[] rules)</span> </span>&#123;</span><br><span class="line">        RelativeLayout.LayoutParams anchorParams;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// VALUE_NOT_SET indicates a &quot;soft requirement&quot; in that direction. For example:</span></span><br><span class="line">        <span class="comment">// left=10, right=VALUE_NOT_SET means the view must start at 10, but can go as far as it</span></span><br><span class="line">        <span class="comment">// wants to the right</span></span><br><span class="line">        <span class="comment">// left=VALUE_NOT_SET, right=10 means the view must end at 10, but can go as far as it</span></span><br><span class="line">        <span class="comment">// wants to the left</span></span><br><span class="line">        <span class="comment">// left=10, right=20 means the left and right ends are both fixed</span></span><br><span class="line">        childParams.mLeft = VALUE_NOT_SET;</span><br><span class="line">        childParams.mRight = VALUE_NOT_SET;</span><br><span class="line"></span><br><span class="line">        anchorParams = getRelatedViewParams(rules, LEFT_OF);</span><br><span class="line">        <span class="keyword">if</span> (anchorParams != <span class="keyword">null</span>) &#123;</span><br><span class="line">            childParams.mRight = anchorParams.mLeft - (anchorParams.leftMargin +</span><br><span class="line">                    childParams.rightMargin);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childParams.alignWithParent &amp;&amp; rules[LEFT_OF] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (myWidth &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                childParams.mRight = myWidth - mPaddingRight - childParams.rightMargin;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        anchorParams = getRelatedViewParams(rules, RIGHT_OF);</span><br><span class="line">        <span class="keyword">if</span> (anchorParams != <span class="keyword">null</span>) &#123;</span><br><span class="line">            childParams.mLeft = anchorParams.mRight + (anchorParams.rightMargin +</span><br><span class="line">                    childParams.leftMargin);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childParams.alignWithParent &amp;&amp; rules[RIGHT_OF] != <span class="number">0</span>) &#123;</span><br><span class="line">            childParams.mLeft = mPaddingLeft + childParams.leftMargin;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        anchorParams = getRelatedViewParams(rules, ALIGN_LEFT);</span><br><span class="line">        <span class="keyword">if</span> (anchorParams != <span class="keyword">null</span>) &#123;</span><br><span class="line">            childParams.mLeft = anchorParams.mLeft + childParams.leftMargin;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childParams.alignWithParent &amp;&amp; rules[ALIGN_LEFT] != <span class="number">0</span>) &#123;</span><br><span class="line">            childParams.mLeft = mPaddingLeft + childParams.leftMargin;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        anchorParams = getRelatedViewParams(rules, ALIGN_RIGHT);</span><br><span class="line">        <span class="keyword">if</span> (anchorParams != <span class="keyword">null</span>) &#123;</span><br><span class="line">            childParams.mRight = anchorParams.mRight - childParams.rightMargin;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childParams.alignWithParent &amp;&amp; rules[ALIGN_RIGHT] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (myWidth &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                childParams.mRight = myWidth - mPaddingRight - childParams.rightMargin;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != rules[ALIGN_PARENT_LEFT]) &#123;</span><br><span class="line">            childParams.mLeft = mPaddingLeft + childParams.leftMargin;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != rules[ALIGN_PARENT_RIGHT]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (myWidth &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                childParams.mRight = myWidth - mPaddingRight - childParams.rightMargin;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>纵观整个函数，其实就是对水平方向的几条规则逐个进行处理，这几条规则分别是：LEFT_OF/RIGHT_OF/ALIGN_LEFT/ALIGN_RIGHT/ALIGN_PARENT_LEFT/ALIGN_PARENT_RIGHT；<br>对于每个属性的处理方法都是相似的：通过相应的规则从getRelativeViewParams中取到对应依赖的View，然后通过依赖的View的对应属性和padding来调整该View的对应属性<br>看看下getRelativeViewParams的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> LayoutParams <span class="title">getRelatedViewParams</span><span class="params">(<span class="keyword">int</span>[] rules, <span class="keyword">int</span> relation)</span> </span>&#123;</span><br><span class="line">        View v = getRelatedView(rules, relation);</span><br><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ViewGroup.LayoutParams params = v.getLayoutParams();</span><br><span class="line">            <span class="keyword">if</span> (params <span class="keyword">instanceof</span> LayoutParams) &#123;</span><br><span class="line">                <span class="keyword">return</span> (LayoutParams) v.getLayoutParams();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>真正的实现在getRelatedView中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> View <span class="title">getRelatedView</span><span class="params">(<span class="keyword">int</span>[] rules, <span class="keyword">int</span> relation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> id = rules[relation];</span><br><span class="line">        <span class="keyword">if</span> (id != <span class="number">0</span>) &#123;</span><br><span class="line">            DependencyGraph.Node node = mGraph.mKeyNodes.get(id);</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            View v = node.view;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Find the first non-GONE view up the chain</span></span><br><span class="line">            <span class="keyword">while</span> (v.getVisibility() == View.GONE) &#123;</span><br><span class="line">                rules = ((LayoutParams) v.getLayoutParams()).getRules(v.getLayoutDirection());</span><br><span class="line">                node = mGraph.mKeyNodes.get((rules[relation]));</span><br><span class="line">                <span class="comment">// ignore self dependency. for more info look in git commit: da3003</span></span><br><span class="line">                <span class="keyword">if</span> (node == <span class="keyword">null</span> || v == node.view) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                v = node.view;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>关键点：</p>
<ul>
<li>通过rules数组取到对应依赖的View id</li>
<li>通过View id从依赖图中取出对应的View</li>
<li>如果取到的View可见性为GONE，则继续通过对应的依赖规则取依赖的View所依赖的View(有点拗口…)</li>
</ul>
<p>经过applyHorizontalSizeRules方法的处理之后，子View的params中的left/right值都已经确定好，然后会进入measureChildHorizontal方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">measureChildHorizontal</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            View child, LayoutParams params, <span class="keyword">int</span> myWidth, <span class="keyword">int</span> myHeight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(params.mLeft, params.mRight,</span><br><span class="line">                params.width, params.leftMargin, params.rightMargin, mPaddingLeft, mPaddingRight,</span><br><span class="line">                myWidth);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec;</span><br><span class="line">        <span class="keyword">if</span> (myHeight &lt; <span class="number">0</span> &amp;&amp; !mAllowBrokenMeasureSpecs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (params.height &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                        params.height, MeasureSpec.EXACTLY);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Negative values in a mySize/myWidth/myWidth value in</span></span><br><span class="line">                <span class="comment">// RelativeLayout measurement is code for, &quot;we got an</span></span><br><span class="line">                <span class="comment">// unspecified mode in the RelativeLayout&#x27;s measure spec.&quot;</span></span><br><span class="line">                <span class="comment">// Carry it forward.</span></span><br><span class="line">                childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(<span class="number">0</span>, MeasureSpec.UNSPECIFIED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> maxHeight;</span><br><span class="line">            <span class="keyword">if</span> (mMeasureVerticalWithPaddingMargin) &#123;</span><br><span class="line">                maxHeight = Math.max(<span class="number">0</span>, myHeight - mPaddingTop - mPaddingBottom</span><br><span class="line">                        - params.topMargin - params.bottomMargin);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxHeight = Math.max(<span class="number">0</span>, myHeight);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> heightMode;</span><br><span class="line">            <span class="keyword">if</span> (params.height == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                heightMode = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                heightMode = MeasureSpec.AT_MOST;</span><br><span class="line">            &#125;</span><br><span class="line">            childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(maxHeight, heightMode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在上一阶段我们确定了子View的left/right参数，在这一阶段，可以通过left/right得到子View的宽度，然后进行第一次子View的measure方法调用，进行第一次测量</p>
<p>接下来调用positionChildHorizontal方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">positionChildHorizontal</span><span class="params">(View child, LayoutParams params, <span class="keyword">int</span> myWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> wrapContent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = getLayoutDirection();</span><br><span class="line">        <span class="keyword">int</span>[] rules = params.getRules(layoutDirection);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (params.mLeft == VALUE_NOT_SET &amp;&amp; params.mRight != VALUE_NOT_SET) &#123;</span><br><span class="line">            <span class="comment">// Right is fixed, but left varies</span></span><br><span class="line">            params.mLeft = params.mRight - child.getMeasuredWidth();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params.mLeft != VALUE_NOT_SET &amp;&amp; params.mRight == VALUE_NOT_SET) &#123;</span><br><span class="line">            <span class="comment">// Left is fixed, but right varies</span></span><br><span class="line">            params.mRight = params.mLeft + child.getMeasuredWidth();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params.mLeft == VALUE_NOT_SET &amp;&amp; params.mRight == VALUE_NOT_SET) &#123;</span><br><span class="line">            <span class="comment">// Both left and right vary</span></span><br><span class="line">            <span class="keyword">if</span> (rules[CENTER_IN_PARENT] != <span class="number">0</span> || rules[CENTER_HORIZONTAL] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!wrapContent) &#123;</span><br><span class="line">                    centerHorizontal(child, params, myWidth);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    positionAtEdge(child, params, myWidth);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// This is the default case. For RTL we start from the right and for LTR we start</span></span><br><span class="line">                <span class="comment">// from the left. This will give LEFT/TOP for LTR and RIGHT/TOP for RTL.</span></span><br><span class="line">                positionAtEdge(child, params, myWidth);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rules[ALIGN_PARENT_END] != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的代码不长，从实现中可以得知，该方法的作用在于，那些在前阶段没有设置的左右边界约束。</p>
<p><strong>接下来是第三步，遍历子View进行垂直方向的依赖测量</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ……</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = views[i];</span><br><span class="line">            <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">                <span class="keyword">final</span> LayoutParams params = (LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">                applyVerticalSizeRules(params, myHeight, child.getBaseline());</span><br><span class="line">                measureChild(child, params, myWidth, myHeight);</span><br><span class="line">                <span class="keyword">if</span> (positionChildVertical(child, params, myHeight, isWrapContentHeight)) &#123;</span><br><span class="line">                    offsetVerticalAxis = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isWrapContentWidth) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isLayoutRtl()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">                            width = Math.max(width, myWidth - params.mLeft);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            width = Math.max(width, myWidth - params.mLeft + params.leftMargin);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">                            width = Math.max(width, params.mRight);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            width = Math.max(width, params.mRight + params.rightMargin);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isWrapContentHeight) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">                        height = Math.max(height, params.mBottom);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        height = Math.max(height, params.mBottom + params.bottomMargin);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (child != ignore || verticalGravity) &#123;</span><br><span class="line">                    left = Math.min(left, params.mLeft - params.leftMargin);</span><br><span class="line">                    top = Math.min(top, params.mTop - params.topMargin);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (child != ignore || horizontalGravity) &#123;</span><br><span class="line">                    right = Math.max(right, params.mRight + params.rightMargin);</span><br><span class="line">                    bottom = Math.max(bottom, params.mBottom + params.bottomMargin);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>垂直方向的约束测量过程和水平方向是一个套路：</p>
<ul>
<li>遍历子View，根据垂直方向的规则进行top/bottom的约束</li>
<li>测量一次子View</li>
<li>补充边界约束</li>
<li>不同的是，在垂直方向的测量阶段，还会对RelativeLayout的最大宽度和最大高度进行计算</li>
</ul>
<p><strong>经过水平和垂直方向两轮对子View的分发测量，已经完成了子View的测量过程，接下来是根据是否wrapContent调整RelativeLayout自身的高度</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isWrapContentWidth) &#123;</span><br><span class="line">        <span class="comment">// Width already has left padding in it since it was calculated by looking at</span></span><br><span class="line">        <span class="comment">// the right of each child view</span></span><br><span class="line">        width += mPaddingRight;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mLayoutParams != <span class="keyword">null</span> &amp;&amp; mLayoutParams.width &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            width = Math.max(width, mLayoutParams.width);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        width = Math.max(width, getSuggestedMinimumWidth());</span><br><span class="line">        width = resolveSize(width, widthMeasureSpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (offsetHorizontalAxis) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> View child = views[i];</span><br><span class="line">                <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">                    <span class="keyword">final</span> LayoutParams params = (LayoutParams) child.getLayoutParams();</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span>[] rules = params.getRules(layoutDirection);</span><br><span class="line">                    <span class="keyword">if</span> (rules[CENTER_IN_PARENT] != <span class="number">0</span> || rules[CENTER_HORIZONTAL] != <span class="number">0</span>) &#123;</span><br><span class="line">                        centerHorizontal(child, params, width);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rules[ALIGN_PARENT_RIGHT] != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> childWidth = child.getMeasuredWidth();</span><br><span class="line">                        params.mLeft = width - mPaddingRight - childWidth;</span><br><span class="line">                        params.mRight = params.mLeft + childWidth;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isWrapContentHeight) &#123;</span><br><span class="line">        <span class="comment">// Height already has top padding in it since it was calculated by looking at</span></span><br><span class="line">        <span class="comment">// the bottom of each child view</span></span><br><span class="line">        height += mPaddingBottom;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mLayoutParams != <span class="keyword">null</span> &amp;&amp; mLayoutParams.height &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            height = Math.max(height, mLayoutParams.height);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        height = Math.max(height, getSuggestedMinimumHeight());</span><br><span class="line">        height = resolveSize(height, heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (offsetVerticalAxis) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> View child = views[i];</span><br><span class="line">                <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">                    <span class="keyword">final</span> LayoutParams params = (LayoutParams) child.getLayoutParams();</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span>[] rules = params.getRules(layoutDirection);</span><br><span class="line">                    <span class="keyword">if</span> (rules[CENTER_IN_PARENT] != <span class="number">0</span> || rules[CENTER_VERTICAL] != <span class="number">0</span>) &#123;</span><br><span class="line">                        centerVertical(child, params, height);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rules[ALIGN_PARENT_BOTTOM] != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</span><br><span class="line">                        params.mTop = height - mPaddingBottom - childHeight;</span><br><span class="line">                        params.mBottom = params.mTop + childHeight;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后再根据Gravity属性调整位置</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isWrapContentWidth) &#123;</span><br><span class="line">        <span class="comment">// Width already has left padding in it since it was calculated by looking at</span></span><br><span class="line">        <span class="comment">// the right of each child view</span></span><br><span class="line">        width += mPaddingRight;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mLayoutParams != <span class="keyword">null</span> &amp;&amp; mLayoutParams.width &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            width = Math.max(width, mLayoutParams.width);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        width = Math.max(width, getSuggestedMinimumWidth());</span><br><span class="line">        width = resolveSize(width, widthMeasureSpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (offsetHorizontalAxis) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> View child = views[i];</span><br><span class="line">                <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">                    <span class="keyword">final</span> LayoutParams params = (LayoutParams) child.getLayoutParams();</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span>[] rules = params.getRules(layoutDirection);</span><br><span class="line">                    <span class="keyword">if</span> (rules[CENTER_IN_PARENT] != <span class="number">0</span> || rules[CENTER_HORIZONTAL] != <span class="number">0</span>) &#123;</span><br><span class="line">                        centerHorizontal(child, params, width);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rules[ALIGN_PARENT_RIGHT] != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> childWidth = child.getMeasuredWidth();</span><br><span class="line">                        params.mLeft = width - mPaddingRight - childWidth;</span><br><span class="line">                        params.mRight = params.mLeft + childWidth;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isWrapContentHeight) &#123;</span><br><span class="line">        <span class="comment">// Height already has top padding in it since it was calculated by looking at</span></span><br><span class="line">        <span class="comment">// the bottom of each child view</span></span><br><span class="line">        height += mPaddingBottom;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mLayoutParams != <span class="keyword">null</span> &amp;&amp; mLayoutParams.height &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            height = Math.max(height, mLayoutParams.height);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        height = Math.max(height, getSuggestedMinimumHeight());</span><br><span class="line">        height = resolveSize(height, heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (offsetVerticalAxis) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> View child = views[i];</span><br><span class="line">                <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">                    <span class="keyword">final</span> LayoutParams params = (LayoutParams) child.getLayoutParams();</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span>[] rules = params.getRules(layoutDirection);</span><br><span class="line">                    <span class="keyword">if</span> (rules[CENTER_IN_PARENT] != <span class="number">0</span> || rules[CENTER_VERTICAL] != <span class="number">0</span>) &#123;</span><br><span class="line">                        centerVertical(child, params, height);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rules[ALIGN_PARENT_BOTTOM] != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</span><br><span class="line">                        params.mTop = height - mPaddingBottom - childHeight;</span><br><span class="line">                        params.mBottom = params.mTop + childHeight;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>最后就是设置自身的宽高，完成测量过程</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isLayoutRtl()) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> offsetWidth = myWidth - width;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">          <span class="keyword">final</span> View child = views[i];</span><br><span class="line">          <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">              <span class="keyword">final</span> LayoutParams params = (LayoutParams) child.getLayoutParams();</span><br><span class="line">              params.mLeft -= offsetWidth;</span><br><span class="line">              params.mRight -= offsetWidth;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setMeasuredDimension(width, height);</span><br></pre></td></tr></table></figure>
<p>上述就是onMeasure的过程。</p>
<h3 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  The layout has actually already been performed and the positions</span></span><br><span class="line">        <span class="comment">//  cached.  Apply the cached values to the children.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> count = getChildCount();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            View child = getChildAt(i);</span><br><span class="line">            <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">                RelativeLayout.LayoutParams st =</span><br><span class="line">                        (RelativeLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line">                child.layout(st.mLeft, st.mTop, st.mRight, st.mBottom);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>onLayout的过程很简单，遍历子View，因为子View在分发测量过程中已经确定了上下左右的边界约束，所以直接调用对应的约束值进行layout。</p>
<p>###onDraw<br>在RelativeLayout中，没有对onDraw进行重写。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>和大多数容器布局类似，RelativeLayout的核心在于测量阶段，需要遍历两次子View，原因是水平和垂直方向各需一次来确定相应方向的边界约束。</p>
]]></content>
      <tags>
        <tag>Android布局</tag>
      </tags>
  </entry>
  <entry>
    <title>View的绘制流程学习</title>
    <url>/2021/04/13/View%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>View</p>
<blockquote>
<p>This class represents the basic building block for user interface components. A View occupies a rectangular area on the screen and is responsible for drawing and event handling. View is the base class for /widgets/, which are used to create interactive UI components (buttons, text fields, etc.).</p>
</blockquote>
<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>首先是View这个类的继承层次：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">View</span> <span class="keyword">implements</span> <span class="title">Drawable</span>.<span class="title">Callback</span>, <span class="title">KeyEvent</span>.<span class="title">Callback</span>,<span class="title">AccessibilityEventSource</span></span></span><br></pre></td></tr></table></figure>
<p>可以看到是一个普通类，实现了3个接口。</p>
<p>View.java文件代码共有27000多行，乍一看很吓人，但其中注释也占了很大部分，仔细看来主要分成以下方面</p>
<ul>
<li><p>构造函数</p>
</li>
<li><p>绘制相关</p>
</li>
<li><p>各种getter/setter</p>
</li>
<li><p>事件处理相关</p>
</li>
</ul>
<p>这篇首先看看构造函数以及绘制相关的源码</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>View这个类的构造函数一共有四个，方法签名分别是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">View</span><span class="params">(Context context)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">View</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">View</span><span class="params">(Context context, <span class="meta">@Nullable</span>  AttributeSet attrs,  <span class="keyword">int</span> defStyleAttr)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">View</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs, <span class="keyword">int</span> defStyleAttr,  <span class="keyword">int</span> defStyleRes)</span></span></span><br></pre></td></tr></table></figure>

<p>其中第2第3个方法的实现都只是调用了第4个方法，而第4个方法又会首先调用第1个方法，因此先看下第1个方法，即单参数的构造方法实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">View</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">        mResources = context != <span class="keyword">null</span> ? context.getResources() : <span class="keyword">null</span>;</span><br><span class="line">        mViewFlags = SOUND_EFFECTS_ENABLED | HAPTIC_FEEDBACK_ENABLED | FOCUSABLE_AUTO;</span><br><span class="line">        <span class="comment">// Set some flags defaults</span></span><br><span class="line">        mPrivateFlags2 =</span><br><span class="line">                (LAYOUT_DIRECTION_DEFAULT &lt;&lt; PFLAG2_LAYOUT_DIRECTION_MASK_SHIFT) |</span><br><span class="line">                (TEXT_DIRECTION_DEFAULT &lt;&lt; PFLAG2_TEXT_DIRECTION_MASK_SHIFT) |</span><br><span class="line">                (PFLAG2_TEXT_DIRECTION_RESOLVED_DEFAULT) |</span><br><span class="line">                (TEXT_ALIGNMENT_DEFAULT &lt;&lt; PFLAG2_TEXT_ALIGNMENT_MASK_SHIFT) |</span><br><span class="line">                (PFLAG2_TEXT_ALIGNMENT_RESOLVED_DEFAULT) |</span><br><span class="line">                (IMPORTANT_FOR_ACCESSIBILITY_DEFAULT &lt;&lt; PFLAG2_IMPORTANT_FOR_ACCESSIBILITY_SHIFT);</span><br><span class="line">        mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop();</span><br><span class="line">        setOverScrollMode(OVER_SCROLL_IF_CONTENT_SCROLLS);</span><br><span class="line">        mUserPaddingStart = UNDEFINED_PADDING;</span><br><span class="line">        mUserPaddingEnd = UNDEFINED_PADDING;</span><br><span class="line">        mRenderNode = RenderNode.create(getClass().getName(), <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!sCompatibilityDone &amp;&amp; context != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> targetSdkVersion = context.getApplicationInfo().targetSdkVersion;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Older apps may need this compatibility hack for measurement.</span></span><br><span class="line">            sUseBrokenMakeMeasureSpec = targetSdkVersion &lt;= Build.VERSION_CODES.JELLY_BEAN_MR1;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Older apps expect onMeasure() to always be called on a layout pass, regardless</span></span><br><span class="line">            <span class="comment">// of whether a layout was requested on that View.</span></span><br><span class="line">            sIgnoreMeasureCache = targetSdkVersion &lt; Build.VERSION_CODES.KITKAT;</span><br><span class="line"></span><br><span class="line">            Canvas.sCompatibilityRestore = targetSdkVersion &lt; Build.VERSION_CODES.M;</span><br><span class="line">            Canvas.sCompatibilitySetBitmap = targetSdkVersion &lt; Build.VERSION_CODES.O;</span><br><span class="line">            Canvas.setCompatibilityVersion(targetSdkVersion);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// In M and newer, our widgets can pass a “hint” value in the size</span></span><br><span class="line">            <span class="comment">// for UNSPECIFIED MeasureSpecs. This lets child views of scrolling containers</span></span><br><span class="line">            <span class="comment">// know what the expected parent size is going to be, so e.g. list items can size</span></span><br><span class="line">            <span class="comment">// themselves at 1/3 the size of their container. It breaks older apps though,</span></span><br><span class="line">            <span class="comment">// specifically apps that use some popular open source libraries.</span></span><br><span class="line">            sUseZeroUnspecifiedMeasureSpec = targetSdkVersion &lt; Build.VERSION_CODES.M;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Old versions of the platform would give different results from</span></span><br><span class="line">            <span class="comment">// LinearLayout measurement passes using EXACTLY and non-EXACTLY</span></span><br><span class="line">            <span class="comment">// modes, so we always need to run an additional EXACTLY pass.</span></span><br><span class="line">            sAlwaysRemeasureExactly = targetSdkVersion &lt;= Build.VERSION_CODES.M;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Prior to N, layout params could change without requiring a</span></span><br><span class="line">            <span class="comment">// subsequent call to setLayoutParams() and they would usually</span></span><br><span class="line">            <span class="comment">// work. Partial layout breaks this assumption.</span></span><br><span class="line">            sLayoutParamsAlwaysChanged = targetSdkVersion &lt;= Build.VERSION_CODES.M;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Prior to N, TextureView would silently ignore calls to setBackground/setForeground.</span></span><br><span class="line">            <span class="comment">// On N+, we throw, but that breaks compatibility with apps that use these methods.</span></span><br><span class="line">            sTextureViewIgnoresDrawableSetters = targetSdkVersion &lt;= Build.VERSION_CODES.M;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Prior to N, we would drop margins in LayoutParam conversions. The fix triggers bugs</span></span><br><span class="line">            <span class="comment">// in apps so we target check it to avoid breaking existing apps.</span></span><br><span class="line">            sPreserveMarginParamsInLayoutParamConversion =</span><br><span class="line">                    targetSdkVersion &gt;= Build.VERSION_CODES.N;</span><br><span class="line"></span><br><span class="line">            sCascadedDragDrop = targetSdkVersion &lt; Build.VERSION_CODES.N;</span><br><span class="line"></span><br><span class="line">            sHasFocusableExcludeAutoFocusable = targetSdkVersion &lt; Build.VERSION_CODES.O;</span><br><span class="line"></span><br><span class="line">            sAutoFocusableOffUIThreadWontNotifyParents = targetSdkVersion &lt; Build.VERSION_CODES.O;</span><br><span class="line"></span><br><span class="line">            sUseDefaultFocusHighlight = context.getResources().getBoolean(</span><br><span class="line">                    com.android.internal.R.bool.config_useDefaultFocusHighlight);</span><br><span class="line"></span><br><span class="line">            sThrowOnInvalidFloatProperties = targetSdkVersion &gt;= Build.VERSION_CODES.P;</span><br><span class="line"></span><br><span class="line">            sCanFocusZeroSized = targetSdkVersion &lt; Build.VERSION_CODES.P;</span><br><span class="line"></span><br><span class="line">            sAlwaysAssignFocus = targetSdkVersion &lt; Build.VERSION_CODES.P;</span><br><span class="line"></span><br><span class="line">            sAcceptZeroSizeDragShadow = targetSdkVersion &lt; Build.VERSION_CODES.P;</span><br><span class="line"></span><br><span class="line">            sCompatibilityDone = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>概括来说，主要做了以下几件事：</p>
<ul>
<li><p>对View可访问的关键变量进行赋值：mContext和mResources等</p>
</li>
<li><p>根据系统版本对其成员变量进行赋值，这里的变量大多数都是boolean型</p>
</li>
</ul>
<p>然后是第4个4参数的构造函数实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">View</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> TypedArray a = context.obtainStyledAttributes(</span><br><span class="line">                attrs, com.android.internal.R.styleable.View, defStyleAttr, defStyleRes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mDebugViewAttributes) &#123;</span><br><span class="line">            saveAttributeData(attrs, a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Drawable background = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftPadding = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> topPadding = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> rightPadding = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> bottomPadding = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> startPadding = UNDEFINED_PADDING;</span><br><span class="line">        <span class="keyword">int</span> endPadding = UNDEFINED_PADDING;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> padding = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> paddingHorizontal = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> paddingVertical = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> viewFlagValues = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> viewFlagMasks = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> setScrollContainer = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> tx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> ty = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> tz = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> elevation = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> rotation = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> rotationX = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> rotationY = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> sx = <span class="number">1f</span>;</span><br><span class="line">        <span class="keyword">float</span> sy = <span class="number">1f</span>;</span><br><span class="line">        <span class="keyword">boolean</span> transformSet = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> scrollbarStyle = SCROLLBARS_INSIDE_OVERLAY;</span><br><span class="line">        <span class="keyword">int</span> overScrollMode = mOverScrollMode;</span><br><span class="line">        <span class="keyword">boolean</span> initializeScrollbars = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> initializeScrollIndicators = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> startPaddingDefined = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> endPaddingDefined = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> leftPaddingDefined = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> rightPaddingDefined = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> targetSdkVersion = context.getApplicationInfo().targetSdkVersion;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set default values.</span></span><br><span class="line">        viewFlagValues |= FOCUSABLE_AUTO;</span><br><span class="line">        viewFlagMasks |= FOCUSABLE_AUTO;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = a.getIndexCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> I = <span class="number">0</span>; I &lt; N; I++) &#123;</span><br><span class="line">            <span class="keyword">int</span> attr = a.getIndex(i);</span><br><span class="line">            <span class="keyword">switch</span> (attr) &#123;</span><br><span class="line">                <span class="keyword">case</span> com.android.internal.R.styleable.View_background:</span><br><span class="line">                    background = a.getDrawable(attr);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> com.android.internal.R.styleable.View_padding:</span><br><span class="line">                    padding = a.getDimensionPixelSize(attr, -<span class="number">1</span>);</span><br><span class="line">                    mUserPaddingLeftInitial = padding;</span><br><span class="line">                    mUserPaddingRightInitial = padding;</span><br><span class="line">                    leftPaddingDefined = <span class="keyword">true</span>;</span><br><span class="line">                    rightPaddingDefined = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> com.android.internal.R.styleable.View_paddingHorizontal:</span><br><span class="line">                    paddingHorizontal = a.getDimensionPixelSize(attr, -<span class="number">1</span>);</span><br><span class="line">                    mUserPaddingLeftInitial = paddingHorizontal;</span><br><span class="line">                    mUserPaddingRightInitial = paddingHorizontal;</span><br><span class="line">                    leftPaddingDefined = <span class="keyword">true</span>;</span><br><span class="line">                    rightPaddingDefined = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 此处省略约400行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setOverScrollMode(overScrollMode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Cache start/end user padding as we cannot fully resolve padding here (we don’t have yet</span></span><br><span class="line">        <span class="comment">// the resolved layout direction). Those cached values will be used later during padding</span></span><br><span class="line">        <span class="comment">// resolution.</span></span><br><span class="line">        mUserPaddingStart = startPadding;</span><br><span class="line">        mUserPaddingEnd = endPadding;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (background != <span class="keyword">null</span>) &#123;</span><br><span class="line">            setBackground(background);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// setBackground above will record that padding is currently provided by the background.</span></span><br><span class="line">        <span class="comment">// If we have padding specified via xml, record that here instead and use it.</span></span><br><span class="line">        mLeftPaddingDefined = leftPaddingDefined;</span><br><span class="line">        mRightPaddingDefined = rightPaddingDefined;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (padding &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            leftPadding = padding;</span><br><span class="line">            topPadding = padding;</span><br><span class="line">            rightPadding = padding;</span><br><span class="line">            bottomPadding = padding;</span><br><span class="line">            mUserPaddingLeftInitial = padding;</span><br><span class="line">            mUserPaddingRightInitial = padding;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (paddingHorizontal &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                leftPadding = paddingHorizontal;</span><br><span class="line">                rightPadding = paddingHorizontal;</span><br><span class="line">                mUserPaddingLeftInitial = paddingHorizontal;</span><br><span class="line">                mUserPaddingRightInitial = paddingHorizontal;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (paddingVertical &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                topPadding = paddingVertical;</span><br><span class="line">                bottomPadding = paddingVertical;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isRtlCompatibilityMode()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mLeftPaddingDefined &amp;&amp; startPaddingDefined) &#123;</span><br><span class="line">                leftPadding = startPadding;</span><br><span class="line">            &#125;</span><br><span class="line">            mUserPaddingLeftInitial = (leftPadding &gt;= <span class="number">0</span>) ? leftPadding : mUserPaddingLeftInitial;</span><br><span class="line">            <span class="keyword">if</span> (!mRightPaddingDefined &amp;&amp; endPaddingDefined) &#123;</span><br><span class="line">                rightPadding = endPadding;</span><br><span class="line">            &#125;</span><br><span class="line">            mUserPaddingRightInitial = (rightPadding &gt;= <span class="number">0</span>) ? rightPadding : mUserPaddingRightInitial;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> hasRelativePadding = startPaddingDefined || endPaddingDefined;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mLeftPaddingDefined &amp;&amp; !hasRelativePadding) &#123;</span><br><span class="line">                mUserPaddingLeftInitial = leftPadding;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mRightPaddingDefined &amp;&amp; !hasRelativePadding) &#123;</span><br><span class="line">                mUserPaddingRightInitial = rightPadding;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        internalSetPadding(</span><br><span class="line">                mUserPaddingLeftInitial,</span><br><span class="line">                topPadding &gt;= <span class="number">0</span> ? topPadding : mPaddingTop,</span><br><span class="line">                mUserPaddingRightInitial,</span><br><span class="line">                bottomPadding &gt;= <span class="number">0</span> ? bottomPadding : mPaddingBottom);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (viewFlagMasks != <span class="number">0</span>) &#123;</span><br><span class="line">            setFlags(viewFlagValues, viewFlagMasks);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (initializeScrollbars) &#123;</span><br><span class="line">            initializeScrollbarsInternal(a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (initializeScrollIndicators) &#123;</span><br><span class="line">            initializeScrollIndicatorsInternal();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        a.recycle();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Needs to be called after mViewFlags is set</span></span><br><span class="line">        <span class="keyword">if</span> (scrollbarStyle != SCROLLBARS_INSIDE_OVERLAY) &#123;</span><br><span class="line">            recomputePadding();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x != <span class="number">0</span> || y != <span class="number">0</span>) &#123;</span><br><span class="line">            scrollTo(x, y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (transformSet) &#123;</span><br><span class="line">            setTranslationX(tx);</span><br><span class="line">            setTranslationY(ty);</span><br><span class="line">            setTranslationZ(tz);</span><br><span class="line">            setElevation(elevation);</span><br><span class="line">            setRotation(rotation);</span><br><span class="line">            setRotationX(rotationX);</span><br><span class="line">            setRotationY(rotationY);</span><br><span class="line">            setScaleX(sx);</span><br><span class="line">            setScaleY(sy);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!setScrollContainer &amp;&amp; (viewFlagValues&amp;SCROLLBARS_VERTICAL) != <span class="number">0</span>) &#123;</span><br><span class="line">            setScrollContainer(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        computeOpaqueFlags();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>概括来说，主要做了两件事情：</p>
<ul>
<li><p>从xml中将属性分析出来，然后赋值到对应的变量中，函数的70%的代码都在做这件事情</p>
</li>
<li><p>对Padding、transform等属性进行赋值</p>
</li>
</ul>
<h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><p>一个View的绘制，需要经历3个阶段：</p>
<ul>
<li><p>需要知道这个View所占的区域有多大</p>
</li>
<li><p>需要知道这个View所处的位置是哪里</p>
</li>
<li><p>需要知道这个View外观长什么样</p>
</li>
</ul>
<p>以上3个阶段分别对应measure(),layout(),draw()函数</p>
<p><em>measure()</em><br>首先来看measure函数的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> optical = isLayoutModeOptical(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (optical != isLayoutModeOptical(mParent)) &#123;</span><br><span class="line">            Insets insets = getOpticalInsets();</span><br><span class="line">            <span class="keyword">int</span> oWidth  = insets.left + insets.right;</span><br><span class="line">            <span class="keyword">int</span> oHeight = insets.top  + insets.bottom;</span><br><span class="line">            widthMeasureSpec  = MeasureSpec.adjust(widthMeasureSpec,  optical ? -oWidth  : oWidth);</span><br><span class="line">            heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Suppress sign extension for the low bytes</span></span><br><span class="line">        <span class="keyword">long</span> key = (<span class="keyword">long</span>) widthMeasureSpec &lt;&lt; <span class="number">32</span> | (<span class="keyword">long</span>) heightMeasureSpec &amp; <span class="number">0xffffffffL</span>;</span><br><span class="line">        <span class="keyword">if</span> (mMeasureCache == <span class="keyword">null</span>) mMeasureCache = <span class="keyword">new</span> LongSparseLongArray(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> forceLayout = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Optimize layout by avoiding an extra EXACTLY pass when the view is</span></span><br><span class="line">        <span class="comment">// already measured as the correct size. In API 23 and below, this</span></span><br><span class="line">        <span class="comment">// extra pass is required to make LinearLayout re-distribute weight.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> specChanged = widthMeasureSpec != mOldWidthMeasureSpec</span><br><span class="line">                || heightMeasureSpec != mOldHeightMeasureSpec;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isSpecExactly = MeasureSpec.getMode(widthMeasureSpec) == MeasureSpec.EXACTLY</span><br><span class="line">                &amp;&amp; MeasureSpec.getMode(heightMeasureSpec) == MeasureSpec.EXACTLY;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> matchesSpecSize = getMeasuredWidth() == MeasureSpec.getSize(widthMeasureSpec)</span><br><span class="line">                &amp;&amp; getMeasuredHeight() == MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> needsLayout = specChanged</span><br><span class="line">                &amp;&amp; (sAlwaysRemeasureExactly || !isSpecExactly || !matchesSpecSize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (forceLayout || needsLayout) &#123;</span><br><span class="line">            <span class="comment">// first clears the measured dimension flag</span></span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET;</span><br><span class="line"></span><br><span class="line">            resolveRtlPropertiesIfNeeded();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> cacheIndex = forceLayout ? -<span class="number">1</span> : mMeasureCache.indexOfKey(key);</span><br><span class="line">            <span class="keyword">if</span> (cacheIndex &lt; <span class="number">0</span> || sIgnoreMeasureCache) &#123;</span><br><span class="line">                <span class="comment">// measure ourselves, this should set the measured dimension flag back</span></span><br><span class="line">                onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">                mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> value = mMeasureCache.valueAt(cacheIndex);</span><br><span class="line">                <span class="comment">// Casting a long to int drops the high 32 bits, no mask needed</span></span><br><span class="line">                setMeasuredDimensionRaw((<span class="keyword">int</span>) (value &gt;&gt; <span class="number">32</span>), (<span class="keyword">int</span>) value);</span><br><span class="line">                mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// flag not set, setMeasuredDimension() was not invoked, we raise</span></span><br><span class="line">            <span class="comment">// an exception to warn the developer</span></span><br><span class="line">            <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;View with id&quot;</span> + getId() + <span class="string">&quot;: &quot;</span></span><br><span class="line">                        + getClass().getName() + “#onMeasure() did not set the&quot;</span><br><span class="line">                       + <span class="string">&quot; measured dimension by calling&quot;</span></span><br><span class="line">                       + <span class="string">&quot; setMeasuredDimension()&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mOldWidthMeasureSpec = widthMeasureSpec;</span><br><span class="line">        mOldHeightMeasureSpec = heightMeasureSpec;</span><br><span class="line"></span><br><span class="line">        mMeasureCache.put(key, ((<span class="keyword">long</span>) mMeasuredWidth) &lt;&lt; <span class="number">32</span> |</span><br><span class="line">                (<span class="keyword">long</span>) mMeasuredHeight &amp; <span class="number">0xffffffffL</span>); <span class="comment">// suppress sign extension</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>阅读一个函数，从读懂函数签名开始：从measure()的函数签名中可以得到以下信息：</p>
<ul>
<li><p>final函数，函数被关键字final标记，意味着不可被子类重写，但仔细看函数体内，大量的代码都是与设置boolean标志位相关的，并没有进行measure，真正measure的地方在上述38行的onMeasure()方法中，这也是自定义View时进行测量操作的地方</p>
</li>
<li><p>入参widthMeasureSpec和heightMeasureSpec，一个View需要确定自己有多大，不能为所欲为，需要知道两点信息：/父容器对其大小的限制/和/父容器允许的大小，/入参的widthMeasureSpec和heightMeasureSpec分别从宽和高两个维度用1个变量给出了上述2点信息，下面具体看下是如何做到的</p>
</li>
</ul>
<p><em>MeasureSpec</em><br>在View的onMeasure()方法中，会调用getDefaultSize(int size, int measureSpec)方法来获得这个View默认的size，看下这个方法的源码即可了解MeasureSpec的原理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = size;</span><br><span class="line">        <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">        <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">            result = size;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">            result = specSize;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中关键的两行，第3行MeasureSpec.getMode()得到的就是父容器对其大小的限制，而MeasureSpec.getSize()得到的是父容器允许/建议的大小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMode</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (measureSpec &amp; MODE_MASK);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (measureSpec &amp; ~MODE_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getMode()和getSize()方法的实现非常简洁，这里的MODE_MASK取值为0X3&lt;&lt;30，即32位，高2位为11，余下为0，因为上面两个方法的含义分别是：getMode为取measureSpec的高2位，getSize为取measureSpec的低30位，通过这个方式，1个32位的变量即可存储模式和尺寸两个信息<br>在getDefaultSize()函数中也能看到，得到的specMode有3种取值：</p>
<ul>
<li><p>UNSPECIFIED：父容器对该View的大小没有限制</p>
</li>
<li><p>AL_MOST：最多不能超过给出的specSize</p>
</li>
<li><p>EXACTLTY：取值要为给出的specSize</p>
</li>
</ul>
<p>meMeasure的最终目标，是在onMeasure()方法中，将测量得到的宽高，赋值给View的宽高，用于后续使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setMeasuredDimensionRaw</span><span class="params">(<span class="keyword">int</span> measuredWidth, <span class="keyword">int</span> measuredHeight)</span> </span>&#123;</span><br><span class="line">        mMeasuredWidth = measuredWidth;</span><br><span class="line">        mMeasuredHeight = measuredHeight;</span><br><span class="line"></span><br><span class="line">        mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><em>layout()</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="number">0</span>) &#123;</span><br><span class="line">            onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</span><br><span class="line">            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> oldL = mLeft;</span><br><span class="line">        <span class="keyword">int</span> oldT = mTop;</span><br><span class="line">        <span class="keyword">int</span> oldB = mBottom;</span><br><span class="line">        <span class="keyword">int</span> oldR = mRight;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line">            onLayout(changed, l, t, r, b);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (shouldDrawRoundScrollbar()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(mRoundScrollbarRenderer == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mRoundScrollbarRenderer = <span class="keyword">new</span> RoundScrollbarRenderer(<span class="keyword">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mRoundScrollbarRenderer = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</span><br><span class="line"></span><br><span class="line">            ListenerInfo li = mListenerInfo;</span><br><span class="line">            <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</span><br><span class="line">                        (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</span><br><span class="line">                <span class="keyword">int</span> numListeners = listenersCopy.size();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i I <span class="number">0</span>; i I numListeners; ++i) &#123;</span><br><span class="line">                    listenersCopy.get(i).onLayoutChange(<span class="keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> wasLayoutValid = isLayoutValid();</span><br><span class="line"></span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</span><br><span class="line">        mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!wasLayoutValid &amp;&amp; isFocused()) &#123;</span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_WANTS_FOCUS;</span><br><span class="line">            <span class="keyword">if</span> (canTakeFocus()) &#123;</span><br><span class="line">                <span class="comment">// We have a robust focus, so parents should no longer be wanting focus.</span></span><br><span class="line">                clearParentsWantFocus();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getViewRootImpl() == <span class="keyword">null</span> || !getViewRootImpl().isInLayout()) &#123;</span><br><span class="line">                <span class="comment">// This is a weird case. Most-likely the user, rather than ViewRootImpl, called</span></span><br><span class="line">                <span class="comment">// layout. In this case, there&#x27;s’no guarantee that parent layouts will be evaluated</span></span><br><span class="line">                <span class="comment">// and thus the safest action is to clear focus here.</span></span><br><span class="line">                clearFocusInternal(<span class="keyword">null</span>, <span class="comment">/* propagate */</span> <span class="keyword">true</span>, <span class="comment">/* refocus */</span> <span class="keyword">false</span>);</span><br><span class="line">                clearParentsWantFocus();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasParentWantsFocus()) &#123;</span><br><span class="line">                <span class="comment">// original requestFocus was likely on this view directly, so just clear focus</span></span><br><span class="line">                clearFocusInternal(<span class="keyword">null</span>, <span class="comment">/* propagate */</span> <span class="keyword">true</span>, <span class="comment">/* refocus */</span> <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// otherwise, we let parents handle re-assigning focus during their layout passes.</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_WANTS_FOCUS) != <span class="number">0</span>) &#123;</span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_WANTS_FOCUS;</span><br><span class="line">            View focused = findFocus();</span><br><span class="line">            <span class="keyword">if</span> (focused != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Try to restore focus as close as possible to our starting focus.</span></span><br><span class="line">                <span class="keyword">if</span> (!restoreDefaultFocus() &amp;&amp; !hasParentWantsFocus()) &#123;</span><br><span class="line">                    <span class="comment">// Give up and clear focus once we’v’ reached the top-most parent which wants</span></span><br><span class="line">                    <span class="comment">// focus.</span></span><br><span class="line">                    focused.clearFocusInternal(<span class="keyword">null</span>, <span class="comment">/* propagate */</span> <span class="keyword">true</span>, <span class="comment">/* refocus */</span> <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_NOTIFY_AUTOFILL_ENTER_ON_LAYOUT) != <span class="number">0</span>) &#123;</span><br><span class="line">            mPrivateFlags3 &amp;= ~PFLAG3_NOTIFY_AUTOFILL_ENTER_ON_LAYOUT;</span><br><span class="line">            notifyEnterOrExitForAutoFillIfNeeded(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>layout()函数，作用是确定View的坐标，通过left/top/right/bottom四个值来确定，有2点值得记录的：</p>
<ul>
<li><p>进行layout()时，会检查是否已经进行了onMeasure()，确保layout()在onMeasure(0之后</p>
</li>
<li><p>和measure()与onMeasure()类似，真正进行layout操作的，在onLayout()方法里，也是自定义View确定布局的地方，在View.java里，onLayout()函数是一个空实现</p>
</li>
</ul>
<p><em>draw()</em><br>确定了View的大小和位置之后，就可以进行实际的绘制操作了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> privateFlags = mPrivateFlags;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;</span><br><span class="line">                (mAttachInfo == <span class="keyword">null</span> || !mAttachInfo.mIgnoreDirtyState);</span><br><span class="line">        mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 1, draw the background, if needed</span></span><br><span class="line">        <span class="keyword">int</span> saveCount;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!dirtyOpaque) &#123;</span><br><span class="line">            drawBackground(canvas);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// skip step 2 &amp; 5 if possible (common case)</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</span><br><span class="line">        <span class="keyword">boolean</span> horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</span><br><span class="line">            <span class="comment">// Step 3, draw the content</span></span><br><span class="line">            <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step 4, draw the children</span></span><br><span class="line">            dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">            drawAutofilledHighlight(canvas);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Overlay is part of the content and draws beneath Foreground</span></span><br><span class="line">            <span class="keyword">if</span> (mOverlay != <span class="keyword">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">                mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step 6, draw decorations (foreground, scrollbars)</span></span><br><span class="line">            onDrawForeground(canvas);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step 7, draw the default focus highlight</span></span><br><span class="line">            drawDefaultFocusHighlight(canvas);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (debugDraw()) &#123;</span><br><span class="line">                debugDrawFocus(canvas);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// we’re done…</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>draw()过程，源码的注释比较清晰，主要有7个步骤：</p>
<ul>
<li><p>绘制背景</p>
</li>
<li><p>如果有需要，保存图层信息，用于淡出准备</p>
</li>
<li><p>绘制内容，这一步最关键，也和measure()/layout()相似，这里会调用onDraw()来绘制真正的内容</p>
</li>
<li><p>绘制子view</p>
</li>
<li><p>如果有需要，绘制类似阴影效果</p>
</li>
<li><p>绘制View的装饰，如滚动条</p>
</li>
<li><p>绘制焦点效果</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Android Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>View触摸事件传递源码学习</title>
    <url>/2021/04/13/View%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="起点"><a href="#起点" class="headerlink" title="起点"></a>起点</h3><p>事件传递，属于我们人与机器交互的范畴，因此选择交互的载体——Activity作为起点。<br>在Activity中与触摸事件相关的方法是dispatchTouchEvent(MotionEvent ev)与onTouchEvent(MotionEvent ev)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            onUserInteraction();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>解析</p>
<ul>
<li>判断事件类型，如果是<em>按下</em>事件，调用onUserInteraction()方法，这个方法在Activity中是一个空实现，表明我们可以根据需要重写这个方法的实现</li>
<li>调用该Activity对应的Window的superDispatchTouchEvent(MotionEvent ev)方法处理事件，如果该方法返回了true，证明事件被消费</li>
<li>如果上述Window的方法返回了false，证明事件没有被消费，此时由Activity的onTouchEvent(MotionEvent ev)方法来消费；</li>
</ul>
<h3 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h3><p>调用Activity的dispatchTouchEvent(MotionEvent ev)方法之后，会调用到对应Window的superDispatchTouchEvent(MotionEvent ev)方法，根据Window类的注释说明，Window类唯一的实现类是PhoneWindow，因此直接到<em>PhoneWindow</em>中看其实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用的是其mDecor的同名方法，mDecor类型是DecorView，再到<em>DecorView</em>中看下它的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用的实际上是父类的dispatchTouchEvent(MotionEvent ev)实现，DecorView的父类是FrameLayout，但FrameLayout自身没有实现这个方法，因此调用的是FrameLayout的父类ViewGroup的方法，在ViewGroup中，dispatchTouchEvent(MotionEvent ev)方法是真正的处理事件的地方，在开始这部分源码阅读之前，先小结一下触摸事件是怎么传递到ViewGroup的：<br><strong>Activity –&gt; PhoneWindow –&gt; DecorView –&gt; ViewGroup</strong></p>
<h3 id="ViewGroup的dispatchTouchEvent-MotionEvent-ev-方法"><a href="#ViewGroup的dispatchTouchEvent-MotionEvent-ev-方法" class="headerlink" title="ViewGroup的dispatchTouchEvent(MotionEvent ev)方法"></a>ViewGroup的dispatchTouchEvent(MotionEvent ev)方法</h3><p>这个方法的实现比较长，主要分成以下阶段来分析：</p>
<h5 id="是否拦截"><a href="#是否拦截" class="headerlink" title="是否拦截"></a>是否拦截</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mInputEventConsistencyVerifier.onTouchEvent(ev, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123;</span><br><span class="line">            ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">                cancelAndClearTouchTargets(ev);</span><br><span class="line">                resetTouchState();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关键代码，判断是否拦截</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                    || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 判断子View是否不允许该父类拦截</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">                    intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                    ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    intercepted = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                intercepted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (intercepted || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，最关键的两点：</p>
<ul>
<li>判断disallowIntercept，即子类是否允许父类拦截</li>
<li>调用onInterceptTouchEvent(MotionEvent ev)，确定拦截判定为true或者false，可想而知，如果为true的话，该事件将不再向子类分发，在ViewGroup中，onInterceptTouchEvent(MotionEvent ev)是有默认实现的：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ev.isFromSource(InputDevice.SOURCE_MOUSE)</span><br><span class="line">                &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN</span><br><span class="line">                &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)</span><br><span class="line">                &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
在特定的4种场景下，事件会被拦截</li>
</ul>
<h5 id="向下分发"><a href="#向下分发" class="headerlink" title="向下分发"></a>向下分发</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">       ……</span><br><span class="line">            <span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">                View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()</span><br><span class="line">                        ? findChildWithAccessibilityFocus() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                        || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">                        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex(); <span class="comment">// always 0 for down</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> idBitsToAssign = split ? <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex)</span><br><span class="line">                            : TouchTarget.ALL_POINTER_IDS;</span><br><span class="line"></span><br><span class="line">               </span><br><span class="line">                    removePointersFromTouchTargets(idBitsToAssign);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">                    <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(actionIndex);</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(actionIndex);</span><br><span class="line">                      <span class="comment">// 关键代码1，构建子View遍历列表</span></span><br><span class="line">                        <span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = preorderedList == <span class="keyword">null</span></span><br><span class="line">                                &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line">                        <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                            <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(</span><br><span class="line">                                    childrenCount, i, customOrder);</span><br><span class="line">                            <span class="keyword">final</span> View child = getAndVerifyPreorderedView(</span><br><span class="line">                                    preorderedList, children, childIndex);</span><br><span class="line">                      </span><br><span class="line">                            <span class="keyword">if</span> (childWithAccessibilityFocus != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (childWithAccessibilityFocus != child) &#123;</span><br><span class="line">                                    <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                childWithAccessibilityFocus = <span class="keyword">null</span>;</span><br><span class="line">                                i = childrenCount - <span class="number">1</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 关键代码2，两个条件分别是是否可以接收触摸事件和触摸点坐标是否在View内</span></span><br><span class="line">                            <span class="comment">// 如果有其中1个条件不满足，就继续找下一个View；否则说明找到目标子View</span></span><br><span class="line">                            <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">                                    || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                                ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            newTouchTarget = getTouchTarget(child);</span><br><span class="line">                            <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            resetCancelNextUpFlag(child);</span><br><span class="line">                            <span class="comment">// 关键代码3，找到目标子View之后调用该方法进行处理</span></span><br><span class="line">                            <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                                mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                                <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                                        <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                                            mLastTouchDownIndex = j;</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    mLastTouchDownIndex = childIndex;</span><br><span class="line">                                &#125;</span><br><span class="line">                                mLastTouchDownX = ev.getX();</span><br><span class="line">                                mLastTouchDownY = ev.getY();</span><br><span class="line">                                 <span class="comment">// 关键代码4，处理了Action.Down事件的View加入到链表中</span></span><br><span class="line">                                newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                                alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) preorderedList.clear();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        newTouchTarget = mFirstTouchTarget;</span><br><span class="line">                        <span class="keyword">while</span> (newTouchTarget.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            newTouchTarget = newTouchTarget.next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 关键代码5，这时证明还没有子View处理事件，调用该方法来自己处理</span></span><br><span class="line">                handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">                        TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                TouchTarget predecessor = <span class="keyword">null</span>;</span><br><span class="line">                TouchTarget target = mFirstTouchTarget;</span><br><span class="line">                <span class="comment">// 关键代码6，不断从链表中取出子View对应的节点，进行Action.Down以外的事件分发</span></span><br><span class="line">                <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">                    <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">                        handled = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                                || intercepted;</span><br><span class="line">                        <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                                target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                            handled = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (cancelChild) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (predecessor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                mFirstTouchTarget = next;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                predecessor.next = next;</span><br><span class="line">                            &#125;</span><br><span class="line">                            target.recycle();</span><br><span class="line">                            target = next;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    predecessor = target;</span><br><span class="line">                    target = next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (canceled</span><br><span class="line">                    || actionMasked == MotionEvent.ACTION_UP</span><br><span class="line">                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">                resetTouchState();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex();</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> idBitsToRemove = <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex);</span><br><span class="line">                removePointersFromTouchTargets(idBitsToRemove);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!handled &amp;&amp; mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mInputEventConsistencyVerifier.onUnhandledEvent(ev, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这一段代码比较长，但抓住注释中的6处关键代码即可把握整体流程：</p>
<ul>
<li>构建子View的遍历列表</li>
<li>遍历子View，找到可以处理ACTION_DOWN的View</li>
<li>调用dispatchTransformedTouchEvent方法将事件分发到子View上进行处理</li>
<li>对所有处理了ACTION_DOWN方法的子View加入到一个链表中</li>
<li>如果没有子View处理过ACTION_DOWN方法，则调用dispatchTransformTouchEvent来分发给自身来处理</li>
<li>如果有子View处理过ACTION_DOWN方法，则不断从链表中取出子View，进行其余正常事件的分发</li>
</ul>
<h5 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h5><p>由上述代码可以得知，无论是找到了子View让其处理，还是没有子View处理而自身处理，都是通过调用dispatchTransformedTouchEvent方法进行的，来看下这个方法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></span><br><span class="line"><span class="function"><span class="params">            View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</span><br><span class="line">        <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">            event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">                handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handled = child.dispatchTouchEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line">            event.setAction(oldAction);</span><br><span class="line">            <span class="keyword">return</span> handled;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldPointerIdBits = event.getPointerIdBits();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newPointerIdBits == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">final</span> MotionEvent transformedEvent;</span><br><span class="line">        <span class="keyword">if</span> (newPointerIdBits == oldPointerIdBits) &#123;</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="keyword">null</span> || child.hasIdentityMatrix()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</span><br><span class="line">                    event.offsetLocation(offsetX, offsetY);</span><br><span class="line"></span><br><span class="line">                    handled = child.dispatchTouchEvent(event);</span><br><span class="line"></span><br><span class="line">                    event.offsetLocation(-offsetX, -offsetY);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> handled;</span><br><span class="line">            &#125;</span><br><span class="line">            transformedEvent = MotionEvent.obtain(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            transformedEvent = event.split(newPointerIdBits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            handled = <span class="keyword">super</span>.dispatchTouchEvent(transformedEvent);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</span><br><span class="line">            transformedEvent.offsetLocation(offsetX, offsetY);</span><br><span class="line">            <span class="keyword">if</span> (! child.hasIdentityMatrix()) &#123;</span><br><span class="line">                transformedEvent.transform(child.getInverseMatrix());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            handled = child.dispatchTouchEvent(transformedEvent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        transformedEvent.recycle();</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法乍一看内容比较多，但其实返回的handled值，归根到底就是一个if-else：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">    handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    handled = child.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此这段函数要么就是调用子View的dispatchTouchEvent()，要么就是调用父类的dispatchTouchEvent()，而无论是调用子View还是父类，最终都会调用到View类的这个方法实现；因此接下来看下View类中dispatchTouchEvent()的源码：</p>
<h5 id="View类的dispatchTouchEvent方法"><a href="#View类的dispatchTouchEvent方法" class="headerlink" title="View类的dispatchTouchEvent方法"></a>View类的dispatchTouchEvent方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (event.isTargetAccessibilityFocus()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isAccessibilityFocusedViewOrHost()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;        </span><br><span class="line">            event.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mInputEventConsistencyVerifier.onTouchEvent(event, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = event.getActionMasked();</span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">           </span><br><span class="line">            stopNestedScroll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</span><br><span class="line">                result = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">            ListenerInfo li = mListenerInfo;</span><br><span class="line">            <span class="comment">// 关键代码1，是否设置了onTouchListener，并且消费</span></span><br><span class="line">            <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">                    &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line">                result = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 关键代码2，调用自身的onTouchEvent()决定是否消费</span></span><br><span class="line">            <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">                result = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!result &amp;&amp; mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mInputEventConsistencyVerifier.onUnhandledEvent(event, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_UP ||</span><br><span class="line">                actionMasked == MotionEvent.ACTION_CANCEL ||</span><br><span class="line">                (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123;</span><br><span class="line">            stopNestedScroll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>View类的dispatchTouchEvent方法并不长，而且代码核心在于注释的2处：</p>
<ul>
<li>首先看该View是否设置了onTouchListener，调用其onTouch(MotionEvent ev)方法，如果onTouchListener的onTouch方法消费了该方法；则View自身的onTouchEvent(MotionEvent ev)方法将不被调用；</li>
<li>如果没有设置onTouchListener或者onTouchListener的onTouch(MotionEvent ev)方法没有消费事件，则调用View自身的onTouchEvent()方法</li>
</ul>
<h5 id="View的onTouchEvent方法"><a href="#View的onTouchEvent方法" class="headerlink" title="View的onTouchEvent方法"></a>View的onTouchEvent方法</h5><p>根据上述流程可以得到，如果触摸事件的整个传递过程中，没有被拦截也没有被onTouchListener消费的话，最终将走到View的onTouchEvent(MotionEvent ev)方法中执行，接下来看下View的onTouchEvent方法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> x = event.getX();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> y = event.getY();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> action = event.getAction();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE</span><br><span class="line">                || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</span><br><span class="line">                || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</span><br><span class="line">                setPressed(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class="line">            <span class="keyword">return</span> clickable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关键代码1，是否设置了TouchDelegate并且onTouchEvent()方法消费了该事件</span></span><br><span class="line">        <span class="keyword">if</span> (mTouchDelegate != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mTouchDelegate.onTouchEvent(event)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关键代码2，该View是否可以被点击</span></span><br><span class="line">        <span class="keyword">if</span> (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">                <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                    mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class="line">                    <span class="keyword">if</span> ((viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class="line">                        handleTooltipUp();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!clickable) &#123;</span><br><span class="line">                        removeTapCallback();</span><br><span class="line">                        removeLongPressCallback();</span><br><span class="line">                        mInContextButtonPress = <span class="keyword">false</span>;</span><br><span class="line">                        mHasPerformedLongPress = <span class="keyword">false</span>;</span><br><span class="line">                        mIgnoreNextUpEvent = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">boolean</span> prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span> || prepressed) &#123;</span><br><span class="line">                        <span class="keyword">boolean</span> focusTaken = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">if</span> (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</span><br><span class="line">                            focusTaken = requestFocus();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (prepressed) &#123;</span><br><span class="line">                            setPressed(<span class="keyword">true</span>, x, y);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</span><br><span class="line">                            removeLongPressCallback();</span><br><span class="line">                            <span class="keyword">if</span> (!focusTaken) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    mPerformClick = <span class="keyword">new</span> PerformClick();</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (!post(mPerformClick)) &#123;</span><br><span class="line">                                    <span class="comment">// 关键代码3，进行单击操作</span></span><br><span class="line">                                    performClickInternal();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (mUnsetPressedState == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            mUnsetPressedState = <span class="keyword">new</span> UnsetPressedState();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (prepressed) &#123;</span><br><span class="line">                            postDelayed(mUnsetPressedState,</span><br><span class="line">                                    ViewConfiguration.getPressedStateDuration());</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!post(mUnsetPressedState)) &#123;</span><br><span class="line">                            mUnsetPressedState.run();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        removeTapCallback();</span><br><span class="line">                    &#125;</span><br><span class="line">                    mIgnoreNextUpEvent = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                    <span class="keyword">if</span> (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) &#123;</span><br><span class="line">                        mPrivateFlags3 |= PFLAG3_FINGER_DOWN;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mHasPerformedLongPress = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!clickable) &#123;</span><br><span class="line">                        checkForLongClick(<span class="number">0</span>, x, y);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (performButtonActionOnTouchDown(event)) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">boolean</span> isInScrollingContainer = isInScrollingContainer();</span><br><span class="line">                    <span class="keyword">if</span> (isInScrollingContainer) &#123;</span><br><span class="line">                        mPrivateFlags |= PFLAG_PREPRESSED;</span><br><span class="line">                        <span class="keyword">if</span> (mPendingCheckForTap == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            mPendingCheckForTap = <span class="keyword">new</span> CheckForTap();</span><br><span class="line">                        &#125;</span><br><span class="line">                        mPendingCheckForTap.x = event.getX();</span><br><span class="line">                        mPendingCheckForTap.y = event.getY();</span><br><span class="line">                        postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        setPressed(<span class="keyword">true</span>, x, y);</span><br><span class="line">                        <span class="comment">// 关键代码4，进行长按检测</span></span><br><span class="line">                        checkForLongClick(<span class="number">0</span>, x, y);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">                    <span class="keyword">if</span> (clickable) &#123;</span><br><span class="line">                        setPressed(<span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    removeTapCallback();</span><br><span class="line">                    removeLongPressCallback();</span><br><span class="line">                    mInContextButtonPress = <span class="keyword">false</span>;</span><br><span class="line">                    mHasPerformedLongPress = <span class="keyword">false</span>;</span><br><span class="line">                    mIgnoreNextUpEvent = <span class="keyword">false</span>;</span><br><span class="line">                    mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                    <span class="keyword">if</span> (clickable) &#123;</span><br><span class="line">                        drawableHotspotChanged(x, y);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!pointInView(x, y, mTouchSlop)) &#123;</span><br><span class="line">                        removeTapCallback();</span><br><span class="line">                        removeLongPressCallback();</span><br><span class="line">                        <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</span><br><span class="line">                            setPressed(<span class="keyword">false</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>View的onTouchEvent()方法也并不长，主要是分成DOWN/UP/MOVE/CANCEL这4种case进行处理，其中的几处关键代码分别是：</p>
<ul>
<li>关键代码1会判断是否设置了onTouchDelegate，如果设置了，将优先被delegate处理</li>
<li>如果没有delegate或者delegate没有处理，将判断view是否可点击，可点击将走进这个if代码块，注意到这个if代码块最终是return true的</li>
<li>关键代码3，在ACTION_UP中进行单击操作performClickInternal()</li>
<li>关键代码4，在ACTION_DOWN中进行长按检测，如果检测到是长按，则进行长按回调</li>
</ul>
<h5 id="单击和长按的处理函数"><a href="#单击和长按的处理函数" class="headerlink" title="单击和长按的处理函数"></a>单击和长按的处理函数</h5><p>在View中，处理单击和长按的函数分别是perfromClick()和performLongClickInternal()，最后分别看下这两个函数的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        notifyAutofillManagerOnClick();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> result;</span><br><span class="line">        <span class="keyword">final</span> ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnClickListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            playSoundEffect(SoundEffectConstants.CLICK);</span><br><span class="line">            <span class="comment">// 关键代码，调用监听器的onClick</span></span><br><span class="line">            li.mOnClickListener.onClick(<span class="keyword">this</span>);</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</span><br><span class="line"></span><br><span class="line">        notifyEnterOrExitForAutoFillIfNeeded(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">performLongClickInternal</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span> </span>&#123;</span><br><span class="line">        sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_LONG_CLICKED);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLongClickListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 关键代码，调用监听器的onLongClick</span></span><br><span class="line">            handled = li.mOnLongClickListener.onLongClick(View.<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!handled) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> isAnchored = !Float.isNaN(x) &amp;&amp; !Float.isNaN(y);</span><br><span class="line">            handled = isAnchored ? showContextMenu(x, y) : showContextMenu();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((mViewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!handled) &#123;</span><br><span class="line">                handled = showLongClickTooltip((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (handled) &#123;</span><br><span class="line">            performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，对单击和长按的最终处理，是通过调用相应Listener的对应方法来进行的。</p>
]]></content>
      <tags>
        <tag>Android Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Android TextView源码浅析之Layout</title>
    <url>/2021/04/16/Android-TextView%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90%E4%B9%8BLayout/</url>
    <content><![CDATA[<h3 id="OverView"><a href="#OverView" class="headerlink" title="OverView"></a>OverView</h3><p>在上一篇从顶层整体流程分析TextView时能看到Layout这个重要概念，无论是onMeasure()过程还是onDraw()过程，主要工作都是由Layout来完成。<br>Layout类负责的作用是，完成TextView的排版，包括折行、省略等等。</p>
<h3 id="TextView-makeNewLayout"><a href="#TextView-makeNewLayout" class="headerlink" title="TextView.makeNewLayout()"></a>TextView.makeNewLayout()</h3><p>在上一篇的分析中，在onMeasure()过程，会调用到TextView的makeNewLayout()方法，现在来看下它的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeNewLayout</span><span class="params">(<span class="keyword">int</span> wantWidth, <span class="keyword">int</span> hintWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">                             BoringLayout.Metrics boring,</span></span></span><br><span class="line"><span class="function"><span class="params">                             BoringLayout.Metrics hintBoring,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> ellipsisWidth, <span class="keyword">boolean</span> bringIntoView)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 暂停走马灯动画</span></span><br><span class="line">    stopMarquee();</span><br><span class="line"></span><br><span class="line">    mOldMaximum = mMaximum;</span><br><span class="line">    mOldMaxMode = mMaxMode;</span><br><span class="line"></span><br><span class="line">    mHighlightPathBogus = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wantWidth &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        wantWidth = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hintWidth &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        hintWidth = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 1.获取对齐方式</span></span><br><span class="line">    Layout.Alignment alignment = getLayoutAlignment();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> testDirChange = mSingleLine &amp;&amp; mLayout != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; (alignment == Layout.Alignment.ALIGN_NORMAL</span><br><span class="line">                    || alignment == Layout.Alignment.ALIGN_OPPOSITE);</span><br><span class="line">    <span class="keyword">int</span> oldDir = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (testDirChange) oldDir = mLayout.getParagraphDirection(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">boolean</span> shouldEllipsize = mEllipsize != <span class="keyword">null</span> &amp;&amp; getKeyListener() == <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 2.处理省略方式</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> switchEllipsize = mEllipsize == TruncateAt.MARQUEE</span><br><span class="line">            &amp;&amp; mMarqueeFadeMode != MARQUEE_FADE_NORMAL;</span><br><span class="line">    TruncateAt effectiveEllipsize = mEllipsize;</span><br><span class="line">    <span class="keyword">if</span> (mEllipsize == TruncateAt.MARQUEE</span><br><span class="line">            &amp;&amp; mMarqueeFadeMode == MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) &#123;</span><br><span class="line">        effectiveEllipsize = TruncateAt.END_SMALL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.获取文字方向</span></span><br><span class="line">    <span class="keyword">if</span> (mTextDir == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mTextDir = getTextDirectionHeuristic();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.通过上述信息，构建mLayout</span></span><br><span class="line">    mLayout = makeSingleLayout(wantWidth, boring, ellipsisWidth, alignment, shouldEllipsize,</span><br><span class="line">            effectiveEllipsize, effectiveEllipsize == mEllipsize);</span><br><span class="line">    <span class="keyword">if</span> (switchEllipsize) &#123;</span><br><span class="line">        TruncateAt oppositeEllipsize = effectiveEllipsize == TruncateAt.MARQUEE</span><br><span class="line">                ? TruncateAt.END : TruncateAt.MARQUEE;</span><br><span class="line">        mSavedMarqueeModeLayout = makeSingleLayout(wantWidth, boring, ellipsisWidth, alignment,</span><br><span class="line">                shouldEllipsize, oppositeEllipsize, effectiveEllipsize != mEllipsize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shouldEllipsize = mEllipsize != <span class="keyword">null</span>;</span><br><span class="line">    mHintLayout = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 5.构建出用于显示hint的Layout</span></span><br><span class="line">    <span class="keyword">if</span> (mHint != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shouldEllipsize) hintWidth = wantWidth;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hintBoring == UNKNOWN_BORING) &#123;</span><br><span class="line">            hintBoring = BoringLayout.isBoring(mHint, mTextPaint, mTextDir,</span><br><span class="line">                                               mHintBoring);</span><br><span class="line">            <span class="keyword">if</span> (hintBoring != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mHintBoring = hintBoring;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hintBoring != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hintBoring.width &lt;= hintWidth</span><br><span class="line">                    &amp;&amp; (!shouldEllipsize || hintBoring.width &lt;= ellipsisWidth)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mSavedHintLayout != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mHintLayout = mSavedHintLayout.replaceOrMake(mHint, mTextPaint,</span><br><span class="line">                            hintWidth, alignment, mSpacingMult, mSpacingAdd,</span><br><span class="line">                            hintBoring, mIncludePad);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mHintLayout = BoringLayout.make(mHint, mTextPaint,</span><br><span class="line">                            hintWidth, alignment, mSpacingMult, mSpacingAdd,</span><br><span class="line">                            hintBoring, mIncludePad);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mSavedHintLayout = (BoringLayout) mHintLayout;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shouldEllipsize &amp;&amp; hintBoring.width &lt;= hintWidth) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mSavedHintLayout != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mHintLayout = mSavedHintLayout.replaceOrMake(mHint, mTextPaint,</span><br><span class="line">                            hintWidth, alignment, mSpacingMult, mSpacingAdd,</span><br><span class="line">                            hintBoring, mIncludePad, mEllipsize,</span><br><span class="line">                            ellipsisWidth);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mHintLayout = BoringLayout.make(mHint, mTextPaint,</span><br><span class="line">                            hintWidth, alignment, mSpacingMult, mSpacingAdd,</span><br><span class="line">                            hintBoring, mIncludePad, mEllipsize,</span><br><span class="line">                            ellipsisWidth);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mHintLayout == <span class="keyword">null</span>) &#123;</span><br><span class="line">            StaticLayout.Builder builder = StaticLayout.Builder.obtain(mHint, <span class="number">0</span>,</span><br><span class="line">                    mHint.length(), mTextPaint, hintWidth)</span><br><span class="line">                    .setAlignment(alignment)</span><br><span class="line">                    .setTextDirection(mTextDir)</span><br><span class="line">                    .setLineSpacing(mSpacingAdd, mSpacingMult)</span><br><span class="line">                    .setIncludePad(mIncludePad)</span><br><span class="line">                    .setUseLineSpacingFromFallbacks(mUseFallbackLineSpacing)</span><br><span class="line">                    .setBreakStrategy(mBreakStrategy)</span><br><span class="line">                    .setHyphenationFrequency(mHyphenationFrequency)</span><br><span class="line">                    .setJustificationMode(mJustificationMode)</span><br><span class="line">                    .setMaxLines(mMaxMode == LINES ? mMaximum : Integer.MAX_VALUE);</span><br><span class="line">            <span class="keyword">if</span> (shouldEllipsize) &#123;</span><br><span class="line">                builder.setEllipsize(mEllipsize)</span><br><span class="line">                        .setEllipsizedWidth(ellipsisWidth);</span><br><span class="line">            &#125;</span><br><span class="line">            mHintLayout = builder.build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bringIntoView || (testDirChange &amp;&amp; oldDir != mLayout.getParagraphDirection(<span class="number">0</span>))) &#123;</span><br><span class="line">        registerForPreDraw();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.重启走马灯动画</span></span><br><span class="line">    <span class="keyword">if</span> (mEllipsize == TextUtils.TruncateAt.MARQUEE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!compressText(ellipsisWidth)) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> height = mLayoutParams.height;</span><br><span class="line">            <span class="keyword">if</span> (height != LayoutParams.WRAP_CONTENT &amp;&amp; height != LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                startMarquee();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mRestartMarquee = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CursorControllers need a non-null mLayout</span></span><br><span class="line">    <span class="keyword">if</span> (mEditor != <span class="keyword">null</span>) mEditor.prepareCursorControllers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个函数中，最重要的是第4点的通过调用makeSingleLayout()方法构建出主Layout，但第5点构建hint的Layout也很值得学习，因为涉及了BoringLayout和StaticLayout这两个重要的概念：<br>BoringLayout和StaticLayout都是Layout的子类，其中BoringLayout是指不包含Span而且文本都是左到右而且能够一行展示下的文本，这种情况下使用BoringLayout能够节省不必要的计算；当hint不满足BoringLayout的条件时，会使用StaticLayout来进行布局</p>
<h3 id="TextView-makeSingleLayout-方法"><a href="#TextView-makeSingleLayout-方法" class="headerlink" title="TextView.makeSingleLayout()方法"></a>TextView.makeSingleLayout()方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Layout <span class="title">makeSingleLayout</span><span class="params">(<span class="keyword">int</span> wantWidth, BoringLayout.Metrics boring, <span class="keyword">int</span> ellipsisWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">        Layout.Alignment alignment, <span class="keyword">boolean</span> shouldEllipsize, TruncateAt effectiveEllipsize,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> useSaved)</span> </span>&#123;</span><br><span class="line">    Layout result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 这个方法的内部会判断文本是否是Spannable，是的话会使用DynamicLayout</span></span><br><span class="line">    <span class="keyword">if</span> (useDynamicLayout()) &#123;</span><br><span class="line">        <span class="keyword">final</span> DynamicLayout.Builder builder = DynamicLayout.Builder.obtain(mText, mTextPaint,</span><br><span class="line">                wantWidth)</span><br><span class="line">                .setDisplayText(mTransformed)</span><br><span class="line">                .setAlignment(alignment)</span><br><span class="line">                .setTextDirection(mTextDir)</span><br><span class="line">                .setLineSpacing(mSpacingAdd, mSpacingMult)</span><br><span class="line">                .setIncludePad(mIncludePad)</span><br><span class="line">                .setUseLineSpacingFromFallbacks(mUseFallbackLineSpacing)</span><br><span class="line">                .setBreakStrategy(mBreakStrategy)</span><br><span class="line">                .setHyphenationFrequency(mHyphenationFrequency)</span><br><span class="line">                .setJustificationMode(mJustificationMode)</span><br><span class="line">                .setEllipsize(getKeyListener() == <span class="keyword">null</span> ? effectiveEllipsize : <span class="keyword">null</span>)</span><br><span class="line">                .setEllipsizedWidth(ellipsisWidth);</span><br><span class="line">        result = builder.build();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否确定了是不是Boring</span></span><br><span class="line">        <span class="keyword">if</span> (boring == UNKNOWN_BORING) &#123;</span><br><span class="line">            boring = BoringLayout.isBoring(mTransformed, mTextPaint, mTextDir, mBoring);</span><br><span class="line">            <span class="keyword">if</span> (boring != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mBoring = boring;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这个条件如果成立，则证明是Boring</span></span><br><span class="line">        <span class="keyword">if</span> (boring != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 根据boring的不同属性，创建对应的Layout，if-else分支里都会尝试从mSavedLayout中创建，拿不到再调用BoringLayout.make()来创建新的</span></span><br><span class="line">            <span class="keyword">if</span> (boring.width &lt;= wantWidth</span><br><span class="line">                    &amp;&amp; (effectiveEllipsize == <span class="keyword">null</span> || boring.width &lt;= ellipsisWidth)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (useSaved &amp;&amp; mSavedLayout != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    result = mSavedLayout.replaceOrMake(mTransformed, mTextPaint,</span><br><span class="line">                            wantWidth, alignment, mSpacingMult, mSpacingAdd,</span><br><span class="line">                            boring, mIncludePad);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result = BoringLayout.make(mTransformed, mTextPaint,</span><br><span class="line">                            wantWidth, alignment, mSpacingMult, mSpacingAdd,</span><br><span class="line">                            boring, mIncludePad);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (useSaved) &#123;</span><br><span class="line">                    mSavedLayout = (BoringLayout) result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shouldEllipsize &amp;&amp; boring.width &lt;= wantWidth) &#123;</span><br><span class="line">                <span class="keyword">if</span> (useSaved &amp;&amp; mSavedLayout != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    result = mSavedLayout.replaceOrMake(mTransformed, mTextPaint,</span><br><span class="line">                            wantWidth, alignment, mSpacingMult, mSpacingAdd,</span><br><span class="line">                            boring, mIncludePad, effectiveEllipsize,</span><br><span class="line">                            ellipsisWidth);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result = BoringLayout.make(mTransformed, mTextPaint,</span><br><span class="line">                            wantWidth, alignment, mSpacingMult, mSpacingAdd,</span><br><span class="line">                            boring, mIncludePad, effectiveEllipsize,</span><br><span class="line">                            ellipsisWidth);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在这里result依然为null，证明不是Boring，需要用StaticLayout</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        StaticLayout.Builder builder = StaticLayout.Builder.obtain(mTransformed,</span><br><span class="line">                <span class="number">0</span>, mTransformed.length(), mTextPaint, wantWidth)</span><br><span class="line">                .setAlignment(alignment)</span><br><span class="line">                .setTextDirection(mTextDir)</span><br><span class="line">                .setLineSpacing(mSpacingAdd, mSpacingMult)</span><br><span class="line">                .setIncludePad(mIncludePad)</span><br><span class="line">                .setUseLineSpacingFromFallbacks(mUseFallbackLineSpacing)</span><br><span class="line">                .setBreakStrategy(mBreakStrategy)</span><br><span class="line">                .setHyphenationFrequency(mHyphenationFrequency)</span><br><span class="line">                .setJustificationMode(mJustificationMode)</span><br><span class="line">                .setMaxLines(mMaxMode == LINES ? mMaximum : Integer.MAX_VALUE);</span><br><span class="line">        <span class="keyword">if</span> (shouldEllipsize) &#123;</span><br><span class="line">            builder.setEllipsize(effectiveEllipsize)</span><br><span class="line">                    .setEllipsizedWidth(ellipsisWidth);</span><br><span class="line">        &#125;</span><br><span class="line">        result = builder.build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="StaticLayout-generate"><a href="#StaticLayout-generate" class="headerlink" title="StaticLayout.generate()"></a>StaticLayout.generate()</h3><p>在调用StaticLayout.Builder.build()方法之后，最终会调用到StaticLayout的generate()方法来构建出真正对应的Layout，generate()方法很长，还是采取分部分的方式来看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> CharSequence source = b.mText;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> bufStart = b.mStart;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> bufEnd = b.mEnd;</span><br><span class="line">    TextPaint paint = b.mPaint;</span><br><span class="line">    <span class="keyword">int</span> outerWidth = b.mWidth;</span><br><span class="line">    TextDirectionHeuristic textDir = b.mTextDir;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> fallbackLineSpacing = b.mFallbackLineSpacing;</span><br><span class="line">    <span class="keyword">float</span> spacingmult = b.mSpacingMult;</span><br><span class="line">    <span class="keyword">float</span> spacingadd = b.mSpacingAdd;</span><br><span class="line">    <span class="keyword">float</span> ellipsizedWidth = b.mEllipsizedWidth;</span><br><span class="line">    TextUtils.TruncateAt ellipsize = b.mEllipsize;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> addLastLineSpacing = b.mAddLastLineLineSpacing;</span><br><span class="line">    LineBreaks lineBreaks = <span class="keyword">new</span> LineBreaks(); </span><br><span class="line">    FloatArray widths = <span class="keyword">new</span> FloatArray();</span><br><span class="line"></span><br><span class="line">    mLineCount = <span class="number">0</span>;</span><br><span class="line">    mEllipsized = <span class="keyword">false</span>;</span><br><span class="line">    mMaxLineHeight = mMaximumVisibleLineCount &lt; <span class="number">1</span> ? <span class="number">0</span> : DEFAULT_MAX_LINE_HEIGHT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> v = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> needMultiply = (spacingmult != <span class="number">1</span> || spacingadd != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Paint.FontMetricsInt fm = b.mFontMetricsInt;</span><br><span class="line">    <span class="keyword">int</span>[] chooseHtv = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>第1部分是变量的初始化<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span>[] indents;</span><br><span class="line">    <span class="keyword">if</span> (mLeftIndents != <span class="keyword">null</span> || mRightIndents != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> leftLen = mLeftIndents == <span class="keyword">null</span> ? <span class="number">0</span> : mLeftIndents.length;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> rightLen = mRightIndents == <span class="keyword">null</span> ? <span class="number">0</span> : mRightIndents.length;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> indentsLen = Math.max(leftLen, rightLen);</span><br><span class="line">        indents = <span class="keyword">new</span> <span class="keyword">int</span>[indentsLen];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; leftLen; i++) &#123;</span><br><span class="line">            indents[i] = mLeftIndents[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rightLen; i++) &#123;</span><br><span class="line">            indents[i] += mRightIndents[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        indents = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> nativePtr = nInit(</span><br><span class="line">            b.mBreakStrategy, b.mHyphenationFrequency,</span><br><span class="line">            b.mJustificationMode != Layout.JUSTIFICATION_MODE_NONE,</span><br><span class="line">            indents, mLeftPaddings, mRightPaddings);</span><br></pre></td></tr></table></figure></li>
<li>第2部分是对文本缩进的处理，最终处理调用的是native函数实现，但实际这个if代码块，暂时还没有找到能够判断为true的地方<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrecomputedText.ParagraphInfo[] paragraphInfo = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">final</span> Spanned spanned = (source <span class="keyword">instanceof</span> Spanned) ? (Spanned) source : <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (source <span class="keyword">instanceof</span> PrecomputedText) &#123;</span><br><span class="line">    PrecomputedText precomputed = (PrecomputedText) source;</span><br><span class="line">    <span class="keyword">if</span> (precomputed.canUseMeasuredResult(bufStart, bufEnd, textDir, paint,</span><br><span class="line">              b.mBreakStrategy, b.mHyphenationFrequency)) &#123;</span><br><span class="line">        paragraphInfo = precomputed.getParagraphInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (paragraphInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> PrecomputedText.Params param = <span class="keyword">new</span> PrecomputedText.Params(paint, textDir,</span><br><span class="line">            b.mBreakStrategy, b.mHyphenationFrequency);</span><br><span class="line">    paragraphInfo = PrecomputedText.createMeasuredParagraphs(source, param, bufStart,</span><br><span class="line">            bufEnd, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第3部分是分析文本的段落信息，这里涉及到的PrecomputedText是包含了文本测量信息的类，通过它来构建文本能够节省一些开销</li>
</ul>
<p>接下来的部分，是根据段落信息，逐段地分析段落里的文本内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> paraIndex = <span class="number">0</span>; paraIndex &lt; paragraphInfo.length; paraIndex++) &#123;</span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">int</span> paraStart = paraIndex == <span class="number">0</span></span><br><span class="line">                 ? bufStart : paragraphInfo[paraIndex - <span class="number">1</span>].paragraphEnd;</span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">int</span> paraEnd = paragraphInfo[paraIndex].paragraphEnd;</span><br><span class="line"> <span class="comment">// ……</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>下面这几段的代码都发生在这个大的for循环中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> firstWidthLineCount = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> firstWidth = outerWidth;</span><br><span class="line"><span class="keyword">int</span> restWidth = outerWidth;</span><br><span class="line"></span><br><span class="line">LineHeightSpan[] chooseHt = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (spanned != <span class="keyword">null</span>) &#123;</span><br><span class="line">    LeadingMarginSpan[] sp = getParagraphSpans(spanned, paraStart, paraEnd,</span><br><span class="line">            LeadingMarginSpan.class);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sp.length; i++) &#123;</span><br><span class="line">        LeadingMarginSpan lms = sp[i];</span><br><span class="line">        firstWidth -= sp[i].getLeadingMargin(<span class="keyword">true</span>);</span><br><span class="line">        restWidth -= sp[i].getLeadingMargin(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// LeadingMarginSpan2 is odd.  The count affects all</span></span><br><span class="line">        <span class="comment">// leading margin spans, not just this particular one</span></span><br><span class="line">        <span class="keyword">if</span> (lms <span class="keyword">instanceof</span> LeadingMarginSpan2) &#123;</span><br><span class="line">            LeadingMarginSpan2 lms2 = (LeadingMarginSpan2) lms;</span><br><span class="line">            firstWidthLineCount = Math.max(firstWidthLineCount,</span><br><span class="line">                    lms2.getLeadingMarginLineCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>首先是宽度方面的分析，解析LeadingMarginSpan和LeadingMargin2<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    chooseHt = getParagraphSpans(spanned, paraStart, paraEnd, LineHeightSpan.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (chooseHt.length == <span class="number">0</span>) &#123;</span><br><span class="line">        chooseHt = <span class="keyword">null</span>; <span class="comment">// So that out() would not assume it has any contents</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (chooseHtv == <span class="keyword">null</span> || chooseHtv.length &lt; chooseHt.length) &#123;</span><br><span class="line">            chooseHtv = ArrayUtils.newUnpaddedIntArray(chooseHt.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chooseHt.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> o = spanned.getSpanStart(chooseHt[i]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (o &lt; paraStart) &#123;</span><br><span class="line">                <span class="comment">// starts in this layout, before the</span></span><br><span class="line">                <span class="comment">// current paragraph</span></span><br><span class="line"></span><br><span class="line">                chooseHtv[i] = getLineTop(getLineForOffset(o));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// starts in this paragraph</span></span><br><span class="line"></span><br><span class="line">                chooseHtv[i] = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>然后是行高的分析，通过解析LineHeightSpan来实现<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] variableTabStops = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (spanned != <span class="keyword">null</span>) &#123;</span><br><span class="line">    TabStopSpan[] spans = getParagraphSpans(spanned, paraStart,</span><br><span class="line">            paraEnd, TabStopSpan.<span class="keyword">class</span>);</span><br><span class="line">    <span class="keyword">if</span> (spans.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] stops = <span class="keyword">new</span> <span class="keyword">int</span>[spans.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; spans.length; i++) &#123;</span><br><span class="line">            stops[i] = spans[i].getTabStop();</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.<span class="keyword">sort</span>(stops, <span class="number">0</span>, stops.length);</span><br><span class="line">        variableTabStops = stops;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>这一段通过解析TabStopSpan来获取tabStop，排序后存储在variableTabStop中<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">final MeasuredParagraph measuredPara = paragraphInfo<span class="literal">[<span class="identifier">paraIndex</span>]</span>.measured;</span><br><span class="line">final <span class="built_in">char</span><span class="literal">[]</span> chs = measuredPara.get<span class="constructor">Chars()</span>;</span><br><span class="line">final <span class="built_in">int</span><span class="literal">[]</span> spanEndCache = measuredPara.get<span class="constructor">SpanEndCache()</span>.get<span class="constructor">RawArray()</span>;</span><br><span class="line">final <span class="built_in">int</span><span class="literal">[]</span> fmCache = measuredPara.get<span class="constructor">FontMetrics()</span>.get<span class="constructor">RawArray()</span>;</span><br><span class="line">widths.resize(chs.length);</span><br></pre></td></tr></table></figure></li>
<li>这部分作用是从段落信息paragraphInfo[paraIndex]中取出测量相关的信息，后面准备使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> breakCount = nComputeLineBreaks(</span><br><span class="line">         nativePtr,</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Inputs</span></span><br><span class="line">         chs,</span><br><span class="line">         measuredPara.getNativePtr(),</span><br><span class="line">         paraEnd - paraStart,</span><br><span class="line">         firstWidth,</span><br><span class="line">         firstWidthLineCount,</span><br><span class="line">         restWidth,</span><br><span class="line">         variableTabStops,</span><br><span class="line">         TAB_INCREMENT,</span><br><span class="line">         mLineCount,</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Outputs</span></span><br><span class="line">         lineBreaks,</span><br><span class="line">         lineBreaks.breaks.length,</span><br><span class="line">         lineBreaks.breaks,</span><br><span class="line">         lineBreaks.widths,</span><br><span class="line">         lineBreaks.ascents,</span><br><span class="line">         lineBreaks.descents,</span><br><span class="line">         lineBreaks.flags,</span><br><span class="line">         widths.getRawArray());</span><br><span class="line"></span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">int</span>[] breaks = lineBreaks.breaks;</span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">float</span>[] lineWidths = lineBreaks.widths;</span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">float</span>[] ascents = lineBreaks.ascents;</span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">float</span>[] descents = lineBreaks.descents;</span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">int</span>[] flags = lineBreaks.flags;</span><br></pre></td></tr></table></figure>
<ul>
<li>这一段是根据前述步骤的宽度、行宽等信息，调用native的方法进行了折行处理，处理后的结果在lineBreaks中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> remainingLineCount = mMaximumVisibleLineCount - mLineCount;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> ellipsisMayBeApplied = ellipsize != <span class="keyword">null</span></span><br><span class="line">        &amp;&amp; (ellipsize == TextUtils.TruncateAt.END</span><br><span class="line">            || (mMaximumVisibleLineCount == <span class="number">1</span></span><br><span class="line">                    &amp;&amp; ellipsize != TextUtils.TruncateAt.MARQUEE));</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> &lt; remainingLineCount &amp;&amp; remainingLineCount &lt; breakCount</span><br><span class="line">        &amp;&amp; ellipsisMayBeApplied) &#123;</span><br><span class="line">    <span class="comment">// Calculate width and flag.</span></span><br><span class="line">    <span class="keyword">float</span> width = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>; <span class="comment">// XXX May need to also have starting hyphen edit</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = remainingLineCount - <span class="number">1</span>; i &lt; breakCount; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == breakCount - <span class="number">1</span>) &#123;</span><br><span class="line">            width += lineWidths[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = (i == <span class="number">0</span> ? <span class="number">0</span> : breaks[i - <span class="number">1</span>]); j &lt; breaks[i]; j++) &#123;</span><br><span class="line">                width += widths.get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        flag |= flags[i] &amp; TAB_MASK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Treat the last line and overflowed lines as a single line.</span></span><br><span class="line">    breaks[remainingLineCount - <span class="number">1</span>] = breaks[breakCount - <span class="number">1</span>];</span><br><span class="line">    lineWidths[remainingLineCount - <span class="number">1</span>] = width;</span><br><span class="line">    flags[remainingLineCount - <span class="number">1</span>] = flag;</span><br><span class="line"></span><br><span class="line">    breakCount = remainingLineCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这里主要是对末行以及省略的相应处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> here = paraStart;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fmTop = <span class="number">0</span>, fmBottom = <span class="number">0</span>, fmAscent = <span class="number">0</span>, fmDescent = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> fmCacheIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> spanEndCacheIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> breakIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> spanStart = paraStart, spanEnd; spanStart &lt; paraEnd; spanStart = spanEnd) &#123;</span><br><span class="line">        <span class="comment">// retrieve end of span</span></span><br><span class="line">        spanEnd = spanEndCache[spanEndCacheIndex++];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// retrieve cached metrics, order matches above</span></span><br><span class="line">        fm.top = fmCache[fmCacheIndex * <span class="number">4</span> + <span class="number">0</span>];</span><br><span class="line">        fm.bottom = fmCache[fmCacheIndex * <span class="number">4</span> + <span class="number">1</span>];</span><br><span class="line">        fm.ascent = fmCache[fmCacheIndex * <span class="number">4</span> + <span class="number">2</span>];</span><br><span class="line">        fm.descent = fmCache[fmCacheIndex * <span class="number">4</span> + <span class="number">3</span>];</span><br><span class="line">        fmCacheIndex++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fm.top &lt; fmTop) &#123;</span><br><span class="line">            fmTop = fm.top;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fm.ascent &lt; fmAscent) &#123;</span><br><span class="line">            fmAscent = fm.ascent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fm.descent &gt; fmDescent) &#123;</span><br><span class="line">            fmDescent = fm.descent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fm.bottom &gt; fmBottom) &#123;</span><br><span class="line">            fmBottom = fm.bottom;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// skip breaks ending before current span range</span></span><br><span class="line">        <span class="keyword">while</span> (breakIndex &lt; breakCount &amp;&amp; paraStart + breaks[breakIndex] &lt; spanStart) &#123;</span><br><span class="line">            breakIndex++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (breakIndex &lt; breakCount &amp;&amp; paraStart + breaks[breakIndex] &lt;= spanEnd) &#123;</span><br><span class="line">            <span class="keyword">int</span> endPos = paraStart + breaks[breakIndex];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> moreChars = (endPos &lt; bufEnd);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> ascent = fallbackLineSpacing</span><br><span class="line">                    ? Math.min(fmAscent, Math.round(ascents[breakIndex]))</span><br><span class="line">                    : fmAscent;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> descent = fallbackLineSpacing</span><br><span class="line">                    ? Math.max(fmDescent, Math.round(descents[breakIndex]))</span><br><span class="line">                    : fmDescent;</span><br><span class="line">            v = out(source, here, endPos,</span><br><span class="line">                    ascent, descent, fmTop, fmBottom,</span><br><span class="line">                    v, spacingmult, spacingadd, chooseHt, chooseHtv, fm,</span><br><span class="line">                    flags[breakIndex], needMultiply, measuredPara, bufEnd,</span><br><span class="line">                    includepad, trackpad, addLastLineSpacing, chs, widths.getRawArray(),</span><br><span class="line">                    paraStart, ellipsize, ellipsizedWidth, lineWidths[breakIndex],</span><br><span class="line">                    paint, moreChars);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (endPos &lt; spanEnd) &#123;</span><br><span class="line">                <span class="comment">// preserve metrics for current span</span></span><br><span class="line">                fmTop = fm.top;</span><br><span class="line">                fmBottom = fm.bottom;</span><br><span class="line">                fmAscent = fm.ascent;</span><br><span class="line">                fmDescent = fm.descent;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fmTop = fmBottom = fmAscent = fmDescent = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            here = endPos;</span><br><span class="line">            breakIndex++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mLineCount &gt;= mMaximumVisibleLineCount &amp;&amp; mEllipsized) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (paraEnd == bufEnd) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这一段是对段落中的Span和这行进行处理，其中fmCache是前面PrecomputeText在测量时已经测算好的各个Span在top/bottom/ascent/descent这几个维度上的值，并缓存在fmCache中，因此在这里需要计算某个段落的字体属性时，直接从fmCache中取出即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((bufEnd == bufStart || source.charAt(bufEnd - <span class="number">1</span>) == CHAR_NEW_LINE)</span><br><span class="line">                    &amp;&amp; mLineCount &lt; mMaximumVisibleLineCount) &#123;</span><br><span class="line">                <span class="keyword">final</span> MeasuredParagraph measuredPara =</span><br><span class="line">                        MeasuredParagraph.buildForBidi(source, bufEnd, bufEnd, textDir, <span class="keyword">null</span>);</span><br><span class="line">                paint.getFontMetricsInt(fm);</span><br><span class="line">                v = out(source,</span><br><span class="line">                        bufEnd, bufEnd, fm.ascent, fm.descent,</span><br><span class="line">                        fm.top, fm.bottom,</span><br><span class="line">                        v,</span><br><span class="line">                        spacingmult, spacingadd, <span class="keyword">null</span>,</span><br><span class="line">                        <span class="keyword">null</span>, fm, <span class="number">0</span>,</span><br><span class="line">                        needMultiply, measuredPara, bufEnd,</span><br><span class="line">                        includepad, trackpad, addLastLineSpacing, <span class="keyword">null</span>,</span><br><span class="line">                        <span class="keyword">null</span>, bufStart, ellipsize,</span><br><span class="line">                        ellipsizedWidth, <span class="number">0</span>, paint, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意最后这一段的成立条件：结束为止和起始位置相等，并且前一个字符是换行符，那证明是一个新的空白段落，也需要作为一个单独的段落进行单独处理</li>
</ul>
<h3 id="StaticLayout-out"><a href="#StaticLayout-out" class="headerlink" title="StaticLayout.out()"></a>StaticLayout.out()</h3><p>上面已经看完了整体的StaticLayout.generate()函数，其中看到有对out()函数的调用，out()函数完整的签名如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">out</span><span class="params">(<span class="keyword">final</span> CharSequence text, <span class="keyword">final</span> <span class="keyword">int</span> start, <span class="keyword">final</span> <span class="keyword">int</span> end, <span class="keyword">int</span> above, <span class="keyword">int</span> below,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> top, <span class="keyword">int</span> bottom, <span class="keyword">int</span> v, <span class="keyword">final</span> <span class="keyword">float</span> spacingmult, <span class="keyword">final</span> <span class="keyword">float</span> spacingadd,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> LineHeightSpan[] chooseHt, <span class="keyword">final</span> <span class="keyword">int</span>[] chooseHtv, <span class="keyword">final</span> Paint.FontMetricsInt fm,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> <span class="keyword">int</span> flags, <span class="keyword">final</span> <span class="keyword">boolean</span> needMultiply, <span class="meta">@NonNull</span> <span class="keyword">final</span> MeasuredParagraph measured,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> <span class="keyword">int</span> bufEnd, <span class="keyword">final</span> <span class="keyword">boolean</span> includePad, <span class="keyword">final</span> <span class="keyword">boolean</span> trackPad,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> <span class="keyword">boolean</span> addLastLineLineSpacing, <span class="keyword">final</span> <span class="keyword">char</span>[] chs, <span class="keyword">final</span> <span class="keyword">float</span>[] widths,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> <span class="keyword">int</span> widthStart, <span class="keyword">final</span> TextUtils.TruncateAt ellipsize, <span class="keyword">final</span> <span class="keyword">float</span> ellipsisWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> <span class="keyword">float</span> textWidth, <span class="keyword">final</span> TextPaint paint, <span class="keyword">final</span> <span class="keyword">boolean</span> moreChars)</span></span></span><br></pre></td></tr></table></figure>
<p>参数非常多，但看参数名基本能看出和此前的generate()函数基本是对应的<br>接下来分段看下它做了什么</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> j = mLineCount;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> off = j * mColumns;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> want = off + mColumns + TOP;</span><br><span class="line"><span class="keyword">int</span>[] lines = mLines;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> dir = measured.getParagraphDir();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (want &gt;= lines.length) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span>[] grow = ArrayUtils.newUnpaddedIntArray(GrowingArrayUtils.growSize(want));</span><br><span class="line">    System.arraycopy(lines, <span class="number">0</span>, grow, <span class="number">0</span>, lines.length);</span><br><span class="line">    mLines = grow;</span><br><span class="line">    lines = grow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (j &gt;= mLineDirections.length) &#123;</span><br><span class="line">    <span class="keyword">final</span> Directions[] grow = ArrayUtils.newUnpaddedArray(Directions.class,</span><br><span class="line">            GrowingArrayUtils.growSize(j));</span><br><span class="line">    System.arraycopy(mLineDirections, <span class="number">0</span>, grow, <span class="number">0</span>, mLineDirections.length);</span><br><span class="line">    mLineDirections = grow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第1部分是判断mLines/mLineDirections数组是否需要扩容以及在需要时进行扩容操作，mLines数组中存储的是每行的信息，包括每一行的信息包括START/TOP/DESCENT/HYPHEN/ELLIPSIS_START/ELLIPSIS_COUNT</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (chooseHt != <span class="keyword">null</span>) &#123;</span><br><span class="line">    fm.ascent = above;</span><br><span class="line">    fm.descent = below;</span><br><span class="line">    fm.top = top;</span><br><span class="line">    fm.bottom = bottom;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chooseHt.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chooseHt[i] <span class="keyword">instanceof</span> LineHeightSpan.WithDensity) &#123;</span><br><span class="line">            ((LineHeightSpan.WithDensity) chooseHt[i])</span><br><span class="line">                    .chooseHeight(text, start, end, chooseHtv[i], v, fm, paint);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            chooseHt[i].chooseHeight(text, start, end, chooseHtv[i], v, fm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    above = fm.ascent;</span><br><span class="line">    below = fm.descent;</span><br><span class="line">    top = fm.top;</span><br><span class="line">    bottom = fm.bottom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第2部分是对高度进行处理，得到的结果存储在above/below/top/bottom变量中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ellipsize != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// If there is only one line, then do any type of ellipsis except when it is MARQUEE</span></span><br><span class="line">    <span class="comment">// if there are multiple lines, just allow END ellipsis on the last line</span></span><br><span class="line">    <span class="keyword">boolean</span> forceEllipsis = moreChars &amp;&amp; (mLineCount + <span class="number">1</span> == mMaximumVisibleLineCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> doEllipsis =</span><br><span class="line">            (((mMaximumVisibleLineCount == <span class="number">1</span> &amp;&amp; moreChars) || (firstLine &amp;&amp; !moreChars)) &amp;&amp;</span><br><span class="line">                    ellipsize != TextUtils.TruncateAt.MARQUEE) ||</span><br><span class="line">            (!firstLine &amp;&amp; (currentLineIsTheLastVisibleOne || !moreChars) &amp;&amp;</span><br><span class="line">                    ellipsize == TextUtils.TruncateAt.END);</span><br><span class="line">    <span class="keyword">if</span> (doEllipsis) &#123;</span><br><span class="line">        calculateEllipsis(start, end, widths, widthStart,</span><br><span class="line">                ellipsisWidth, ellipsize, j,</span><br><span class="line">                textWidth, paint, forceEllipsis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第3部分是对省略的计算和处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> lastLine;</span><br><span class="line"><span class="keyword">if</span> (mEllipsized) &#123;</span><br><span class="line">    lastLine = <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> lastCharIsNewLine = widthStart != bufEnd &amp;&amp; bufEnd &gt; <span class="number">0</span></span><br><span class="line">            &amp;&amp; text.charAt(bufEnd - <span class="number">1</span>) == CHAR_NEW_LINE;</span><br><span class="line">    <span class="keyword">if</span> (end == bufEnd &amp;&amp; !lastCharIsNewLine) &#123;</span><br><span class="line">        lastLine = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start == bufEnd &amp;&amp; lastCharIsNewLine) &#123;</span><br><span class="line">        lastLine = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lastLine = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (firstLine) &#123;</span><br><span class="line">    <span class="keyword">if</span> (trackPad) &#123;</span><br><span class="line">        mTopPadding = top - above;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (includePad) &#123;</span><br><span class="line">        above = top;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> extra;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (lastLine) &#123;</span><br><span class="line">    <span class="keyword">if</span> (trackPad) &#123;</span><br><span class="line">        mBottomPadding = bottom - below;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (includePad) &#123;</span><br><span class="line">        below = bottom;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (needMultiply &amp;&amp; (addLastLineLineSpacing || !lastLine)) &#123;</span><br><span class="line">    <span class="keyword">double</span> ex = (below - above) * (spacingmult - <span class="number">1</span>) + spacingadd;</span><br><span class="line">    <span class="keyword">if</span> (ex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        extra = (<span class="keyword">int</span>)(ex + EXTRA_ROUNDING);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        extra = -(<span class="keyword">int</span>)(-ex + EXTRA_ROUNDING);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    extra = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第4部分是对首行末行的特殊处理，因为要考虑上下留白；还有对行间距的特殊处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lines[off + START] = start;</span><br><span class="line">  lines[off + TOP] = v;</span><br><span class="line">  lines[off + DESCENT] = below + extra;</span><br><span class="line">  lines[off + EXTRA] = extra;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// special case for non-ellipsized last visible line when maxLines is set</span></span><br><span class="line">  <span class="comment">// store the height as if it was ellipsized</span></span><br><span class="line">  <span class="keyword">if</span> (!mEllipsized &amp;&amp; currentLineIsTheLastVisibleOne) &#123;</span><br><span class="line">      <span class="comment">// below calculation as if it was the last line</span></span><br><span class="line">      <span class="keyword">int</span> maxLineBelow = includePad ? bottom : below;</span><br><span class="line">      <span class="comment">// similar to the calculation of v below, without the extra.</span></span><br><span class="line">      mMaxLineHeight = v + (maxLineBelow - above);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  v += (below - above) + extra;</span><br><span class="line">  lines[off + mColumns + START] = end;</span><br><span class="line">  lines[off + mColumns + TOP] = v;</span><br><span class="line"></span><br><span class="line">  lines[off + TAB] |= flags &amp; TAB_MASK;</span><br><span class="line">  lines[off + HYPHEN] = flags;</span><br><span class="line">  lines[off + DIR] |= dir &lt;&lt; DIR_SHIFT;</span><br><span class="line">  mLineDirections[j] = measured.getDirections(start - widthStart, end - widthStart);</span><br><span class="line"></span><br><span class="line">  mLineCount++;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br></pre></td></tr></table></figure>
<ul>
<li>第5部分就是将处理完的每一行的信息，都记录到lines数组中了</li>
</ul>
<p><strong>从这里就能看出out函数的作用是对Layout中的每一行文本进行分析，最重要的产出就是得到mLines数组</strong></p>
<h3 id="Layout-draw"><a href="#Layout-draw" class="headerlink" title="Layout.draw()"></a>Layout.draw()</h3><p>在上一篇TextView的整体流程中我们看到，TextView的onDraw()执行过程中，最终实际上是通过Layout.draw()函数完成的，而在Layout前面的分析中我们已经得到了每一行的信息，所以接下来看下Layout.draw()函数是怎么执行的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas, Path highlight, Paint highlightPaint,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> cursorOffsetVertical)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> lineRange = getLineRangeForDraw(canvas);</span><br><span class="line">    <span class="keyword">int</span> firstLine = TextUtils.unpackRangeStartFromLong(lineRange);</span><br><span class="line">    <span class="keyword">int</span> lastLine = TextUtils.unpackRangeEndFromLong(lineRange);</span><br><span class="line">    <span class="keyword">if</span> (lastLine &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    drawBackground(canvas, highlight, highlightPaint, cursorOffsetVertical,</span><br><span class="line">            firstLine, lastLine);</span><br><span class="line">    drawText(canvas, firstLine, lastLine);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Layout.draw()实际上分成了两部分，drawBackground()和drawText()，下面看下它们的实现：</p>
<h3 id="Layout-drawBackground"><a href="#Layout-drawBackground" class="headerlink" title="Layout.drawBackground()"></a>Layout.drawBackground()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawBackground</span><span class="params">(Canvas canvas, Path highlight, Paint highlightPaint,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> cursorOffsetVertical, <span class="keyword">int</span> firstLine, <span class="keyword">int</span> lastLine)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// First, draw LineBackgroundSpans.</span></span><br><span class="line">    <span class="comment">// LineBackgroundSpans know nothing about the alignment, margins, or</span></span><br><span class="line">    <span class="comment">// direction of the layout or line.  <span class="doctag">XXX:</span> Should they?</span></span><br><span class="line">    <span class="comment">// They are evaluated at each line.</span></span><br><span class="line">    <span class="keyword">if</span> (mSpannedText) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mLineBackgroundSpans == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mLineBackgroundSpans = <span class="keyword">new</span> SpanSet&lt;LineBackgroundSpan&gt;(LineBackgroundSpan.class);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Spanned buffer = (Spanned) mText;</span><br><span class="line">        <span class="keyword">int</span> textLength = buffer.length();</span><br><span class="line">        mLineBackgroundSpans.init(buffer, <span class="number">0</span>, textLength);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mLineBackgroundSpans.numberOfSpans &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> previousLineBottom = getLineTop(firstLine);</span><br><span class="line">            <span class="keyword">int</span> previousLineEnd = getLineStart(firstLine);</span><br><span class="line">            ParagraphStyle[] spans = NO_PARA_SPANS;</span><br><span class="line">            <span class="keyword">int</span> spansLength = <span class="number">0</span>;</span><br><span class="line">            TextPaint paint = mPaint;</span><br><span class="line">            <span class="keyword">int</span> spanEnd = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> width = mWidth;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = firstLine; i &lt;= lastLine; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> start = previousLineEnd;</span><br><span class="line">                <span class="keyword">int</span> end = getLineStart(i + <span class="number">1</span>);</span><br><span class="line">                previousLineEnd = end;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> ltop = previousLineBottom;</span><br><span class="line">                <span class="keyword">int</span> lbottom = getLineTop(i + <span class="number">1</span>);</span><br><span class="line">                previousLineBottom = lbottom;</span><br><span class="line">                <span class="keyword">int</span> lbaseline = lbottom - getLineDescent(i);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (start &gt;= spanEnd) &#123;</span><br><span class="line">                    <span class="comment">// These should be infrequent, so we&#x27;ll use this so that</span></span><br><span class="line">                    <span class="comment">// we don&#x27;t have to check as often.</span></span><br><span class="line">                    spanEnd = mLineBackgroundSpans.getNextTransition(start, textLength);</span><br><span class="line">                    <span class="comment">// All LineBackgroundSpans on a line contribute to its background.</span></span><br><span class="line">                    spansLength = <span class="number">0</span>;</span><br><span class="line">                    <span class="comment">// Duplication of the logic of getParagraphSpans</span></span><br><span class="line">                    <span class="keyword">if</span> (start != end || start == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// Equivalent to a getSpans(start, end), but filling the &#x27;spans&#x27; local</span></span><br><span class="line">                        <span class="comment">// array instead to reduce memory allocation</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mLineBackgroundSpans.numberOfSpans; j++) &#123;</span><br><span class="line">                            <span class="comment">// equal test is valid since both intervals are not empty by</span></span><br><span class="line">                            <span class="comment">// construction</span></span><br><span class="line">                            <span class="keyword">if</span> (mLineBackgroundSpans.spanStarts[j] &gt;= end ||</span><br><span class="line">                                    mLineBackgroundSpans.spanEnds[j] &lt;= start) <span class="keyword">continue</span>;</span><br><span class="line">                            spans = GrowingArrayUtils.append(</span><br><span class="line">                                    spans, spansLength, mLineBackgroundSpans.spans[j]);</span><br><span class="line">                            spansLength++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; spansLength; n++) &#123;</span><br><span class="line">                    LineBackgroundSpan lineBackgroundSpan = (LineBackgroundSpan) spans[n];</span><br><span class="line">                    lineBackgroundSpan.drawBackground(canvas, paint, <span class="number">0</span>, width,</span><br><span class="line">                            ltop, lbaseline, lbottom,</span><br><span class="line">                            buffer, start, end, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mLineBackgroundSpans.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// There can be a highlight even without spans if we are drawing</span></span><br><span class="line">    <span class="comment">// a non-spanned transformation of a spanned editing buffer.</span></span><br><span class="line">    <span class="keyword">if</span> (highlight != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cursorOffsetVertical != <span class="number">0</span>) canvas.translate(<span class="number">0</span>, cursorOffsetVertical);</span><br><span class="line">        canvas.drawPath(highlight, highlightPaint);</span><br><span class="line">        <span class="keyword">if</span> (cursorOffsetVertical != <span class="number">0</span>) canvas.translate(<span class="number">0</span>, -cursorOffsetVertical);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>代码不长，可以看到Layout的drawBackground()实际上是通过LineBackgroundSpan.drawBackground()来完成的，而LineBackgroundSpan只是一个接口，在Android源码中并没有实现类，因此drawBackground()的实际绘制效果是使用时自己定义的</li>
</ul>
<h3 id="Layout-drawText"><a href="#Layout-drawText" class="headerlink" title="Layout.drawText()"></a>Layout.drawText()</h3><p><img src="https://raw.githubusercontent.com/SysuCodeMan/PicBed/main/20210506175504.png"><br>drawText()方法整体内容如图，主要的工作在for循环中，从注释中能看出，drawText()的过程是，逐行绘制，下面看下这个for循环内部的逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> start = previousLineEnd;</span><br><span class="line">previousLineEnd = getLineStart(lineNum + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> justify = isJustificationRequired(lineNum);</span><br><span class="line"><span class="keyword">int</span> end = getLineVisibleEnd(lineNum, start, previousLineEnd);</span><br><span class="line">paint.setHyphenEdit(getHyphen(lineNum));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ltop = previousLineBottom;</span><br><span class="line"><span class="keyword">int</span> lbottom = getLineTop(lineNum + <span class="number">1</span>);</span><br><span class="line">previousLineBottom = lbottom;</span><br><span class="line"><span class="keyword">int</span> lbaseline = lbottom - getLineDescent(lineNum);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dir = getParagraphDirection(lineNum);</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = mWidth;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mSpannedText) &#123;</span><br><span class="line">    Spanned sp = (Spanned) buf;</span><br><span class="line">    <span class="keyword">int</span> textLength = buf.length();</span><br><span class="line">    <span class="keyword">boolean</span> isFirstParaLine = (start == <span class="number">0</span> || buf.charAt(start - <span class="number">1</span>) == <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// New batch of paragraph styles, collect into spans array.</span></span><br><span class="line">    <span class="comment">// Compute the alignment, last alignment style wins.</span></span><br><span class="line">    <span class="comment">// Reset tabStops, we&#x27;ll rebuild if we encounter a line with</span></span><br><span class="line">    <span class="comment">// tabs.</span></span><br><span class="line">    <span class="comment">// We expect paragraph spans to be relatively infrequent, use</span></span><br><span class="line">    <span class="comment">// spanEnd so that we can check less frequently.  Since</span></span><br><span class="line">    <span class="comment">// paragraph styles ought to apply to entire paragraphs, we can</span></span><br><span class="line">    <span class="comment">// just collect the ones present at the start of the paragraph.</span></span><br><span class="line">    <span class="comment">// If spanEnd is before the end of the paragraph, that&#x27;s not</span></span><br><span class="line">    <span class="comment">// our problem.</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt;= spanEnd &amp;&amp; (lineNum == firstLine || isFirstParaLine)) &#123;</span><br><span class="line">        spanEnd = sp.nextSpanTransition(start, textLength,</span><br><span class="line">                                        ParagraphStyle.class);</span><br><span class="line">        spans = getParagraphSpans(sp, start, spanEnd, ParagraphStyle.class);</span><br><span class="line"></span><br><span class="line">        paraAlign = mAlignment;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = spans.length - <span class="number">1</span>; n &gt;= <span class="number">0</span>; n--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (spans[n] <span class="keyword">instanceof</span> AlignmentSpan) &#123;</span><br><span class="line">                paraAlign = ((AlignmentSpan) spans[n]).getAlignment();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tabStopsIsInitialized = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Draw all leading margin spans.  Adjust left or right according</span></span><br><span class="line">    <span class="comment">// to the paragraph direction of the line.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> length = spans.length;</span><br><span class="line">    <span class="keyword">boolean</span> useFirstLineMargin = isFirstParaLine;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; length; n++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (spans[n] <span class="keyword">instanceof</span> LeadingMarginSpan2) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = ((LeadingMarginSpan2) spans[n]).getLeadingMarginLineCount();</span><br><span class="line">            <span class="keyword">int</span> startLine = getLineForOffset(sp.getSpanStart(spans[n]));</span><br><span class="line">            <span class="comment">// if there is more than one LeadingMarginSpan2, use</span></span><br><span class="line">            <span class="comment">// the count that is greatest</span></span><br><span class="line">            <span class="keyword">if</span> (lineNum &lt; startLine + count) &#123;</span><br><span class="line">                useFirstLineMargin = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; length; n++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (spans[n] <span class="keyword">instanceof</span> LeadingMarginSpan) &#123;</span><br><span class="line">            LeadingMarginSpan margin = (LeadingMarginSpan) spans[n];</span><br><span class="line">            <span class="keyword">if</span> (dir == DIR_RIGHT_TO_LEFT) &#123;</span><br><span class="line">                margin.drawLeadingMargin(canvas, paint, right, dir, ltop,</span><br><span class="line">                                         lbaseline, lbottom, buf,</span><br><span class="line">                                         start, end, isFirstParaLine, <span class="keyword">this</span>);</span><br><span class="line">                right -= margin.getLeadingMargin(useFirstLineMargin);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                margin.drawLeadingMargin(canvas, paint, left, dir, ltop,</span><br><span class="line">                                         lbaseline, lbottom, buf,</span><br><span class="line">                                         start, end, isFirstParaLine, <span class="keyword">this</span>);</span><br><span class="line">                left += margin.getLeadingMargin(useFirstLineMargin);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第1部分，主要是判断是不是Spanned，是的话需要获取影响ParagraphStyle的Span，然后判断其中是否有LeadingMarginSpan，有的话会调用其drawLeadingMargin()方法来绘制其段首的缩进效果</li>
</ul>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">boolean <span class="attr">hasTab</span> = getLineContainsTab(lineNum);</span><br><span class="line">// Can&#x27;t tell <span class="keyword">if</span> we have tabs for sure, currently</span><br><span class="line"><span class="keyword">if</span> (hasTab &amp;&amp; !tabStopsIsInitialized) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="attr">tabStops</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="attr">tabStops</span> = new TabStops(TAB_INCREMENT, spans);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tabStops.reset(TAB_INCREMENT, spans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">tabStopsIsInitialized</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Determine whether the line aligns to normal, opposite, <span class="literal">or</span> center.</span><br><span class="line">Alignment <span class="attr">align</span> = paraAlign;</span><br><span class="line"><span class="keyword">if</span> (<span class="attr">align</span> == Alignment.ALIGN_LEFT) &#123;</span><br><span class="line">    <span class="attr">align</span> = (<span class="attr">dir</span> == DIR_LEFT_TO_RIGHT) ?</span><br><span class="line">        Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="attr">align</span> == Alignment.ALIGN_RIGHT) &#123;</span><br><span class="line">    <span class="attr">align</span> = (<span class="attr">dir</span> == DIR_LEFT_TO_RIGHT) ?</span><br><span class="line">        Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int x;</span><br><span class="line">final int indentWidth;</span><br><span class="line"><span class="keyword">if</span> (<span class="attr">align</span> == Alignment.ALIGN_NORMAL) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="attr">dir</span> == DIR_LEFT_TO_RIGHT) &#123;</span><br><span class="line">        <span class="attr">indentWidth</span> = getIndentAdjust(lineNum, Alignment.ALIGN_LEFT);</span><br><span class="line">        <span class="attr">x</span> = left + indentWidth;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="attr">indentWidth</span> = -getIndentAdjust(lineNum, Alignment.ALIGN_RIGHT);</span><br><span class="line">        <span class="attr">x</span> = right - indentWidth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    int <span class="attr">max</span> = (int)getLineExtent(lineNum, tabStops, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="attr">align</span> == Alignment.ALIGN_OPPOSITE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="attr">dir</span> == DIR_LEFT_TO_RIGHT) &#123;</span><br><span class="line">            <span class="attr">indentWidth</span> = -getIndentAdjust(lineNum, Alignment.ALIGN_RIGHT);</span><br><span class="line">            <span class="attr">x</span> = right - max - indentWidth;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="attr">indentWidth</span> = getIndentAdjust(lineNum, Alignment.ALIGN_LEFT);</span><br><span class="line">            <span class="attr">x</span> = left - max + indentWidth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; // Alignment.ALIGN_CENTER</span><br><span class="line">        <span class="attr">indentWidth</span> = getIndentAdjust(lineNum, Alignment.ALIGN_CENTER);</span><br><span class="line">        <span class="attr">max</span> = max &amp; ~<span class="number">1</span>;</span><br><span class="line">        <span class="attr">x</span> = ((right + left - max) &gt;&gt; <span class="number">1</span>) + indentWidth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Directions <span class="attr">directions</span> = getLineDirections(lineNum);</span><br></pre></td></tr></table></figure>
<ul>
<li>第2部分，确定该行中是否有Tab，以及对其方式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (directions == DIRS_ALL_LEFT_TO_RIGHT &amp;&amp; !mSpannedText &amp;&amp; !hasTab &amp;&amp; !justify) &#123;</span><br><span class="line">     <span class="comment">// <span class="doctag">XXX:</span> assumes there&#x27;s nothing additional to be done</span></span><br><span class="line">     canvas.drawText(buf, start, end, x, lbaseline, paint);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     tl.set(paint, buf, start, end, dir, directions, hasTab, tabStops);</span><br><span class="line">     <span class="keyword">if</span> (justify) &#123;</span><br><span class="line">         tl.justify(right - left - indentWidth);</span><br><span class="line">     &#125;</span><br><span class="line">     tl.draw(canvas, x, ltop, lbaseline, lbottom);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第3部分，根据前面的信息，如果是布局从左到右并且是普通文本而且没有tab而且不需要对齐，则调用canvas.drawText来绘制，否则调用的是TextLine的draw()方法来进行绘制</li>
</ul>
]]></content>
      <tags>
        <tag>Android控件</tag>
      </tags>
  </entry>
  <entry>
    <title>Android TextView源码浅析之顶层流程</title>
    <url>/2021/04/16/Android-TextView%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90%E4%B9%8B%E9%A1%B6%E5%B1%82%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="OverView"><a href="#OverView" class="headerlink" title="OverView"></a>OverView</h3><p>TextView应该是Android中最基础也是使用最广的控件，其能力简单来说就是将一段文本显示出来，但TextView可能也是最复杂的控件之一，涉及到的类众多，我们来采取自顶向下的方式来学习一下TextView的源码，这一篇先从最顶层开始，整体熟悉TextView的工作过程。</p>
<h3 id="继承层次"><a href="#继承层次" class="headerlink" title="继承层次"></a>继承层次</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextView</span> <span class="keyword">extends</span> <span class="title">View</span> <span class="keyword">implements</span> <span class="title">ViewTreeObserver</span>.<span class="title">OnPreDrawListener</span></span></span><br></pre></td></tr></table></figure>
<p>继承层次很简单，是View的直接子类，实现了ViewTreeObserver.OnPreDrawListener接口<br>而在官方的文档中，能看到其子类有：<br><img src="https://raw.githubusercontent.com/SysuCodeMan/PicBed/main/20210506175259.png"><br>基础控件中常用的Button, EditText都是派生自TextView，这也说明了学习TextView的源码是大有裨益的。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TextView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TextView</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, attrs, com.android.internal.R.attr.textViewStyle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TextView</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, attrs, defStyleAttr, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TextView</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    // ^</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;  </span></span></span><br></pre></td></tr></table></figure>
<p>TextView的构造函数也是模板化的，有1~4个参数的构造函数，单参数的调用二参数然后以此类推，最终都会调用到4参数的构造函数<br>4参数的构造函数实现较长，分段来看下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">super</span>(context, attrs, defStyleAttr, defStyleRes);</span><br><span class="line"></span><br><span class="line"><span class="comment">// TextView is important by default, unless app developer overrode attribute.</span></span><br><span class="line"><span class="keyword">if</span> (getImportantForAutofill() == IMPORTANT_FOR_AUTOFILL_AUTO) &#123;</span><br><span class="line">    setImportantForAutofill(IMPORTANT_FOR_AUTOFILL_YES);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTextInternal(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Resources res = getResources();</span><br><span class="line"><span class="keyword">final</span> CompatibilityInfo compat = res.getCompatibilityInfo();</span><br><span class="line"></span><br><span class="line">mTextPaint = <span class="keyword">new</span> TextPaint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">mTextPaint.density = res.getDisplayMetrics().density;</span><br><span class="line">mTextPaint.setCompatibilityScaling(compat.applicationScale);</span><br><span class="line"></span><br><span class="line">mHighlightPaint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">mHighlightPaint.setCompatibilityScaling(compat.applicationScale);</span><br><span class="line"></span><br><span class="line">mMovement = getDefaultMovementMethod();</span><br><span class="line"></span><br><span class="line">mTransformation = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> TextAppearanceAttributes attributes = <span class="keyword">new</span> TextAppearanceAttributes();</span><br><span class="line">attributes.mTextColor = ColorStateList.valueOf(<span class="number">0xFF000000</span>);</span><br><span class="line">attributes.mTextSize = <span class="number">15</span>;</span><br><span class="line">mBreakStrategy = Layout.BREAK_STRATEGY_SIMPLE;</span><br><span class="line">mHyphenationFrequency = Layout.HYPHENATION_FREQUENCY_NONE;</span><br><span class="line">mJustificationMode = Layout.JUSTIFICATION_MODE_NONE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Resources.Theme theme = context.getTheme();</span><br></pre></td></tr></table></figure>
<ul>
<li>第1部分主要是相关类和变量的初始化<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TypedArray a = theme.obtainStyledAttributes(attrs,</span><br><span class="line">        com.android.internal.R.styleable.TextViewAppearance, defStyleAttr, defStyleRes);</span><br><span class="line">TypedArray appearance = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> ap = a.getResourceId(</span><br><span class="line">        com.android.internal.R.styleable.TextViewAppearance_textAppearance, -<span class="number">1</span>);</span><br><span class="line">a.recycle();</span><br><span class="line"><span class="keyword">if</span> (ap != -<span class="number">1</span>) &#123;</span><br><span class="line">    appearance = theme.obtainStyledAttributes(</span><br><span class="line">            ap, com.android.internal.R.styleable.TextAppearance);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (appearance != <span class="keyword">null</span>) &#123;</span><br><span class="line">    readTextAppearance(context, appearance, attributes, <span class="keyword">false</span> <span class="comment">/* styleArray */</span>);</span><br><span class="line">    attributes.mFontFamilyExplicit = <span class="keyword">false</span>;</span><br><span class="line">    appearance.recycle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> editable = getDefaultEditable();</span><br><span class="line">CharSequence inputMethod = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> numeric = <span class="number">0</span>;</span><br><span class="line">CharSequence digits = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> phone = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span> autotext = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> autocap = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> buffertype = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span> selectallonfocus = <span class="keyword">false</span>;</span><br><span class="line">Drawable drawableLeft = <span class="keyword">null</span>, drawableTop = <span class="keyword">null</span>, drawableRight = <span class="keyword">null</span>,</span><br><span class="line">        drawableBottom = <span class="keyword">null</span>, drawableStart = <span class="keyword">null</span>, drawableEnd = <span class="keyword">null</span>;</span><br><span class="line">ColorStateList drawableTint = <span class="keyword">null</span>;</span><br><span class="line">PorterDuff.Mode drawableTintMode = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> drawablePadding = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ellipsize = ELLIPSIZE_NOT_SET;</span><br><span class="line"><span class="keyword">boolean</span> singleLine = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> maxlength = -<span class="number">1</span>;</span><br><span class="line">CharSequence text = <span class="string">&quot;&quot;</span>;</span><br><span class="line">CharSequence hint = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> password = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">float</span> autoSizeMinTextSizeInPx = UNSET_AUTO_SIZE_UNIFORM_CONFIGURATION_VALUE;</span><br><span class="line"><span class="keyword">float</span> autoSizeMaxTextSizeInPx = UNSET_AUTO_SIZE_UNIFORM_CONFIGURATION_VALUE;</span><br><span class="line"><span class="keyword">float</span> autoSizeStepGranularityInPx = UNSET_AUTO_SIZE_UNIFORM_CONFIGURATION_VALUE;</span><br><span class="line"><span class="keyword">int</span> inputType = EditorInfo.TYPE_NULL;</span><br><span class="line">a = theme.obtainStyledAttributes(</span><br><span class="line">            attrs, com.android.internal.R.styleable.TextView, defStyleAttr, defStyleRes);</span><br><span class="line"><span class="keyword">int</span> firstBaselineToTopHeight = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> lastBaselineToBottomHeight = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> lineHeight = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">readTextAppearance(context, a, attributes, <span class="keyword">true</span> <span class="comment">/* styleArray */</span>);</span><br></pre></td></tr></table></figure></li>
<li>第2部分主要是获取应用的theme等全局属性，来初始化TextView的一些样式相关的变量<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = a.getIndexCount();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Must set id in a temporary variable because it will be reset by setText()</span></span><br><span class="line"><span class="keyword">boolean</span> textIsSetFromXml = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> attr = a.getIndex(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (attr) &#123;</span><br><span class="line">        <span class="keyword">case</span> com.android.internal.R.styleable.TextView_editable:</span><br><span class="line">            editable = a.getBoolean(attr, editable);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> com.android.internal.R.styleable.TextView_inputMethod:</span><br><span class="line">            inputMethod = a.getText(attr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> com.android.internal.R.styleable.TextView_numeric:</span><br><span class="line">            numeric = a.getInt(attr, numeric);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">        <span class="keyword">case</span> com.android.internal.R.styleable.TextView_lineHeight:</span><br><span class="line">            lineHeight = a.getDimensionPixelSize(attr, -<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.recycle();</span><br></pre></td></tr></table></figure></li>
<li>第3部分就是在XML中解析出对应的属性然后赋值到相关变量上<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> variation =</span><br><span class="line">        inputType &amp; (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_MASK_VARIATION);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> passwordInputType = variation</span><br><span class="line">        == (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> webPasswordInputType = variation</span><br><span class="line">        == (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_WEB_PASSWORD);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> numberPasswordInputType = variation</span><br><span class="line">        == (EditorInfo.TYPE_CLASS_NUMBER | EditorInfo.TYPE_NUMBER_VARIATION_PASSWORD);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> targetSdkVersion = context.getApplicationInfo().targetSdkVersion;</span><br><span class="line">mUseInternationalizedInput = targetSdkVersion &gt;= VERSION_CODES.O;</span><br><span class="line">mUseFallbackLineSpacing = targetSdkVersion &gt;= VERSION_CODES.P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (inputMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Class&lt;?&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        c = Class.forName(inputMethod.toString());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        createEditorIfNeeded();</span><br><span class="line">        mEditor.mKeyListener = (KeyListener) c.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mEditor.mInputType = inputType != EditorInfo.TYPE_NULL</span><br><span class="line">                ? inputType</span><br><span class="line">                : mEditor.mKeyListener.getInputType();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IncompatibleClassChangeError e) &#123;</span><br><span class="line">        mEditor.mInputType = EditorInfo.TYPE_CLASS_TEXT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (digits != <span class="keyword">null</span>) &#123;</span><br><span class="line">    createEditorIfNeeded();</span><br><span class="line">    mEditor.mKeyListener = DigitsKeyListener.getInstance(digits.toString());</span><br><span class="line">    <span class="comment">// If no input type was specified, we will default to generic</span></span><br><span class="line">    <span class="comment">// text, since we can&#x27;t tell the IME about the set of digits</span></span><br><span class="line">    <span class="comment">// that was selected.</span></span><br><span class="line">    mEditor.mInputType = inputType != EditorInfo.TYPE_NULL</span><br><span class="line">            ? inputType : EditorInfo.TYPE_CLASS_TEXT;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (inputType != EditorInfo.TYPE_NULL) &#123;</span><br><span class="line">    setInputType(inputType, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// If set, the input type overrides what was set using the deprecated singleLine flag.</span></span><br><span class="line">    singleLine = !isMultilineInputType(inputType);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (phone) &#123;</span><br><span class="line">    createEditorIfNeeded();</span><br><span class="line">    mEditor.mKeyListener = DialerKeyListener.getInstance();</span><br><span class="line">    mEditor.mInputType = inputType = EditorInfo.TYPE_CLASS_PHONE;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (numeric != <span class="number">0</span>) &#123;</span><br><span class="line">    createEditorIfNeeded();</span><br><span class="line">    mEditor.mKeyListener = DigitsKeyListener.getInstance(</span><br><span class="line">            <span class="keyword">null</span>,  <span class="comment">// locale</span></span><br><span class="line">            (numeric &amp; SIGNED) != <span class="number">0</span>,</span><br><span class="line">            (numeric &amp; DECIMAL) != <span class="number">0</span>);</span><br><span class="line">    inputType = mEditor.mKeyListener.getInputType();</span><br><span class="line">    mEditor.mInputType = inputType;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (autotext || autocap != -<span class="number">1</span>) &#123;</span><br><span class="line">    TextKeyListener.Capitalize cap;</span><br><span class="line"></span><br><span class="line">    inputType = EditorInfo.TYPE_CLASS_TEXT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (autocap) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            cap = TextKeyListener.Capitalize.SENTENCES;</span><br><span class="line">            inputType |= EditorInfo.TYPE_TEXT_FLAG_CAP_SENTENCES;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            cap = TextKeyListener.Capitalize.WORDS;</span><br><span class="line">            inputType |= EditorInfo.TYPE_TEXT_FLAG_CAP_WORDS;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            cap = TextKeyListener.Capitalize.CHARACTERS;</span><br><span class="line">            inputType |= EditorInfo.TYPE_TEXT_FLAG_CAP_CHARACTERS;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            cap = TextKeyListener.Capitalize.NONE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEditorIfNeeded();</span><br><span class="line">    mEditor.mKeyListener = TextKeyListener.getInstance(autotext, cap);</span><br><span class="line">    mEditor.mInputType = inputType;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (editable) &#123;</span><br><span class="line">    createEditorIfNeeded();</span><br><span class="line">    mEditor.mKeyListener = TextKeyListener.getInstance();</span><br><span class="line">    mEditor.mInputType = EditorInfo.TYPE_CLASS_TEXT;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (isTextSelectable()) &#123;</span><br><span class="line">    <span class="comment">// Prevent text changes from keyboard.</span></span><br><span class="line">    <span class="keyword">if</span> (mEditor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mEditor.mKeyListener = <span class="keyword">null</span>;</span><br><span class="line">        mEditor.mInputType = EditorInfo.TYPE_NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    bufferType = BufferType.SPANNABLE;</span><br><span class="line">    <span class="comment">// So that selection can be changed using arrow keys and touch is handled.</span></span><br><span class="line">    setMovementMethod(ArrowKeyMovementMethod.getInstance());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mEditor != <span class="keyword">null</span>) mEditor.mKeyListener = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (buffertype) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            bufferType = BufferType.NORMAL;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            bufferType = BufferType.SPANNABLE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            bufferType = BufferType.EDITABLE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mEditor != <span class="keyword">null</span>) &#123;</span><br><span class="line">    mEditor.adjustInputType(password, passwordInputType, webPasswordInputType,</span><br><span class="line">            numberPasswordInputType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (selectallonfocus) &#123;</span><br><span class="line">    createEditorIfNeeded();</span><br><span class="line">    mEditor.mSelectAllOnFocus = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bufferType == BufferType.NORMAL) &#123;</span><br><span class="line">        bufferType = BufferType.SPANNABLE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第4部分是和输入编辑相关的初始化，涉及到的Editor类，负责的功能就是处理文本的区域选择处理和判断、拼写检查、弹出文本菜单等<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Set up the tint (if needed) before setting the drawables so that it</span></span><br><span class="line"><span class="comment">// gets applied correctly.</span></span><br><span class="line"><span class="keyword">if</span> (drawableTint != <span class="keyword">null</span> || drawableTintMode != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mDrawables == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mDrawables = <span class="keyword">new</span> Drawables(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (drawableTint != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mDrawables.mTintList = drawableTint;</span><br><span class="line">        mDrawables.mHasTint = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (drawableTintMode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mDrawables.mTintMode = drawableTintMode;</span><br><span class="line">        mDrawables.mHasTintMode = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This call will save the initial left/right drawables</span></span><br><span class="line">setCompoundDrawablesWithIntrinsicBounds(</span><br><span class="line">        drawableLeft, drawableTop, drawableRight, drawableBottom);</span><br><span class="line">setRelativeDrawablesIfNeeded(drawableStart, drawableEnd);</span><br><span class="line">setCompoundDrawablePadding(drawablePadding);</span><br></pre></td></tr></table></figure></li>
<li>第5部分的工作是，设置对应位置的Drawable<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Same as setSingleLine(), but make sure the transformation method and the maximum number</span></span><br><span class="line"> <span class="comment">// of lines of height are unchanged for multi-line TextViews.</span></span><br><span class="line"> setInputTypeSingleLine(singleLine);</span><br><span class="line"> applySingleLine(singleLine, singleLine, singleLine);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (singleLine &amp;&amp; getKeyListener() == <span class="keyword">null</span> &amp;&amp; ellipsize == ELLIPSIZE_NOT_SET) &#123;</span><br><span class="line">     ellipsize = ELLIPSIZE_END;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">switch</span> (ellipsize) &#123;</span><br><span class="line">     <span class="keyword">case</span> ELLIPSIZE_START:</span><br><span class="line">         setEllipsize(TextUtils.TruncateAt.START);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> ELLIPSIZE_MIDDLE:</span><br><span class="line">         setEllipsize(TextUtils.TruncateAt.MIDDLE);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> ELLIPSIZE_END:</span><br><span class="line">         setEllipsize(TextUtils.TruncateAt.END);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> ELLIPSIZE_MARQUEE:</span><br><span class="line">         <span class="keyword">if</span> (ViewConfiguration.get(context).isFadingMarqueeEnabled()) &#123;</span><br><span class="line">             setHorizontalFadingEdgeEnabled(<span class="keyword">true</span>);</span><br><span class="line">             mMarqueeFadeMode = MARQUEE_FADE_NORMAL;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             setHorizontalFadingEdgeEnabled(<span class="keyword">false</span>);</span><br><span class="line">             mMarqueeFadeMode = MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS;</span><br><span class="line">         &#125;</span><br><span class="line">         setEllipsize(TextUtils.TruncateAt.MARQUEE);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">boolean</span> isPassword = password || passwordInputType || webPasswordInputType</span><br><span class="line">         || numberPasswordInputType;</span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">boolean</span> isMonospaceEnforced = isPassword || (mEditor != <span class="keyword">null</span></span><br><span class="line">         &amp;&amp; (mEditor.mInputType</span><br><span class="line">         &amp; (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_MASK_VARIATION))</span><br><span class="line">         == (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD));</span><br><span class="line"> <span class="keyword">if</span> (isMonospaceEnforced) &#123;</span><br><span class="line">     attributes.mTypefaceIndex = MONOSPACE;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> applyTextAppearance(attributes);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (isPassword) &#123;</span><br><span class="line">     setTransformationMethod(PasswordTransformationMethod.getInstance());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (maxlength &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">     setFilters(<span class="keyword">new</span> InputFilter[] &#123; <span class="keyword">new</span> InputFilter.LengthFilter(maxlength) &#125;);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     setFilters(NO_FILTERS);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> setText(text, bufferType);</span><br><span class="line"> <span class="keyword">if</span> (textIsSetFromXml) &#123;</span><br><span class="line">     mTextSetFromXmlOrResourceId = <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (hint != <span class="keyword">null</span>) setHint(hint);</span><br></pre></td></tr></table></figure></li>
<li>第6部分，是比较关键的设置文字的部分，先是确定好是否单行，然后设置省略方式，最后调用setText()，如果有必要还会设置hint<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Views are not normally clickable unless specified to be.</span></span><br><span class="line"><span class="comment"> * However, TextViews that have input or movement methods *are*</span></span><br><span class="line"><span class="comment"> * clickable by default. By setting clickable here, we implicitly set focusable as well</span></span><br><span class="line"><span class="comment"> * if not overridden by the developer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">a = context.obtainStyledAttributes(</span><br><span class="line">        attrs, com.android.<span class="keyword">internal</span>.R.styleable.View, defStyleAttr, defStyleRes);</span><br><span class="line"><span class="built_in">boolean</span> canInputOrMove = (mMovement != <span class="literal">null</span> || getKeyListener() != <span class="literal">null</span>);</span><br><span class="line"><span class="built_in">boolean</span> clickable = canInputOrMove || isClickable();</span><br><span class="line"><span class="built_in">boolean</span> longClickable = canInputOrMove || isLongClickable();</span><br><span class="line"><span class="built_in">int</span> focusable = getFocusable();</span><br><span class="line"></span><br><span class="line">n = a.getIndexCount();</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">int</span> attr = a.getIndex(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (attr) &#123;</span><br><span class="line">        <span class="keyword">case</span> com.android.<span class="keyword">internal</span>.R.styleable.View_focusable:</span><br><span class="line">            TypedValue val = <span class="keyword">new</span> TypedValue();</span><br><span class="line">            <span class="keyword">if</span> (a.getValue(attr, val)) &#123;</span><br><span class="line">                focusable = (val.type == TypedValue.TYPE_INT_BOOLEAN)</span><br><span class="line">                        ? (val.data == <span class="number">0</span> ? NOT_FOCUSABLE : FOCUSABLE)</span><br><span class="line">                        : val.data;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> com.android.<span class="keyword">internal</span>.R.styleable.View_clickable:</span><br><span class="line">            clickable = a.getBoolean(attr, clickable);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> com.android.<span class="keyword">internal</span>.R.styleable.View_longClickable:</span><br><span class="line">            longClickable = a.getBoolean(attr, longClickable);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">a.recycle();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Some apps were relying on the undefined behavior of focusable winning over</span></span><br><span class="line"><span class="comment">// focusableInTouchMode != focusable in TextViews if both were specified in XML (usually</span></span><br><span class="line"><span class="comment">// when starting with EditText and setting only focusable=false). To keep those apps from</span></span><br><span class="line"><span class="comment">// breaking, re-apply the focusable attribute here.</span></span><br><span class="line"><span class="keyword">if</span> (focusable != getFocusable()) &#123;</span><br><span class="line">    setFocusable(focusable);</span><br><span class="line">&#125;</span><br><span class="line">setClickable(clickable);</span><br><span class="line">setLongClickable(longClickable);</span><br></pre></td></tr></table></figure></li>
<li>第7部分是设置能否点击的相关属性<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mEditor != <span class="keyword">null</span>) mEditor.prepareCursorControllers();</span><br><span class="line"></span><br><span class="line"><span class="comment">// If not explicitly specified this view is important for accessibility.</span></span><br><span class="line"><span class="keyword">if</span> (getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) &#123;</span><br><span class="line">    setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (supportsAutoSizeText()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mAutoSizeTextType == AUTO_SIZE_TEXT_TYPE_UNIFORM) &#123;</span><br><span class="line">        <span class="comment">// If uniform auto-size has been specified but preset values have not been set then</span></span><br><span class="line">        <span class="comment">// replace the auto-size configuration values that have not been specified with the</span></span><br><span class="line">        <span class="comment">// defaults.</span></span><br><span class="line">        <span class="keyword">if</span> (!mHasPresetAutoSizeValues) &#123;</span><br><span class="line">            <span class="keyword">final</span> DisplayMetrics displayMetrics = getResources().getDisplayMetrics();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (autoSizeMinTextSizeInPx == UNSET_AUTO_SIZE_UNIFORM_CONFIGURATION_VALUE) &#123;</span><br><span class="line">                autoSizeMinTextSizeInPx = TypedValue.applyDimension(</span><br><span class="line">                        TypedValue.COMPLEX_UNIT_SP,</span><br><span class="line">                        DEFAULT_AUTO_SIZE_MIN_TEXT_SIZE_IN_SP,</span><br><span class="line">                        displayMetrics);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (autoSizeMaxTextSizeInPx == UNSET_AUTO_SIZE_UNIFORM_CONFIGURATION_VALUE) &#123;</span><br><span class="line">                autoSizeMaxTextSizeInPx = TypedValue.applyDimension(</span><br><span class="line">                        TypedValue.COMPLEX_UNIT_SP,</span><br><span class="line">                        DEFAULT_AUTO_SIZE_MAX_TEXT_SIZE_IN_SP,</span><br><span class="line">                        displayMetrics);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (autoSizeStepGranularityInPx</span><br><span class="line">                    == UNSET_AUTO_SIZE_UNIFORM_CONFIGURATION_VALUE) &#123;</span><br><span class="line">                autoSizeStepGranularityInPx = DEFAULT_AUTO_SIZE_GRANULARITY_IN_PX;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            validateAndSetAutoSizeTextTypeUniformConfiguration(autoSizeMinTextSizeInPx,</span><br><span class="line">                    autoSizeMaxTextSizeInPx,</span><br><span class="line">                    autoSizeStepGranularityInPx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setupAutoSizeText();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mAutoSizeTextType = AUTO_SIZE_TEXT_TYPE_NONE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (firstBaselineToTopHeight &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    setFirstBaselineToTopHeight(firstBaselineToTopHeight);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (lastBaselineToBottomHeight &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    setLastBaselineToBottomHeight(lastBaselineToBottomHeight);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (lineHeight &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    setLineHeight(lineHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>最后第8部分是设置AutoSize/BaseLine/LineHeight等外观相关的属性</li>
</ul>
<h3 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure()"></a>onMeasure()</h3><p>对于onMeasure()源码的解析，同样还是分段来看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line"><span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line"><span class="keyword">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line"><span class="keyword">int</span> heightSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> width;</span><br><span class="line"><span class="keyword">int</span> height;</span><br><span class="line"></span><br><span class="line">BoringLayout.Metrics boring = UNKNOWN_BORING;</span><br><span class="line">BoringLayout.Metrics hintBoring = UNKNOWN_BORING;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mTextDir == <span class="keyword">null</span>) &#123;</span><br><span class="line">    mTextDir = getTextDirectionHeuristic();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第1部分是相关变量的初始化，这里涉及到一个BoringLayout的概念，在这一层先不去管其实现，知道它的作用是对最简单的文本进行排版<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> des = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">boolean</span> fromexisting = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> widthLimit = (widthMode == MeasureSpec.AT_MOST)</span><br><span class="line">        ?  (<span class="keyword">float</span>) widthSize : Float.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (widthMode == MeasureSpec.EXACTLY) &#123;</span><br><span class="line">    <span class="comment">// Parent has told us how big to be. So be it.</span></span><br><span class="line">    width = widthSize;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mLayout != <span class="keyword">null</span> &amp;&amp; mEllipsize == <span class="keyword">null</span>) &#123;</span><br><span class="line">        des = desired(mLayout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (des &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        boring = BoringLayout.isBoring(mTransformed, mTextPaint, mTextDir, mBoring);</span><br><span class="line">        <span class="keyword">if</span> (boring != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mBoring = boring;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fromexisting = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (boring == <span class="keyword">null</span> || boring == UNKNOWN_BORING) &#123;</span><br><span class="line">        <span class="keyword">if</span> (des &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            des = (<span class="keyword">int</span>) Math.ceil(Layout.getDesiredWidthWithLimit(mTransformed, <span class="number">0</span>,</span><br><span class="line">                    mTransformed.length(), mTextPaint, mTextDir, widthLimit));</span><br><span class="line">        &#125;</span><br><span class="line">        width = des;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        width = boring.width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Drawables dr = mDrawables;</span><br><span class="line">    <span class="keyword">if</span> (dr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        width = Math.max(width, dr.mDrawableWidthTop);</span><br><span class="line">        width = Math.max(width, dr.mDrawableWidthBottom);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mHint != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> hintDes = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> hintWidth;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mHintLayout != <span class="keyword">null</span> &amp;&amp; mEllipsize == <span class="keyword">null</span>) &#123;</span><br><span class="line">            hintDes = desired(mHintLayout);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hintDes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            hintBoring = BoringLayout.isBoring(mHint, mTextPaint, mTextDir, mHintBoring);</span><br><span class="line">            <span class="keyword">if</span> (hintBoring != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mHintBoring = hintBoring;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hintBoring == <span class="keyword">null</span> || hintBoring == UNKNOWN_BORING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hintDes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                hintDes = (<span class="keyword">int</span>) Math.ceil(Layout.getDesiredWidthWithLimit(mHint, <span class="number">0</span>,</span><br><span class="line">                        mHint.length(), mTextPaint, mTextDir, widthLimit));</span><br><span class="line">            &#125;</span><br><span class="line">            hintWidth = hintDes;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hintWidth = hintBoring.width;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hintWidth &gt; width) &#123;</span><br><span class="line">            width = hintWidth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    width += getCompoundPaddingLeft() + getCompoundPaddingRight();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mMaxWidthMode == EMS) &#123;</span><br><span class="line">        width = Math.min(width, mMaxWidth * getLineHeight());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        width = Math.min(width, mMaxWidth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mMinWidthMode == EMS) &#123;</span><br><span class="line">        width = Math.max(width, mMinWidth * getLineHeight());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        width = Math.max(width, mMinWidth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check against our minimum width</span></span><br><span class="line">    width = Math.max(width, getSuggestedMinimumWidth());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (widthMode == MeasureSpec.AT_MOST) &#123;</span><br><span class="line">        width = Math.min(widthSize, width);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> want = width - getCompoundPaddingLeft() - getCompoundPaddingRight();</span><br><span class="line"><span class="keyword">int</span> unpaddedWidth = want;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mHorizontallyScrolling) want = VERY_WIDE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> hintWant = want;</span><br><span class="line"><span class="keyword">int</span> hintWidth = (mHintLayout == <span class="keyword">null</span>) ? hintWant : mHintLayout.getWidth();</span><br></pre></td></tr></table></figure>
第2部分是对宽度的计算，如果MeasureMode是EXCACTLY，那直接用父View指定的宽度，否则需要通过Layout来计算，这里再重复一次Layout的概念——Layout负责TextView的排版，包括折行省略等；在计算宽度时，会在正文和hint都会产生一个对应的宽度，取两者最大值作为TextView的宽度<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mLayout == <span class="keyword">null</span>) &#123;</span><br><span class="line">     makeNewLayout(want, hintWant, boring, hintBoring,</span><br><span class="line">                   width - getCompoundPaddingLeft() - getCompoundPaddingRight(), <span class="keyword">false</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">boolean</span> layoutChanged = (mLayout.getWidth() != want) || (hintWidth != hintWant)</span><br><span class="line">             || (mLayout.getEllipsizedWidth()</span><br><span class="line">                     != width - getCompoundPaddingLeft() - getCompoundPaddingRight());</span><br><span class="line"></span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">boolean</span> widthChanged = (mHint == <span class="keyword">null</span>) &amp;&amp; (mEllipsize == <span class="keyword">null</span>)</span><br><span class="line">             &amp;&amp; (want &gt; mLayout.getWidth())</span><br><span class="line">             &amp;&amp; (mLayout <span class="keyword">instanceof</span> BoringLayout</span><br><span class="line">                     || (fromexisting &amp;&amp; des &gt;= <span class="number">0</span> &amp;&amp; des &lt;= want));</span><br><span class="line"></span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">boolean</span> maximumChanged = (mMaxMode != mOldMaxMode) || (mMaximum != mOldMaximum);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (layoutChanged || maximumChanged) &#123;</span><br><span class="line">         <span class="keyword">if</span> (!maximumChanged &amp;&amp; widthChanged) &#123;</span><br><span class="line">             mLayout.increaseWidthTo(want);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             makeNewLayout(want, hintWant, boring, hintBoring,</span><br><span class="line">                     width - getCompoundPaddingLeft() - getCompoundPaddingRight(), <span class="keyword">false</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// Nothing has changed</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li>第3部分也仍然是宽度的相关计算，根据Layout的内容对宽度进行调整，这里涉及到比较关键的方法是makeNewLayout()，关于这个方法，在下一层讲Layout时再展开说。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (heightMode == MeasureSpec.EXACTLY) &#123;</span><br><span class="line">    <span class="comment">// Parent has told us how big to be. So be it.</span></span><br><span class="line">    height = heightSize;</span><br><span class="line">    mDesiredHeightAtMeasure = -<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> desired = getDesiredHeight();</span><br><span class="line"></span><br><span class="line">    height = desired;</span><br><span class="line">    mDesiredHeightAtMeasure = desired;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (heightMode == MeasureSpec.AT_MOST) &#123;</span><br><span class="line">        height = Math.min(desired, heightSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> unpaddedHeight = height - getCompoundPaddingTop() - getCompoundPaddingBottom();</span><br><span class="line"><span class="keyword">if</span> (mMaxMode == LINES &amp;&amp; mLayout.getLineCount() &gt; mMaximum) &#123;</span><br><span class="line">    unpaddedHeight = Math.min(unpaddedHeight, mLayout.getLineTop(mMaximum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第4部分是对高度的计算，内容比宽度的处理少很多，主要通过getDesiredHeight()获得高度；篇幅比width少的原因在于，在计算width的时候，实际上已经通过Layout处理完了排版，完成了height所需的部分工作，getDesiredHeight()的内部实现实际上也是通过mLayout来获得高度的<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We didn&#x27;t let makeNewLayout() register to bring the cursor into view,</span></span><br><span class="line"><span class="comment"> * so do it here if there is any possibility that it is needed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (mMovement != <span class="keyword">null</span></span><br><span class="line">        || mLayout.getWidth() &gt; unpaddedWidth</span><br><span class="line">        || mLayout.getHeight() &gt; unpaddedHeight) &#123;</span><br><span class="line">    registerForPreDraw();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    scrollTo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setMeasuredDimension(width, height);</span><br></pre></td></tr></table></figure></li>
<li>第5部分是最终width和height的结果处理</li>
</ul>
<h3 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout()"></a>onLayout()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onLayout(changed, left, top, right, bottom);</span><br><span class="line">    <span class="keyword">if</span> (mDeferScroll &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> curs = mDeferScroll;</span><br><span class="line">        mDeferScroll = -<span class="number">1</span>;</span><br><span class="line">        bringPointIntoView(Math.min(curs, mText.length()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Call auto-size after the width and height have been calculated.</span></span><br><span class="line">    autoSizeText();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常View的直接子类很少重写onLayout()函数，但TextView就重写了，主要工作就是在onLayout()中调用autoSizeText()</p>
<h3 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw()"></a>onDraw()</h3><p>onDraw()函数同样也分段来看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">restartMarqueeIfNeeded();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Draw the background for this view</span></span><br><span class="line"><span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> compoundPaddingLeft = getCompoundPaddingLeft();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> compoundPaddingTop = getCompoundPaddingTop();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> compoundPaddingRight = getCompoundPaddingRight();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> compoundPaddingBottom = getCompoundPaddingBottom();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> scrollX = mScrollX;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> scrollY = mScrollY;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> right = mRight;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> left = mLeft;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> bottom = mBottom;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> top = mTop;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> isLayoutRtl = isLayoutRtl();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> offset = getHorizontalOffsetForDrawables();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> leftOffset = isLayoutRtl ? <span class="number">0</span> : offset;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> rightOffset = isLayoutRtl ? offset : <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>第1部分，是相关变量的初始化<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Drawables dr = mDrawables;</span><br><span class="line"><span class="keyword">if</span> (dr != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Compound, not extended, because the icon is not clipped</span></span><br><span class="line"><span class="comment">     * if the text height is smaller.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> vspace = bottom - top - compoundPaddingBottom - compoundPaddingTop;</span><br><span class="line">    <span class="keyword">int</span> hspace = right - left - compoundPaddingRight - compoundPaddingLeft;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IMPORTANT: The coordinates computed are also used in invalidateDrawable()</span></span><br><span class="line">    <span class="comment">// Make sure to update invalidateDrawable() when changing this code.</span></span><br><span class="line">    <span class="keyword">if</span> (dr.mShowing[Drawables.LEFT] != <span class="keyword">null</span>) &#123;</span><br><span class="line">        canvas.save();</span><br><span class="line">        canvas.translate(scrollX + mPaddingLeft + leftOffset,</span><br><span class="line">                scrollY + compoundPaddingTop + (vspace - dr.mDrawableHeightLeft) / <span class="number">2</span>);</span><br><span class="line">        dr.mShowing[Drawables.LEFT].draw(canvas);</span><br><span class="line">        canvas.restore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IMPORTANT: The coordinates computed are also used in invalidateDrawable()</span></span><br><span class="line">    <span class="comment">// Make sure to update invalidateDrawable() when changing this code.</span></span><br><span class="line">    <span class="keyword">if</span> (dr.mShowing[Drawables.RIGHT] != <span class="keyword">null</span>) &#123;</span><br><span class="line">        canvas.save();</span><br><span class="line">        canvas.translate(scrollX + right - left - mPaddingRight</span><br><span class="line">                - dr.mDrawableSizeRight - rightOffset,</span><br><span class="line">                 scrollY + compoundPaddingTop + (vspace - dr.mDrawableHeightRight) / <span class="number">2</span>);</span><br><span class="line">        dr.mShowing[Drawables.RIGHT].draw(canvas);</span><br><span class="line">        canvas.restore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IMPORTANT: The coordinates computed are also used in invalidateDrawable()</span></span><br><span class="line">    <span class="comment">// Make sure to update invalidateDrawable() when changing this code.</span></span><br><span class="line">    <span class="keyword">if</span> (dr.mShowing[Drawables.TOP] != <span class="keyword">null</span>) &#123;</span><br><span class="line">        canvas.save();</span><br><span class="line">        canvas.translate(scrollX + compoundPaddingLeft</span><br><span class="line">                + (hspace - dr.mDrawableWidthTop) / <span class="number">2</span>, scrollY + mPaddingTop);</span><br><span class="line">        dr.mShowing[Drawables.TOP].draw(canvas);</span><br><span class="line">        canvas.restore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IMPORTANT: The coordinates computed are also used in invalidateDrawable()</span></span><br><span class="line">    <span class="comment">// Make sure to update invalidateDrawable() when changing this code.</span></span><br><span class="line">    <span class="keyword">if</span> (dr.mShowing[Drawables.BOTTOM] != <span class="keyword">null</span>) &#123;</span><br><span class="line">        canvas.save();</span><br><span class="line">        canvas.translate(scrollX + compoundPaddingLeft</span><br><span class="line">                + (hspace - dr.mDrawableWidthBottom) / <span class="number">2</span>,</span><br><span class="line">                 scrollY + bottom - top - mPaddingBottom - dr.mDrawableSizeBottom);</span><br><span class="line">        dr.mShowing[Drawables.BOTTOM].draw(canvas);</span><br><span class="line">        canvas.restore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第2部分，对上下左右的Drawable进行绘制<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> color = mCurTextColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mLayout == <span class="keyword">null</span>) &#123;</span><br><span class="line">    assumeLayout();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Layout layout = mLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mHint != <span class="keyword">null</span> &amp;&amp; mText.length() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mHintTextColor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        color = mCurHintTextColor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    layout = mHintLayout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mTextPaint.setColor(color);</span><br><span class="line">mTextPaint.drawableState = getDrawableState();</span><br><span class="line"></span><br><span class="line">canvas.save();</span><br></pre></td></tr></table></figure></li>
<li>第3部分，确定此时绘制的是hint还是正文，设置对应的颜色和Layout<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> extendedPaddingTop = getExtendedPaddingTop();</span><br><span class="line"><span class="keyword">int</span> extendedPaddingBottom = getExtendedPaddingBottom();</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> vspace = mBottom - mTop - compoundPaddingBottom - compoundPaddingTop;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> maxScrollY = mLayout.getHeight() - vspace;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> clipLeft = compoundPaddingLeft + scrollX;</span><br><span class="line"><span class="keyword">float</span> clipTop = (scrollY == <span class="number">0</span>) ? <span class="number">0</span> : extendedPaddingTop + scrollY;</span><br><span class="line"><span class="keyword">float</span> clipRight = right - left - getCompoundPaddingRight() + scrollX;</span><br><span class="line"><span class="keyword">float</span> clipBottom = bottom - top + scrollY</span><br><span class="line">        - ((scrollY == maxScrollY) ? <span class="number">0</span> : extendedPaddingBottom);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mShadowRadius != <span class="number">0</span>) &#123;</span><br><span class="line">    clipLeft += Math.min(<span class="number">0</span>, mShadowDx - mShadowRadius);</span><br><span class="line">    clipRight += Math.max(<span class="number">0</span>, mShadowDx + mShadowRadius);</span><br><span class="line"></span><br><span class="line">    clipTop += Math.min(<span class="number">0</span>, mShadowDy - mShadowRadius);</span><br><span class="line">    clipBottom += Math.max(<span class="number">0</span>, mShadowDy + mShadowRadius);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">canvas.clipRect(clipLeft, clipTop, clipRight, clipBottom);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> voffsetText = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> voffsetCursor = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// translate in by our padding</span></span><br><span class="line"><span class="comment">/* shortcircuit calling getVerticaOffset() */</span></span><br><span class="line"><span class="keyword">if</span> ((mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK) != Gravity.TOP) &#123;</span><br><span class="line">    voffsetText = getVerticalOffset(<span class="keyword">false</span>);</span><br><span class="line">    voffsetCursor = getVerticalOffset(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">canvas.translate(compoundPaddingLeft, extendedPaddingTop + voffsetText);</span><br></pre></td></tr></table></figure></li>
<li>第4部分，是对padding的相关处理，主要是和阴影效果相关<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = getLayoutDirection();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> absoluteGravity = Gravity.getAbsoluteGravity(mGravity, layoutDirection);</span><br><span class="line"><span class="keyword">if</span> (isMarqueeFadeEnabled()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mSingleLine &amp;&amp; getLineCount() == <span class="number">1</span> &amp;&amp; canMarquee()</span><br><span class="line">            &amp;&amp; (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) != Gravity.LEFT) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> width = mRight - mLeft;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> padding = getCompoundPaddingLeft() + getCompoundPaddingRight();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> dx = mLayout.getLineRight(<span class="number">0</span>) - (width - padding);</span><br><span class="line">        canvas.translate(layout.getParagraphDirection(<span class="number">0</span>) * dx, <span class="number">0.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mMarquee != <span class="keyword">null</span> &amp;&amp; mMarquee.isRunning()) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> dx = -mMarquee.getScroll();</span><br><span class="line">        canvas.translate(layout.getParagraphDirection(<span class="number">0</span>) * dx, <span class="number">0.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第5部分，主要是走马灯效果的相关处理<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> cursorOffsetVertical = voffsetCursor - voffsetText;</span><br><span class="line"></span><br><span class="line">  Path highlight = getUpdatedHighlightPath();</span><br><span class="line">  <span class="keyword">if</span> (mEditor != <span class="keyword">null</span>) &#123;</span><br><span class="line">      mEditor.onDraw(canvas, layout, highlight, mHighlightPaint, cursorOffsetVertical);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      layout.draw(canvas, highlight, mHighlightPaint, cursorOffsetVertical);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mMarquee != <span class="keyword">null</span> &amp;&amp; mMarquee.shouldDrawGhost()) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">float</span> dx = mMarquee.getGhostOffset();</span><br><span class="line">      canvas.translate(layout.getParagraphDirection(<span class="number">0</span>) * dx, <span class="number">0.0f</span>);</span><br><span class="line">      layout.draw(canvas, highlight, mHighlightPaint, cursorOffsetVertical);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  canvas.restore();</span><br></pre></td></tr></table></figure></li>
<li>第6部分，真正绘制文字的地方，实际上是通过mEditor.draw()或者layout.draw()来进行绘制</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在TextView这一层，整体流程如上文所示，从源码学习的过程中能看到，实际上测量和绘制的逻辑都在Layout/Editor这些类里面，在下一篇我们具体看下它们的实现。</p>
]]></content>
      <tags>
        <tag>Android控件</tag>
      </tags>
  </entry>
  <entry>
    <title>OkHttp源码学习</title>
    <url>/2021/04/21/OkHttp%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p><code>OkHttp是Square公司开源的一款HTTP网络请求发送框架，通过OkHttp可以轻松地进行网络请求</code></p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">run</span><span class="params">(String url)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(url)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">    <span class="keyword">return</span> response.body().string();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面看下client.newCall(request).execute()的流程</p>
<h3 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1.构造函数"></a>1.构造函数</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpClient</span> <span class="keyword">internal</span> <span class="keyword">constructor</span></span>(builder: Builder)</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constructor</span>() : <span class="keyword">this</span>(Builder())</span><br></pre></td></tr></table></figure>
<p>构造函数分为带参的和无参的两个，带参的传入Builder，在Builder中进行相关配置；无参函数内部会调用默认的Builder构造函数</p>
<h3 id="2-Request类"><a href="#2-Request类" class="headerlink" title="2.Request类"></a>2.Request类</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Request</span> <span class="keyword">internal</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;url&quot;</span>) <span class="keyword">val</span> url: HttpUrl,</span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;method&quot;</span>) <span class="keyword">val</span> method: String,</span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;headers&quot;</span>) <span class="keyword">val</span> headers: Headers,</span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;body&quot;</span>) <span class="keyword">val</span> body: RequestBody?,</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">val</span> tags: Map&lt;Class&lt;*&gt;, Any&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>包含了url/method/headers/body一个报文需要的字段</p>
<h3 id="3-OkHttpClient-newCall-Request-request-方法"><a href="#3-OkHttpClient-newCall-Request-request-方法" class="headerlink" title="3.OkHttpClient.newCall(Request request)方法"></a>3.OkHttpClient.newCall(Request request)方法</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newCall</span><span class="params">(request: <span class="type">Request</span>)</span></span>: Call = RealCall(<span class="keyword">this</span>, request, forWebSocket = <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<p>通过传入的request和当前client，构造一个RealCall对象</p>
<h3 id="4-RealCall-execute"><a href="#4-RealCall-execute" class="headerlink" title="4.RealCall.execute()"></a>4.RealCall.execute()</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">  check(executed.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123; <span class="string">&quot;Already Executed&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">  timeout.enter()</span><br><span class="line">  callStart()</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    client.dispatcher.executed(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">return</span> getResponseWithInterceptorChain()</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用OkHttpClient的dispatcher来进行executed()进行操作</p>
<h4 id="4-1-Dispatcher-executed-call-RealCall"><a href="#4-1-Dispatcher-executed-call-RealCall" class="headerlink" title="4.1 Dispatcher.executed(call: RealCall)"></a>4.1 Dispatcher.executed(call: RealCall)</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">runningSyncCalls.add(call)</span><br></pre></td></tr></table></figure>
<p>这里的runningSyncCalls是一个ArrayDeque对象，所以这个方法实际上就是把这个请求加入到队列中</p>
<h4 id="4-2-RealCall-getResponseWithInterceptorChain-Response"><a href="#4-2-RealCall-getResponseWithInterceptorChain-Response" class="headerlink" title="4.2 RealCall.getResponseWithInterceptorChain() : Response"></a>4.2 RealCall.getResponseWithInterceptorChain() : Response</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">  <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">  <span class="keyword">val</span> interceptors = mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">  interceptors += client.interceptors</span><br><span class="line">  interceptors += RetryAndFollowUpInterceptor(client)</span><br><span class="line">  interceptors += BridgeInterceptor(client.cookieJar)</span><br><span class="line">  interceptors += CacheInterceptor(client.cache)</span><br><span class="line">  interceptors += ConnectInterceptor</span><br><span class="line">  <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">    interceptors += client.networkInterceptors</span><br><span class="line">  &#125;</span><br><span class="line">  interceptors += CallServerInterceptor(forWebSocket)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> chain = RealInterceptorChain(</span><br><span class="line">      call = <span class="keyword">this</span>,</span><br><span class="line">      interceptors = interceptors,</span><br><span class="line">      index = <span class="number">0</span>,</span><br><span class="line">      exchange = <span class="literal">null</span>,</span><br><span class="line">      request = originalRequest,</span><br><span class="line">      connectTimeoutMillis = client.connectTimeoutMillis,</span><br><span class="line">      readTimeoutMillis = client.readTimeoutMillis,</span><br><span class="line">      writeTimeoutMillis = client.writeTimeoutMillis</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> calledNoMoreExchanges = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> response = chain.proceed(originalRequest)</span><br><span class="line">    <span class="keyword">if</span> (isCanceled()) &#123;</span><br><span class="line">      response.closeQuietly()</span><br><span class="line">      <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">    calledNoMoreExchanges = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">throw</span> noMoreExchanges(e) <span class="keyword">as</span> Throwable</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class="line">      noMoreExchanges(<span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>设置Interceptor</li>
<li>构造RealInterceptorChain</li>
<li>调用RealInterceptorChain.proceed(request: Request) : Response</li>
</ul>
<h3 id="5-RealInterceptorChain-proceed-request-Request-Response"><a href="#5-RealInterceptorChain-proceed-request-Request-Response" class="headerlink" title="5.RealInterceptorChain.proceed(request: Request) : Response"></a>5.RealInterceptorChain.proceed(request: Request) : Response</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">proceed</span><span class="params">(request: <span class="type">Request</span>)</span></span>: Response &#123;</span><br><span class="line">  check(index &lt; interceptors.size)</span><br><span class="line"></span><br><span class="line">  calls++</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (exchange != <span class="literal">null</span>) &#123;</span><br><span class="line">    check(exchange.finder.sameHostAndPort(request.url)) &#123;</span><br><span class="line">      <span class="string">&quot;network interceptor <span class="subst">$&#123;interceptors[index - <span class="number">1</span>]&#125;</span> must retain the same host and port&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    check(calls == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="string">&quot;network interceptor <span class="subst">$&#123;interceptors[index - <span class="number">1</span>]&#125;</span> must call proceed() exactly once&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Call the next interceptor in the chain.</span></span><br><span class="line">  <span class="keyword">val</span> next = copy(index = index + <span class="number">1</span>, request = request)</span><br><span class="line">  <span class="keyword">val</span> interceptor = interceptors[index]</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Suppress(<span class="meta-string">&quot;USELESS_ELVIS&quot;</span>)</span></span><br><span class="line">  <span class="keyword">val</span> response = interceptor.intercept(next) ?: <span class="keyword">throw</span> NullPointerException(</span><br><span class="line">      <span class="string">&quot;interceptor <span class="variable">$interceptor</span> returned null&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (exchange != <span class="literal">null</span>) &#123;</span><br><span class="line">    check(index + <span class="number">1</span> &gt;= interceptors.size || next.calls == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="string">&quot;network interceptor <span class="variable">$interceptor</span> must call proceed() exactly once&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  check(response.body != <span class="literal">null</span>) &#123; <span class="string">&quot;interceptor <span class="variable">$interceptor</span> returned a response with no body&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个proceed函数中，关键的代码是以下两句：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> next = copy(index = index + <span class="number">1</span>, request = request)</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> response = interceptor.intercept(next) </span><br></pre></td></tr></table></figure>
<p>第一句是将当前的index加一，然后再复制出新一个新的RealIntercetorChain<br>第二句是将index+1复制出来的RealIntercetorChain作为参数传入当前index对应的interceptor的intercept()函数中<br>从4.2中可以知道，最早被执行的是RetryAndFollowUpInterceptor，最后一个被执行的是CallServerInterceptor</p>
<h3 id="6-RetryAndFollowUpInterceptor-intercept"><a href="#6-RetryAndFollowUpInterceptor-intercept" class="headerlink" title="6 RetryAndFollowUpInterceptor.intercept()"></a>6 RetryAndFollowUpInterceptor.intercept()</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">    <span class="keyword">var</span> request = chain.request</span><br><span class="line">    <span class="keyword">val</span> call = realChain.call</span><br><span class="line">    <span class="keyword">var</span> followUpCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> priorResponse: Response? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> newExchangeFinder = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> recoveredFailures = listOf&lt;IOException&gt;()</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      call.enterNetworkInterceptorExchange(request, newExchangeFinder)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> response: Response</span><br><span class="line">      <span class="keyword">var</span> closeActiveExchange = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (call.isCanceled()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          response = realChain.proceed(request)</span><br><span class="line">          newExchangeFinder = <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: RouteException) &#123;</span><br><span class="line">          <span class="comment">// ……</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">          <span class="comment">// ……</span></span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ……</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      </span><br><span class="line"><span class="comment">//……      &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里暂时略去这个Interceptor的具体实现，看到最关键的就是下面这句代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">response = realChain.proceed(request)</span><br></pre></td></tr></table></figure>
<p>这个realChain就是在5里index + 1之后构造出来的RealInterceptorChain，因此形成了一下的调用链：<br>index对应的RealInterceptorChain调用index对应的Interceptor.intercept(),然后Interceptor.intercept()会调用index+1的RealInterceptorChain；在这里完成了index到index+1的intercetor的链式调用；并且最终真正执行index对应的Interceptor时，response就是index+1的intercept()方法处理完的response<br>因此后面分别看下各个Interceptor都做了哪些事情。</p>
<h3 id="7-RetryAndFollowUpInterceptor-失败和重定向拦截器"><a href="#7-RetryAndFollowUpInterceptor-失败和重定向拦截器" class="headerlink" title="7.RetryAndFollowUpInterceptor - 失败和重定向拦截器"></a>7.RetryAndFollowUpInterceptor - 失败和重定向拦截器</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">  <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">  <span class="keyword">var</span> request = chain.request</span><br><span class="line">  <span class="keyword">val</span> call = realChain.call</span><br><span class="line">  <span class="keyword">var</span> followUpCount = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> priorResponse: Response? = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">var</span> newExchangeFinder = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">var</span> recoveredFailures = listOf&lt;IOException&gt;()</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    call.enterNetworkInterceptorExchange(request, newExchangeFinder)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> response: Response</span><br><span class="line">    <span class="keyword">var</span> closeActiveExchange = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (call.isCanceled()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        response = realChain.proceed(request)</span><br><span class="line">        newExchangeFinder = <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e: RouteException) &#123;</span><br><span class="line">        <span class="comment">// The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class="line">        <span class="keyword">if</span> (!recover(e.lastConnectException, call, request, requestSendStarted = <span class="literal">false</span>)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> e.firstConnectException.withSuppressed(recoveredFailures)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          recoveredFailures += e.firstConnectException</span><br><span class="line">        &#125;</span><br><span class="line">        newExchangeFinder = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">        <span class="comment">// An attempt to communicate with a server failed. The request may have been sent.</span></span><br><span class="line">        <span class="keyword">if</span> (!recover(e, call, request, requestSendStarted = e !<span class="keyword">is</span> ConnectionShutdownException)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> e.withSuppressed(recoveredFailures)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          recoveredFailures += e</span><br><span class="line">        &#125;</span><br><span class="line">        newExchangeFinder = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Attach the prior response if it exists. Such responses never have a body.</span></span><br><span class="line">      <span class="keyword">if</span> (priorResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">        response = response.newBuilder()</span><br><span class="line">            .priorResponse(priorResponse.newBuilder()</span><br><span class="line">                .body(<span class="literal">null</span>)</span><br><span class="line">                .build())</span><br><span class="line">            .build()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> exchange = call.interceptorScopedExchange</span><br><span class="line">      <span class="keyword">val</span> followUp = followUpRequest(response, exchange)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (followUp == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exchange != <span class="literal">null</span> &amp;&amp; exchange.isDuplex) &#123;</span><br><span class="line">          call.timeoutEarlyExit()</span><br><span class="line">        &#125;</span><br><span class="line">        closeActiveExchange = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> followUpBody = followUp.body</span><br><span class="line">      <span class="keyword">if</span> (followUpBody != <span class="literal">null</span> &amp;&amp; followUpBody.isOneShot()) &#123;</span><br><span class="line">        closeActiveExchange = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      response.body?.closeQuietly()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ProtocolException(<span class="string">&quot;Too many follow-up requests: <span class="variable">$followUpCount</span>&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      request = followUp</span><br><span class="line">      priorResponse = response</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      call.exitNetworkInterceptorExchange(closeActiveExchange)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个拦截器在拿到response之前没有进行操作，在拿到response之后角色有两个：</p>
<ul>
<li>失败时进行重试</li>
<li>重定向时构造新的request，在while循环的下一轮，这个新的request会交给下一个拦截器处理</li>
</ul>
<h3 id="8-BridgeInterceptor-桥拦截器"><a href="#8-BridgeInterceptor-桥拦截器" class="headerlink" title="8.BridgeInterceptor - 桥拦截器"></a>8.BridgeInterceptor - 桥拦截器</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">  <span class="keyword">val</span> userRequest = chain.request()</span><br><span class="line">  <span class="keyword">val</span> requestBuilder = userRequest.newBuilder()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> body = userRequest.body</span><br><span class="line">  <span class="keyword">if</span> (body != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> contentType = body.contentType()</span><br><span class="line">    <span class="keyword">if</span> (contentType != <span class="literal">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">&quot;Content-Type&quot;</span>, contentType.toString())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> contentLength = body.contentLength()</span><br><span class="line">    <span class="keyword">if</span> (contentLength != -<span class="number">1L</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">&quot;Content-Length&quot;</span>, contentLength.toString())</span><br><span class="line">      requestBuilder.removeHeader(<span class="string">&quot;Transfer-Encoding&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">&quot;Transfer-Encoding&quot;</span>, <span class="string">&quot;chunked&quot;</span>)</span><br><span class="line">      requestBuilder.removeHeader(<span class="string">&quot;Content-Length&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;Host&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">    requestBuilder.header(<span class="string">&quot;Host&quot;</span>, userRequest.url.toHostHeader())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;Connection&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">    requestBuilder.header(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;Keep-Alive&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we add an &quot;Accept-Encoding: gzip&quot; header field we&#x27;re responsible for also decompressing</span></span><br><span class="line">  <span class="comment">// the transfer stream.</span></span><br><span class="line">  <span class="keyword">var</span> transparentGzip = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;Accept-Encoding&quot;</span>) == <span class="literal">null</span> &amp;&amp; userRequest.header(<span class="string">&quot;Range&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">    transparentGzip = <span class="literal">true</span></span><br><span class="line">    requestBuilder.header(<span class="string">&quot;Accept-Encoding&quot;</span>, <span class="string">&quot;gzip&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> cookies = cookieJar.loadForRequest(userRequest.url)</span><br><span class="line">  <span class="keyword">if</span> (cookies.isNotEmpty()) &#123;</span><br><span class="line">    requestBuilder.header(<span class="string">&quot;Cookie&quot;</span>, cookieHeader(cookies))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;User-Agent&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">    requestBuilder.header(<span class="string">&quot;User-Agent&quot;</span>, userAgent)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> networkResponse = chain.proceed(requestBuilder.build())</span><br><span class="line"></span><br><span class="line">  cookieJar.receiveHeaders(userRequest.url, networkResponse.headers)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> responseBuilder = networkResponse.newBuilder()</span><br><span class="line">      .request(userRequest)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (transparentGzip &amp;&amp;</span><br><span class="line">      <span class="string">&quot;gzip&quot;</span>.equals(networkResponse.header(<span class="string">&quot;Content-Encoding&quot;</span>), ignoreCase = <span class="literal">true</span>) &amp;&amp;</span><br><span class="line">      networkResponse.promisesBody()) &#123;</span><br><span class="line">    <span class="keyword">val</span> responseBody = networkResponse.body</span><br><span class="line">    <span class="keyword">if</span> (responseBody != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">val</span> gzipSource = GzipSource(responseBody.source())</span><br><span class="line">      <span class="keyword">val</span> strippedHeaders = networkResponse.headers.newBuilder()</span><br><span class="line">          .removeAll(<span class="string">&quot;Content-Encoding&quot;</span>)</span><br><span class="line">          .removeAll(<span class="string">&quot;Content-Length&quot;</span>)</span><br><span class="line">          .build()</span><br><span class="line">      responseBuilder.headers(strippedHeaders)</span><br><span class="line">      <span class="keyword">val</span> contentType = networkResponse.header(<span class="string">&quot;Content-Type&quot;</span>)</span><br><span class="line">      responseBuilder.body(RealResponseBody(contentType, -<span class="number">1L</span>, gzipSource.buffer()))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> responseBuilder.build()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个拦截器在拿到response之前，将用户构造的请求转换成真实的报文格式；<br>在拿到response之后，将真实的响应转换成用户友好的响应格式<br>这个Bridge指的是从应用程序代码到网络代码的桥梁</p>
<h3 id="9-CacheIntercetpor-缓存拦截器"><a href="#9-CacheIntercetpor-缓存拦截器" class="headerlink" title="9.CacheIntercetpor - 缓存拦截器"></a>9.CacheIntercetpor - 缓存拦截器</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">  <span class="keyword">val</span> call = chain.call()</span><br><span class="line">  <span class="keyword">val</span> cacheCandidate = cache?.<span class="keyword">get</span>(chain.request())</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> now = System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> strategy = CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()</span><br><span class="line">  <span class="keyword">val</span> networkRequest = strategy.networkRequest</span><br><span class="line">  <span class="keyword">val</span> cacheResponse = strategy.cacheResponse</span><br><span class="line"></span><br><span class="line">  cache?.trackResponse(strategy)</span><br><span class="line">  <span class="keyword">val</span> listener = (call <span class="keyword">as</span>? RealCall)?.eventListener ?: EventListener.NONE</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cacheCandidate != <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// The cache candidate wasn&#x27;t applicable. Close it.</span></span><br><span class="line">    cacheCandidate.body?.closeQuietly()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we&#x27;re forbidden from using the network and the cache is insufficient, fail.</span></span><br><span class="line">  <span class="keyword">if</span> (networkRequest == <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Response.Builder()</span><br><span class="line">        .request(chain.request())</span><br><span class="line">        .protocol(Protocol.HTTP_1_1)</span><br><span class="line">        .code(HTTP_GATEWAY_TIMEOUT)</span><br><span class="line">        .message(<span class="string">&quot;Unsatisfiable Request (only-if-cached)&quot;</span>)</span><br><span class="line">        .body(EMPTY_RESPONSE)</span><br><span class="line">        .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build().also &#123;</span><br><span class="line">          listener.satisfactionFailure(call, it)</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we don&#x27;t need the network, we&#x27;re done.</span></span><br><span class="line">  <span class="keyword">if</span> (networkRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> cacheResponse!!.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .build().also &#123;</span><br><span class="line">          listener.cacheHit(call, it)</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">    listener.cacheConditionalHit(call, cacheResponse)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">    listener.cacheMiss(call)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> networkResponse: Response? = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    networkResponse = chain.proceed(networkRequest)</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// If we&#x27;re crashing on I/O or otherwise, don&#x27;t leak the cache body.</span></span><br><span class="line">    <span class="keyword">if</span> (networkResponse == <span class="literal">null</span> &amp;&amp; cacheCandidate != <span class="literal">null</span>) &#123;</span><br><span class="line">      cacheCandidate.body?.closeQuietly()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we have a cache response too, then we&#x27;re doing a conditional get.</span></span><br><span class="line">  <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (networkResponse?.code == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">      <span class="keyword">val</span> response = cacheResponse.newBuilder()</span><br><span class="line">          .headers(combine(cacheResponse.headers, networkResponse.headers))</span><br><span class="line">          .sentRequestAtMillis(networkResponse.sentRequestAtMillis)</span><br><span class="line">          .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)</span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .networkResponse(stripBody(networkResponse))</span><br><span class="line">          .build()</span><br><span class="line"></span><br><span class="line">      networkResponse.body!!.close()</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Update the cache after combining headers but before stripping the</span></span><br><span class="line">      <span class="comment">// Content-Encoding header (as performed by initContentStream()).</span></span><br><span class="line">      cache!!.trackConditionalCacheHit()</span><br><span class="line">      cache.update(cacheResponse, response)</span><br><span class="line">      <span class="keyword">return</span> response.also &#123;</span><br><span class="line">        listener.cacheHit(call, it)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cacheResponse.body?.closeQuietly()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> response = networkResponse!!.newBuilder()</span><br><span class="line">      .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">      .networkResponse(stripBody(networkResponse))</span><br><span class="line">      .build()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (response.promisesBody() &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">      <span class="comment">// Offer this request to the cache.</span></span><br><span class="line">      <span class="keyword">val</span> cacheRequest = cache.put(response)</span><br><span class="line">      <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response).also &#123;</span><br><span class="line">        <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// This will log a conditional cache miss only.</span></span><br><span class="line">          listener.cacheMiss(call)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cache.remove(networkRequest)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (_: IOException) &#123;</span><br><span class="line">        <span class="comment">// The cache cannot be written.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缓存拦截器，顾名思义，就是判断是否需要并且有缓存，如果命中了缓存策略，则直接返回缓存的response，不再触发下一个interceptor的调用；否则继续交给下一个intercetor来获取response</p>
<h3 id="10-ConnectInterceptor-连接拦截器"><a href="#10-ConnectInterceptor-连接拦截器" class="headerlink" title="10.ConnectInterceptor - 连接拦截器"></a>10.ConnectInterceptor - 连接拦截器</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">  <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">  <span class="keyword">val</span> exchange = realChain.call.initExchange(chain)</span><br><span class="line">  <span class="keyword">val</span> connectedChain = realChain.copy(exchange = exchange)</span><br><span class="line">  <span class="keyword">return</span> connectedChain.proceed(realChain.request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-1-ConnectInterceptor相关类"><a href="#10-1-ConnectInterceptor相关类" class="headerlink" title="10.1 ConnectInterceptor相关类"></a>10.1 ConnectInterceptor相关类</h4><p>在调用下一个拦截器之前，构建了exchange和connectedChain，看下Exchange类的结构：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exchange</span></span>(</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">val</span> call: RealCall,</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">val</span> eventListener: EventListener,</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">val</span> finder: ExchangeFinder,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> codec: ExchangeCodec</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>包含了一个ExchangeCodec：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ExchangeCodec</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** Returns the connection that carries this codec. */</span></span><br><span class="line">  <span class="keyword">val</span> connection: RealConnection</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ExchangeCodec是一个接口，具有一个RealConnection成员变量：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealConnection</span></span>(</span><br><span class="line">  <span class="keyword">val</span> connectionPool: RealConnectionPool,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> route: Route</span><br><span class="line">) : Http2Connection.Listener(), Connection &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// These properties are initialized by connect() and never reassigned.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/** The low-level TCP socket. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> rawSocket: Socket? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The application layer socket. Either an [SSLSocket] layered over [rawSocket], or [rawSocket]</span></span><br><span class="line"><span class="comment">   * itself if this connection does not use SSL.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> socket: Socket? = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> handshake: Handshake? = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> protocol: Protocol? = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> http2Connection: Http2Connection? = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> source: BufferedSource? = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> sink: BufferedSink? = <span class="literal">null</span></span><br><span class="line">  <span class="comment">// ……</span></span><br></pre></td></tr></table></figure>
<p>RealConnection最关键的成员变量是Socket，由此可以看出这里是真正和服务端建立连接的地方</p>
<h4 id="10-2-构造Exchange具体过程"><a href="#10-2-构造Exchange具体过程" class="headerlink" title="10.2 构造Exchange具体过程"></a>10.2 构造Exchange具体过程</h4><p>对ConnectInterceptor的相关类有大概了解后，再回到ConnectInterceptor的intercept()函数看下Exchange的具体构造过程</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">  <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">  <span class="keyword">val</span> exchange = realChain.call.initExchange(chain)</span><br><span class="line">  <span class="keyword">val</span> connectedChain = realChain.copy(exchange = exchange)</span><br><span class="line">  <span class="keyword">return</span> connectedChain.proceed(realChain.request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>exchange是通过RealCall的initExchange()构造出来的：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">initExchange</span><span class="params">(chain: <span class="type">RealInterceptorChain</span>)</span></span>: Exchange &#123;</span><br><span class="line">  synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">    check(expectMoreExchanges) &#123; <span class="string">&quot;released&quot;</span> &#125;</span><br><span class="line">    check(!responseBodyOpen)</span><br><span class="line">    check(!requestBodyOpen)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> exchangeFinder = <span class="keyword">this</span>.exchangeFinder!!</span><br><span class="line">  <span class="keyword">val</span> codec = exchangeFinder.find(client, chain)</span><br><span class="line">  <span class="keyword">val</span> result = Exchange(<span class="keyword">this</span>, eventListener, exchangeFinder, codec)</span><br><span class="line">  <span class="keyword">this</span>.interceptorScopedExchange = result</span><br><span class="line">  <span class="keyword">this</span>.exchange = result</span><br><span class="line">  synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.requestBodyOpen = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">this</span>.responseBodyOpen = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (canceled) <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用Exchange的构造函数时，最关键的入参codec是通过ExchangeFinder.find()方法拿到的，看下这个方法的实现</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">find</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  client: <span class="type">OkHttpClient</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  chain: <span class="type">RealInterceptorChain</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: ExchangeCodec &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> resultConnection = findHealthyConnection(</span><br><span class="line">        connectTimeout = chain.connectTimeoutMillis,</span><br><span class="line">        readTimeout = chain.readTimeoutMillis,</span><br><span class="line">        writeTimeout = chain.writeTimeoutMillis,</span><br><span class="line">        pingIntervalMillis = client.pingIntervalMillis,</span><br><span class="line">        connectionRetryEnabled = client.retryOnConnectionFailure,</span><br><span class="line">        doExtensiveHealthChecks = chain.request.method != <span class="string">&quot;GET&quot;</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> resultConnection.newCodec(client, chain)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e: RouteException) &#123;</span><br><span class="line">    trackFailure(e.lastConnectException)</span><br><span class="line">    <span class="keyword">throw</span> e</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">    trackFailure(e)</span><br><span class="line">    <span class="keyword">throw</span> RouteException(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续追溯findHeadlthyConnection()</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findHealthyConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  connectTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  readTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  writeTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  pingIntervalMillis: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  connectionRetryEnabled: <span class="type">Boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  doExtensiveHealthChecks: <span class="type">Boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: RealConnection &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> candidate = findConnection(</span><br><span class="line">        connectTimeout = connectTimeout,</span><br><span class="line">        readTimeout = readTimeout,</span><br><span class="line">        writeTimeout = writeTimeout,</span><br><span class="line">        pingIntervalMillis = pingIntervalMillis,</span><br><span class="line">        connectionRetryEnabled = connectionRetryEnabled</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Confirm that the connection is good.</span></span><br><span class="line">    <span class="keyword">if</span> (candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class="line">      <span class="keyword">return</span> candidate</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If it isn&#x27;t, take it out of the pool.</span></span><br><span class="line">    candidate.noNewExchanges()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure we have some routes left to try. One example where we may exhaust all the routes</span></span><br><span class="line">    <span class="comment">// would happen if we made a new connection and it immediately is detected as unhealthy.</span></span><br><span class="line">    <span class="keyword">if</span> (nextRouteToTry != <span class="literal">null</span>) <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> routesLeft = routeSelection?.hasNext() ?: <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (routesLeft) <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> routesSelectionLeft = routeSelector?.hasNext() ?: <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (routesSelectionLeft) <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> IOException(<span class="string">&quot;exhausted all routes&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不断循环，直到找到一个可用的RealConnection，我们进入findConnection()方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  connectTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  readTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  writeTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  pingIntervalMillis: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  connectionRetryEnabled: <span class="type">Boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: RealConnection &#123;</span><br><span class="line">  <span class="comment">// ……</span></span><br><span class="line">  <span class="comment">// Connect. Tell the call about the connecting call so async cancels work.</span></span><br><span class="line">  <span class="keyword">val</span> newConnection = RealConnection(connectionPool, route)</span><br><span class="line">  call.connectionToCancel = newConnection</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    newConnection.connect(</span><br><span class="line">        connectTimeout,</span><br><span class="line">        readTimeout,</span><br><span class="line">        writeTimeout,</span><br><span class="line">        pingIntervalMillis,</span><br><span class="line">        connectionRetryEnabled,</span><br><span class="line">        call,</span><br><span class="line">        eventListener</span><br><span class="line">    )</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    call.connectionToCancel = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  call.client.routeDatabase.connected(newConnection.route())</span><br><span class="line">  <span class="comment">// ……</span></span><br><span class="line">  <span class="keyword">return</span> newConnection</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数实现比较长，这里截取了最关键的部分：新建一个RealConnection，并且进行connect操作，下面看下RealConnection.connect()具体实现</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    connectTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    readTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    writeTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    pingIntervalMillis: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    connectionRetryEnabled: <span class="type">Boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    call: <span class="type">Call</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    eventListener: <span class="type">EventListener</span></span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span> &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (route.requiresTunnel()) &#123;</span><br><span class="line">          connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener)</span><br><span class="line">          <span class="keyword">if</span> (rawSocket == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// We were unable to connect the tunnel but properly closed down our resources.</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          connectSocket(connectTimeout, readTimeout, call, eventListener)</span><br><span class="line">        &#125;</span><br><span class="line">        establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener)</span><br><span class="line">        eventListener.connectEnd(call, route.socketAddress, route.proxy, protocol)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>同样，抓住最关键的部分：connectTunnel()和connectSocket()；但实际上connectTunnel()内部也是通过connectSocket()实现的，因此直接看connectSocket()的实现</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">connectSocket</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  connectTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  readTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  call: <span class="type">Call</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  eventListener: <span class="type">EventListener</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> proxy = route.proxy</span><br><span class="line">  <span class="keyword">val</span> address = route.address</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> rawSocket = <span class="keyword">when</span> (proxy.type()) &#123;</span><br><span class="line">    Proxy.Type.DIRECT, Proxy.Type.HTTP -&gt; address.socketFactory.createSocket()!!</span><br><span class="line">    <span class="keyword">else</span> -&gt; Socket(proxy)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.rawSocket = rawSocket</span><br><span class="line"></span><br><span class="line">  eventListener.connectStart(call, route.socketAddress, proxy)</span><br><span class="line">  rawSocket.soTimeout = readTimeout</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Platform.<span class="keyword">get</span>().connectSocket(rawSocket, route.socketAddress, connectTimeout)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e: ConnectException) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ConnectException(<span class="string">&quot;Failed to connect to <span class="subst">$&#123;route.socketAddress&#125;</span>&quot;</span>).apply &#123;</span><br><span class="line">      initCause(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The following try/catch block is a pseudo hacky way to get around a crash on Android 7.0</span></span><br><span class="line">  <span class="comment">// More details:</span></span><br><span class="line">  <span class="comment">// https://github.com/square/okhttp/issues/3245</span></span><br><span class="line">  <span class="comment">// https://android-review.googlesource.com/#/c/271775/</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    source = rawSocket.source().buffer()</span><br><span class="line">    sink = rawSocket.sink().buffer()</span><br><span class="line">  &#125; <span class="keyword">catch</span> (npe: NullPointerException) &#123;</span><br><span class="line">    <span class="keyword">if</span> (npe.message == NPE_THROW_WITH_NULL) &#123;</span><br><span class="line">      <span class="keyword">throw</span> IOException(npe)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要就是：1.创建Socket；2.调动Socket的connect()进行连接</p>
<p><strong>至此，已经建立起了连接，接下来交给下一个interceptor进行处理</strong></p>
<h3 id="11-CallServerInterceptor"><a href="#11-CallServerInterceptor" class="headerlink" title="11.CallServerInterceptor"></a>11.CallServerInterceptor</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">    <span class="keyword">val</span> exchange = realChain.exchange!!</span><br><span class="line">    <span class="keyword">val</span> request = realChain.request</span><br><span class="line">    <span class="keyword">val</span> requestBody = request.body</span><br><span class="line">    <span class="keyword">val</span> sentRequestMillis = System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> invokeStartEvent = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> responseBuilder: Response.Builder? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> sendRequestException: IOException? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      exchange.writeRequestHeaders(request)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method) &amp;&amp; requestBody != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If there&#x27;s a &quot;Expect: 100-continue&quot; header on the request, wait for a &quot;HTTP/1.1 100</span></span><br><span class="line">        <span class="comment">// Continue&quot; response before transmitting the request body. If we don&#x27;t get that, return</span></span><br><span class="line">        <span class="comment">// what we did get (such as a 4xx response) without ever transmitting the request body.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;100-continue&quot;</span>.equals(request.header(<span class="string">&quot;Expect&quot;</span>), ignoreCase = <span class="literal">true</span>)) &#123;</span><br><span class="line">          exchange.flushRequest()</span><br><span class="line">          responseBuilder = exchange.readResponseHeaders(expectContinue = <span class="literal">true</span>)</span><br><span class="line">          exchange.responseHeadersStart()</span><br><span class="line">          invokeStartEvent = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (responseBuilder == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (requestBody.isDuplex()) &#123;</span><br><span class="line">            <span class="comment">// Prepare a duplex body so that the application can send a request body later.</span></span><br><span class="line">            exchange.flushRequest()</span><br><span class="line">            <span class="keyword">val</span> bufferedRequestBody = exchange.createRequestBody(request, <span class="literal">true</span>).buffer()</span><br><span class="line">            requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.</span></span><br><span class="line">            <span class="keyword">val</span> bufferedRequestBody = exchange.createRequestBody(request, <span class="literal">false</span>).buffer()</span><br><span class="line">            requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">            bufferedRequestBody.close()</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          exchange.noRequestBody()</span><br><span class="line">          <span class="keyword">if</span> (!exchange.connection.isMultiplexed) &#123;</span><br><span class="line">            <span class="comment">// If the &quot;Expect: 100-continue&quot; expectation wasn&#x27;t met, prevent the HTTP/1 connection</span></span><br><span class="line">            <span class="comment">// from being reused. Otherwise we&#x27;re still obligated to transmit the request body to</span></span><br><span class="line">            <span class="comment">// leave the connection in a consistent state.</span></span><br><span class="line">            exchange.noNewExchangesOnConnection()</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        exchange.noRequestBody()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (requestBody == <span class="literal">null</span> || !requestBody.isDuplex()) &#123;</span><br><span class="line">        exchange.finishRequest()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">      <span class="keyword">if</span> (e <span class="keyword">is</span> ConnectionShutdownException) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e <span class="comment">// No request was sent so there&#x27;s no response to read.</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!exchange.hasFailure) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e <span class="comment">// Don&#x27;t attempt to read the response; we failed to send the request.</span></span><br><span class="line">      &#125;</span><br><span class="line">      sendRequestException = e</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (responseBuilder == <span class="literal">null</span>) &#123;</span><br><span class="line">        responseBuilder = exchange.readResponseHeaders(expectContinue = <span class="literal">false</span>)!!</span><br><span class="line">        <span class="keyword">if</span> (invokeStartEvent) &#123;</span><br><span class="line">          exchange.responseHeadersStart()</span><br><span class="line">          invokeStartEvent = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">var</span> response = responseBuilder</span><br><span class="line">          .request(request)</span><br><span class="line">          .handshake(exchange.connection.handshake())</span><br><span class="line">          .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">          .build()</span><br><span class="line">      <span class="keyword">var</span> code = response.code</span><br><span class="line">      <span class="keyword">if</span> (code == <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="comment">// Server sent a 100-continue even though we did not request one. Try again to read the</span></span><br><span class="line">        <span class="comment">// actual response status.</span></span><br><span class="line">        responseBuilder = exchange.readResponseHeaders(expectContinue = <span class="literal">false</span>)!!</span><br><span class="line">        <span class="keyword">if</span> (invokeStartEvent) &#123;</span><br><span class="line">          exchange.responseHeadersStart()</span><br><span class="line">        &#125;</span><br><span class="line">        response = responseBuilder</span><br><span class="line">            .request(request)</span><br><span class="line">            .handshake(exchange.connection.handshake())</span><br><span class="line">            .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">            .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">            .build()</span><br><span class="line">        code = response.code</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      exchange.responseHeadersEnd(response)</span><br><span class="line"></span><br><span class="line">      response = <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line">        <span class="comment">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span></span><br><span class="line">        response.newBuilder()</span><br><span class="line">            .body(EMPTY_RESPONSE)</span><br><span class="line">            .build()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        response.newBuilder()</span><br><span class="line">            .body(exchange.openResponseBody(response))</span><br><span class="line">            .build()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;close&quot;</span>.equals(response.request.header(<span class="string">&quot;Connection&quot;</span>), ignoreCase = <span class="literal">true</span>) ||</span><br><span class="line">          <span class="string">&quot;close&quot;</span>.equals(response.header(<span class="string">&quot;Connection&quot;</span>), ignoreCase = <span class="literal">true</span>)) &#123;</span><br><span class="line">        exchange.noNewExchangesOnConnection()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body?.contentLength() ?: -<span class="number">1L</span> &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ProtocolException(</span><br><span class="line">            <span class="string">&quot;HTTP <span class="variable">$code</span> had non-zero Content-Length: <span class="subst">$&#123;response.body?.contentLength()&#125;</span>&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> response</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">      <span class="keyword">if</span> (sendRequestException != <span class="literal">null</span>) &#123;</span><br><span class="line">        sendRequestException.addSuppressed(e)</span><br><span class="line">        <span class="keyword">throw</span> sendRequestException</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> e</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面已经和服务器进行了连接，这里是最后一个interceptor，主要是和服务器进行读写操作，获得响应的response<br><strong>至此从服务器拿到了响应的response，然后这个response再层层向之前的interceptor返回，每个intercetor有需要的话再对response进行加工，最后作为整个网络请求的结果交给应用程序</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>OkHttp的核心是链式调用，将网络请求的完整动作交给5个interceptor完成</li>
<li>在ConnectInterceptor里完成了socket的创建和连接</li>
</ul>
]]></content>
      <tags>
        <tag>网络框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Volley源码学习</title>
    <url>/2021/04/25/Volley%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>Volley是Google官方提供的网络请求库，支持Http请求</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>官方demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Instantiate the RequestQueue.</span></span><br><span class="line">    RequestQueue queue = Volley.newRequestQueue(<span class="keyword">this</span>);</span><br><span class="line">    String url =<span class="string">&quot;http://www.google.com&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Request a string response from the provided URL.</span></span><br><span class="line">    StringRequest stringRequest = <span class="keyword">new</span> StringRequest(Request.Method.GET, url,</span><br><span class="line">                <span class="keyword">new</span> Response.Listener&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(String response)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Display the first 500 characters of the response string.</span></span><br><span class="line">            textView.setText(<span class="string">&quot;Response is: &quot;</span>+ response.substring(<span class="number">0</span>,<span class="number">500</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="keyword">new</span> Response.ErrorListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError error)</span> </span>&#123;</span><br><span class="line">            textView.setText(<span class="string">&quot;That didn&#x27;t work!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the request to the RequestQueue.</span></span><br><span class="line">    queue.add(stringRequest);</span><br></pre></td></tr></table></figure>

<p><strong>从用法上看，最关键的类是RequestQueue，下面将从RequestQueue开始进行分析</strong></p>
<h3 id="1-Volley-newRquestQueue"><a href="#1-Volley-newRquestQueue" class="headerlink" title="1.Volley.newRquestQueue()"></a>1.Volley.newRquestQueue()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> newRequestQueue(context, (BaseHttpStack) <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context, BaseHttpStack stack)</span> </span>&#123;</span><br><span class="line">    BasicNetwork network;</span><br><span class="line">    <span class="keyword">if</span> (stack == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">9</span>) &#123;</span><br><span class="line">            network = <span class="keyword">new</span> BasicNetwork(<span class="keyword">new</span> HurlStack());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Prior to Gingerbread, HttpUrlConnection was unreliable.</span></span><br><span class="line">            <span class="comment">// See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html</span></span><br><span class="line">            <span class="comment">// At some point in the future we&#x27;ll move our minSdkVersion past Froyo and can</span></span><br><span class="line">            <span class="comment">// delete this fallback (along with all Apache HTTP code).</span></span><br><span class="line">            String userAgent = <span class="string">&quot;volley/0&quot;</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String packageName = context.getPackageName();</span><br><span class="line">                PackageInfo info =</span><br><span class="line">                        context.getPackageManager().getPackageInfo(packageName, <span class="comment">/* flags= */</span> <span class="number">0</span>);</span><br><span class="line">                userAgent = packageName + <span class="string">&quot;/&quot;</span> + info.versionCode;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NameNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            network =</span><br><span class="line">                    <span class="keyword">new</span> BasicNetwork(</span><br><span class="line">                            <span class="keyword">new</span> HttpClientStack(AndroidHttpClient.newInstance(userAgent)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        network = <span class="keyword">new</span> BasicNetwork(stack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newRequestQueue(context, network);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context, Network network)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Context appContext = context.getApplicationContext();</span><br><span class="line">    <span class="comment">// Use a lazy supplier for the cache directory so that newRequestQueue() can be called on</span></span><br><span class="line">    <span class="comment">// main thread without causing strict mode violation.</span></span><br><span class="line">    DiskBasedCache.FileSupplier cacheSupplier =</span><br><span class="line">            <span class="keyword">new</span> DiskBasedCache.FileSupplier() &#123;</span><br><span class="line">                <span class="keyword">private</span> File cacheDir = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> File <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (cacheDir == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        cacheDir = <span class="keyword">new</span> File(appContext.getCacheDir(), DEFAULT_CACHE_DIR);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> cacheDir;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">    RequestQueue queue = <span class="keyword">new</span> RequestQueue(<span class="keyword">new</span> DiskBasedCache(cacheSupplier), network);</span><br><span class="line">    queue.start();</span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>过程中涉及到以下几个关键类的创建：</p>
<ul>
<li>BasicNetwork</li>
<li>DiskBasedCache<br>下面了解下这几个类的作用和初始化过程</li>
</ul>
<h3 id="1-1-BasicNetwork"><a href="#1-1-BasicNetwork" class="headerlink" title="1.1 BasicNetwork"></a>1.1 BasicNetwork</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BasicNetwork</span><span class="params">(BaseHttpStack httpStack)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If a pool isn&#x27;t passed in, then build a small default pool that will give us a lot of</span></span><br><span class="line">    <span class="comment">// benefit and not use too much memory.</span></span><br><span class="line">    <span class="keyword">this</span>(httpStack, <span class="keyword">new</span> ByteArrayPool(DEFAULT_POOL_SIZE));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BasicNetwork</span><span class="params">(BaseHttpStack httpStack, ByteArrayPool pool)</span> </span>&#123;</span><br><span class="line">    mBaseHttpStack = httpStack;</span><br><span class="line">    mHttpStack = httpStack;</span><br><span class="line">    mPool = pool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BasicNetwork的构造过程仅仅是将传入的BaseHttpStack和ByteArrayPool进行设置，而前面在构建BasicNetwork时传入的BaseHttpStack的实现类是HurlStack，下面看下HurlStack的具体实现。</p>
<h3 id="1-1-1-HurlStack"><a href="#1-1-1-HurlStack" class="headerlink" title="1.1.1 HurlStack"></a>1.1.1 HurlStack</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HurlStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="comment">/* urlRewriter = */</span> <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HurlStack</span><span class="params">(UrlRewriter urlRewriter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(urlRewriter, <span class="comment">/* sslSocketFactory = */</span> <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HurlStack</span><span class="params">(UrlRewriter urlRewriter, SSLSocketFactory sslSocketFactory)</span> </span>&#123;</span><br><span class="line">    mUrlRewriter = urlRewriter;</span><br><span class="line">    mSslSocketFactory = sslSocketFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Hurl的构造过程也仅仅是对成员变量进行设置，而且目前用户代码传入的都是null。</p>
<h3 id="1-2-DiskBasedCache"><a href="#1-2-DiskBasedCache" class="headerlink" title="1.2 DiskBasedCache"></a>1.2 DiskBasedCache</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DiskBasedCache</span><span class="params">(FileSupplier rootDirectorySupplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(rootDirectorySupplier, DEFAULT_DISK_USAGE_BYTES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DiskBasedCache</span><span class="params">(FileSupplier rootDirectorySupplier, <span class="keyword">int</span> maxCacheSizeInBytes)</span> </span>&#123;</span><br><span class="line">    mRootDirectorySupplier = rootDirectorySupplier;</span><br><span class="line">    mMaxCacheSizeInBytes = maxCacheSizeInBytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DiskBasedCache的构造函数也只是对成员变量进行设置，这里传入的FileSuppiler会提供一个File，看类名也可以猜测到这个File的作用是作为磁盘缓存的文件。</p>
<h3 id="1-3-RequestQueue-start"><a href="#1-3-RequestQueue-start" class="headerlink" title="1.3 RequestQueue.start()"></a>1.3 RequestQueue.start()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stop(); <span class="comment">// Make sure any currently running dispatchers are stopped.</span></span><br><span class="line">    <span class="comment">// Create the cache dispatcher and start it.</span></span><br><span class="line">    mCacheDispatcher = <span class="keyword">new</span> CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</span><br><span class="line">    mCacheDispatcher.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create network dispatchers (and corresponding threads) up to the pool size.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mDispatchers.length; i++) &#123;</span><br><span class="line">        NetworkDispatcher networkDispatcher =</span><br><span class="line">                <span class="keyword">new</span> NetworkDispatcher(mNetworkQueue, mNetwork, mCache, mDelivery);</span><br><span class="line">        mDispatchers[i] = networkDispatcher;</span><br><span class="line">        networkDispatcher.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>涉及到CacheDispatcher和NetworkDispatcher的start()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheDispatcher</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkDispatcher</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br></pre></td></tr></table></figure>
<p>这两个Dispatcher都是Thread的子类，从这里可以看到Volley开启了多线程。</p>
<p>从官方用法中看出，构造RequestQueue之后，是通过add一个StringRequest进行网络请求，接下来看下StringRequest的相关代码。</p>
<h3 id="2-StringRequest"><a href="#2-StringRequest" class="headerlink" title="2.StringRequest"></a>2.StringRequest</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringRequest</span> <span class="keyword">extends</span> <span class="title">Request</span>&lt;<span class="title">String</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>继承自Request类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> method,</span></span></span><br><span class="line"><span class="function"><span class="params">            String url,</span></span></span><br><span class="line"><span class="function"><span class="params">            Listener&lt;String&gt; listener,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@Nullable</span> ErrorListener errorListener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(method, url, errorListener);</span><br><span class="line">        mListener = listener;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>构造函数需要传入两个listener，分别是正常返回的listener和异常返回的listener</p>
<h3 id="2-1-Listener"><a href="#2-1-Listener" class="headerlink" title="2.1 Listener"></a>2.1 Listener</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Listener</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(T response)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-ErrorListener"><a href="#2-2-ErrorListener" class="headerlink" title="2.2 ErrorListener"></a>2.2 ErrorListener</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ErrorListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError error)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-Request"><a href="#2-3-Request" class="headerlink" title="2.3 Request"></a>2.3 Request</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Request</span><span class="params">(<span class="keyword">int</span> method, String url, <span class="meta">@Nullable</span> Response.ErrorListener errorListener)</span> </span>&#123;</span><br><span class="line">    mMethod = method;</span><br><span class="line">    mUrl = url;</span><br><span class="line">    mErrorListener = errorListener;</span><br><span class="line">    setRetryPolicy(<span class="keyword">new</span> DefaultRetryPolicy());</span><br><span class="line"></span><br><span class="line">    mDefaultTrafficStatsTag = findDefaultTrafficStatsTag(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看到在StringRequest的父类Request的构造函数中，记录了这个请求对应的方法和url，并且进行了重试策略的设置</p>
<p><strong>在StringRequest对象构造出来后，通过RequestQueue的add(Request request)方法发出，看下这个方法的执行链路</strong></p>
<h3 id="3-RequestQueue-add-Request-request"><a href="#3-RequestQueue-add-Request-request" class="headerlink" title="3.RequestQueue.add(Request request)"></a>3.RequestQueue.add(Request request)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Request&lt;T&gt; <span class="title">add</span><span class="params">(Request&lt;T&gt; request)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Tag the request as belonging to this queue and add it to the set of current requests.</span></span><br><span class="line">    request.setRequestQueue(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (mCurrentRequests) &#123;</span><br><span class="line">        mCurrentRequests.add(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process requests in the order they are added.</span></span><br><span class="line">    request.setSequence(getSequenceNumber());</span><br><span class="line">    request.addMarker(<span class="string">&quot;add-to-queue&quot;</span>);</span><br><span class="line">    sendRequestEvent(request, RequestEvent.REQUEST_QUEUED);</span><br><span class="line"></span><br><span class="line">    beginRequest(request);</span><br><span class="line">    <span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>标记这个request的queue为当前queue</li>
<li>将这个request加入到当前记录的mCurrentRequests对象中</li>
<li>调用sendRequestEvent()方法</li>
<li>调用beginRequest方法</li>
</ul>
<h3 id="3-1-RequestQueue-sendRequestEvent"><a href="#3-1-RequestQueue-sendRequestEvent" class="headerlink" title="3.1 RequestQueue.sendRequestEvent()"></a>3.1 RequestQueue.sendRequestEvent()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendRequestEvent</span><span class="params">(Request&lt;?&gt; request, <span class="meta">@RequestEvent</span> <span class="keyword">int</span> event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mEventListeners) &#123;</span><br><span class="line">        <span class="keyword">for</span> (RequestEventListener listener : mEventListeners) &#123;</span><br><span class="line">            listener.onRequestEvent(request, event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法作用是通知当前的RequestEventListener，有request的事件产生，前面用户代码传入的是RequestEvent.REQUEST_QUEUED这个事件，代表有request加入队列</p>
<h3 id="3-2-RequestQueue-beginRequest-Request-request"><a href="#3-2-RequestQueue-beginRequest-Request-request" class="headerlink" title="3.2 RequestQueue.beginRequest(Request request)"></a>3.2 RequestQueue.beginRequest(Request request)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">beginRequest</span><span class="params">(Request&lt;T&gt; request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// If the request is uncacheable, skip the cache queue and go straight to the network.</span></span><br><span class="line">        <span class="keyword">if</span> (!request.shouldCache()) &#123;</span><br><span class="line">            sendRequestOverNetwork(request);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mCacheQueue.add(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>会调用到sendRequestOverNetwork(Request request)，看这个函数名，我们很接近真正发送请求的地方了！</p>
<h3 id="3-2-1-sendRequestOverNetwork-Request-request"><a href="#3-2-1-sendRequestOverNetwork-Request-request" class="headerlink" title="3.2.1 sendRequestOverNetwork(Request request)"></a>3.2.1 sendRequestOverNetwork(Request request)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sendRequestOverNetwork</span><span class="params">(Request&lt;T&gt; request)</span> </span>&#123;</span><br><span class="line">    mNetworkQueue.add(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这里有点失望，原来只是加入了网络队列中，那继续看下这个队列被消费时的场景</p>
<h3 id="3-3-NetworkDispatcher-processRequest"><a href="#3-3-NetworkDispatcher-processRequest" class="headerlink" title="3.3 NetworkDispatcher.processRequest()"></a>3.3 NetworkDispatcher.processRequest()</h3><p>找了一下，这个队列就是前面我们构造NetworkDispatcher时传入的队列，而这个队列被消费的场景就是在processRequest()方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// Take a request from the queue.</span></span><br><span class="line">    Request&lt;?&gt; request = mQueue.take();</span><br><span class="line">    processRequest(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从队列中取出一个request然后调用到processRequest(Request request)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(Request&lt;?&gt; request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Perform the network request.</span></span><br><span class="line">        NetworkResponse networkResponse = mNetwork.performRequest(request);</span><br><span class="line">        request.addMarker(<span class="string">&quot;network-http-complete&quot;</span>);</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</span><br><span class="line">            request.finish(<span class="string">&quot;not-modified&quot;</span>);</span><br><span class="line">            request.notifyListenerResponseNotUsable();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Parse the response here on the worker thread.</span></span><br><span class="line">        Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</span><br><span class="line">        request.addMarker(<span class="string">&quot;network-parse-complete&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write to cache if applicable.</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Only update cache metadata instead of entire record for 304s.</span></span><br><span class="line">        <span class="keyword">if</span> (request.shouldCache() &amp;&amp; response.cacheEntry != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mCache.put(request.getCacheKey(), response.cacheEntry);</span><br><span class="line">            request.addMarker(<span class="string">&quot;network-cache-written&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Post the response back.</span></span><br><span class="line">        request.markDelivered();</span><br><span class="line">        mDelivery.postResponse(request, response);</span><br><span class="line">        request.notifyListenerResponseReceived(response);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (VolleyError volleyError) &#123;</span><br><span class="line">        volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</span><br><span class="line">        parseAndDeliverNetworkError(request, volleyError);</span><br><span class="line">        request.notifyListenerResponseNotUsable();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原代码有点长，删减后的关键代码如上，主要有以下几个操作</p>
<ul>
<li>通过Network.performRequest()方法获取到NetworkResponse</li>
<li>对原始的NetworkResponse进行parse操作得到Response</li>
<li>通过ResponseDelivery将Response post到对应的地方</li>
</ul>
<p>下面逐个看下这些操作</p>
<h3 id="3-3-1-Network-performRequest"><a href="#3-3-1-Network-performRequest" class="headerlink" title="3.3.1 Network.performRequest()"></a>3.3.1 Network.performRequest()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> NetworkResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</span><br><span class="line">     <span class="keyword">long</span> requestStart = SystemClock.elapsedRealtime();</span><br><span class="line">     <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">         HttpResponse httpResponse = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">byte</span>[] responseContents = <span class="keyword">null</span>;</span><br><span class="line">         List&lt;Header&gt; responseHeaders = Collections.emptyList();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// Gather headers.</span></span><br><span class="line">             Map&lt;String, String&gt; additionalRequestHeaders =</span><br><span class="line">                     HttpHeaderParser.getCacheHeaders(request.getCacheEntry());</span><br><span class="line">             httpResponse = mBaseHttpStack.executeRequest(request, additionalRequestHeaders);</span><br><span class="line">             <span class="keyword">int</span> statusCode = httpResponse.getStatusCode();</span><br><span class="line"></span><br><span class="line">             responseHeaders = httpResponse.getHeaders();</span><br><span class="line">             <span class="comment">// Handle cache validation.</span></span><br><span class="line">             <span class="keyword">if</span> (statusCode == HttpURLConnection.HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">                 <span class="keyword">long</span> requestDuration = SystemClock.elapsedRealtime() - requestStart;</span><br><span class="line">                 <span class="keyword">return</span> NetworkUtility.getNotModifiedNetworkResponse(</span><br><span class="line">                         request, requestDuration, responseHeaders);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// Some responses such as 204s do not have content.  We must check.</span></span><br><span class="line">             InputStream inputStream = httpResponse.getContent();</span><br><span class="line">             <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 responseContents =</span><br><span class="line">                         NetworkUtility.inputStreamToBytes(</span><br><span class="line">                                 inputStream, httpResponse.getContentLength(), mPool);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">// Add 0 byte response as a way of honestly representing a</span></span><br><span class="line">                 <span class="comment">// no-content request.</span></span><br><span class="line">                 responseContents = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// if the request is slow, log it.</span></span><br><span class="line">             <span class="keyword">long</span> requestLifetime = SystemClock.elapsedRealtime() - requestStart;</span><br><span class="line">             NetworkUtility.logSlowRequests(</span><br><span class="line">                     requestLifetime, request, responseContents, statusCode);</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (statusCode &lt; <span class="number">200</span> || statusCode &gt; <span class="number">299</span>) &#123;</span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(</span><br><span class="line">                     statusCode,</span><br><span class="line">                     responseContents,</span><br><span class="line">                     <span class="comment">/* notModified= */</span> <span class="keyword">false</span>,</span><br><span class="line">                     SystemClock.elapsedRealtime() - requestStart,</span><br><span class="line">                     responseHeaders);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">             <span class="comment">// This will either throw an exception, breaking us from the loop, or will loop</span></span><br><span class="line">             <span class="comment">// again and retry the request.</span></span><br><span class="line">             RetryInfo retryInfo =</span><br><span class="line">                     NetworkUtility.shouldRetryException(</span><br><span class="line">                             request, e, requestStart, httpResponse, responseContents);</span><br><span class="line">             <span class="comment">// We should already be on a background thread, so we can invoke the retry inline.</span></span><br><span class="line">             NetworkUtility.attemptRetryOnException(request, retryInfo);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>函数约50行，但关键代码主要是第9行，后面都是对拿到的HttpResponse进行操作和检查，下面进到第9行的httpResponse = mBaseHttpStack.executeRequest(request, additionalRequestHeaders);</p>
<h3 id="3-3-1-1-HurlStack-executeRequest"><a href="#3-3-1-1-HurlStack-executeRequest" class="headerlink" title="3.3.1.1 HurlStack.executeRequest()"></a>3.3.1.1 HurlStack.executeRequest()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HttpResponse <span class="title">executeRequest</span><span class="params">(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, AuthFailureError </span>&#123;</span><br><span class="line">    String url = request.getUrl();</span><br><span class="line">    HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.putAll(additionalHeaders);</span><br><span class="line">    <span class="comment">// Request.getHeaders() takes precedence over the given additional (cache) headers).</span></span><br><span class="line">    map.putAll(request.getHeaders());</span><br><span class="line">    <span class="keyword">if</span> (mUrlRewriter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String rewritten = mUrlRewriter.rewriteUrl(url);</span><br><span class="line">        <span class="keyword">if</span> (rewritten == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;URL blocked by rewriter: &quot;</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line">        url = rewritten;</span><br><span class="line">    &#125;</span><br><span class="line">    URL parsedUrl = <span class="keyword">new</span> URL(url);</span><br><span class="line">    HttpURLConnection connection = openConnection(parsedUrl, request);</span><br><span class="line">    <span class="keyword">boolean</span> keepConnectionOpen = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String headerName : map.keySet()) &#123;</span><br><span class="line">            connection.setRequestProperty(headerName, map.get(headerName));</span><br><span class="line">        &#125;</span><br><span class="line">        setConnectionParametersForRequest(connection, request);</span><br><span class="line">        <span class="comment">// Initialize HttpResponse with data from the HttpURLConnection.</span></span><br><span class="line">        <span class="keyword">int</span> responseCode = connection.getResponseCode();</span><br><span class="line">        <span class="keyword">if</span> (responseCode == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// -1 is returned by getResponseCode() if the response code could not be retrieved.</span></span><br><span class="line">            <span class="comment">// Signal to the caller that something was wrong with the connection.</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Could not retrieve response code from HttpUrlConnection.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!hasResponseBody(request.getMethod(), responseCode)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HttpResponse(responseCode, convertHeaders(connection.getHeaderFields()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Need to keep the connection open until the stream is consumed by the caller. Wrap the</span></span><br><span class="line">        <span class="comment">// stream such that close() will disconnect the connection.</span></span><br><span class="line">        keepConnectionOpen = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpResponse(</span><br><span class="line">                responseCode,</span><br><span class="line">                convertHeaders(connection.getHeaderFields()),</span><br><span class="line">                connection.getContentLength(),</span><br><span class="line">                createInputStream(request, connection));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!keepConnectionOpen) &#123;</span><br><span class="line">            connection.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又是大约50行的实现，这里已经看到了Volley是如何进行一个请求的，答案就是<strong>通过Android库中自带的HttpURLConnection来进行实际的请求操作；最后也是通过HttpURLConnection的内容进行HttpResponse的构建</strong>。</p>
<p>回到3.3中说的，拿到原始的HttpResponse之后要进行一次parse操作得到最终的Response</p>
<h3 id="3-3-2-StringRequest-parseNetworkResponse-NetworkResponse-response"><a href="#3-3-2-StringRequest-parseNetworkResponse-NetworkResponse-response" class="headerlink" title="3.3.2 StringRequest.parseNetworkResponse(NetworkResponse response)"></a>3.3.2 StringRequest.parseNetworkResponse(NetworkResponse response)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Response&lt;String&gt; <span class="title">parseNetworkResponse</span><span class="params">(NetworkResponse response)</span> </span>&#123;</span><br><span class="line">    String parsed;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        parsed = <span class="keyword">new</span> String(response.data, HttpHeaderParser.parseCharset(response.headers));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="comment">// Since minSdkVersion = 8, we can&#x27;t call</span></span><br><span class="line">        <span class="comment">// new String(response.data, Charset.defaultCharset())</span></span><br><span class="line">        <span class="comment">// So suppress the warning instead.</span></span><br><span class="line">        parsed = <span class="keyword">new</span> String(response.data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过原始的Response的data字段，和headers中指定的charset来构建出String对象，最后通过String对象构建出Response</p>
<p>parse出最终的Response之后，要将这个response post到需要的地方</p>
<h3 id="3-3-3-ExecutorDelivery"><a href="#3-3-3-ExecutorDelivery" class="headerlink" title="3.3.3 ExecutorDelivery"></a>3.3.3 ExecutorDelivery</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response)</span> </span>&#123;</span><br><span class="line">    postResponse(request, response, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</span> </span>&#123;</span><br><span class="line">    request.markDelivered();</span><br><span class="line">    request.addMarker(<span class="string">&quot;post-response&quot;</span>);</span><br><span class="line">    mResponsePoster.execute(<span class="keyword">new</span> ResponseDeliveryRunnable(request, response, runnable));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的mResponsePoster只是一个Executor，因此excute方法执行的实际上是ResponseDeliveryRunnable的run()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mRequest.isCanceled()) &#123;</span><br><span class="line">            mRequest.finish(<span class="string">&quot;canceled-at-delivery&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Deliver a normal response or error, depending.</span></span><br><span class="line">        <span class="keyword">if</span> (mResponse.isSuccess()) &#123;</span><br><span class="line">            mRequest.deliverResponse(mResponse.result);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mRequest.deliverError(mResponse.error);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终实际上是通过request自己的mRequest.deliverResponse()方法执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">deliverResponse</span><span class="params">(String response)</span> </span>&#123;</span><br><span class="line">    Response.Listener&lt;String&gt; listener;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        listener = mListener;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">        listener.onResponse(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在StringRequest中这个deliverResponse()方法就触发了最早用户代码传入的listner的onResponse方法啦！</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Volley实际的网络请求是通过HttpURLConnection来进行的</li>
<li>Volley最大的作用是帮助用户代码更好地调度网络请求</li>
</ul>
]]></content>
      <tags>
        <tag>网络框架</tag>
      </tags>
  </entry>
  <entry>
    <title>android-async-http源码学习</title>
    <url>/2021/04/26/android-async-http%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>android-async-http是loopj开源的一款网络请求库，可以说是最早出现的Android网络请求库，虽然目前作者已经不再维护，并且Android也放弃了其底层支持HttpClient，但作为Android平台网络请求库的鼻祖，其设计思想还是值得学习。</p>
<h3 id="使用（来自官方文档）"><a href="#使用（来自官方文档）" class="headerlink" title="使用（来自官方文档）"></a>使用（来自官方文档）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.loopj.android.http.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwitterRestClient</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BASE_URL = <span class="string">&quot;https://api.twitter.com/1/&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> AsyncHttpClient client = <span class="keyword">new</span> AsyncHttpClient();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String url, RequestParams params, AsyncHttpResponseHandler responseHandler)</span> </span>&#123;</span><br><span class="line">      client.get(getAbsoluteUrl(url), params, responseHandler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(String url, RequestParams params, AsyncHttpResponseHandler responseHandler)</span> </span>&#123;</span><br><span class="line">      client.post(getAbsoluteUrl(url), params, responseHandler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getAbsoluteUrl</span><span class="params">(String relativeUrl)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> BASE_URL + relativeUrl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从官方的使用介绍来看，只要调用AsyncHttpClient的get()方法传入url、参数和handler即可完成一次http的get请求，因此源码学习从AsyncHttpClient入手</p>
<h3 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1.构造函数"></a>1.构造函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncHttpClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>, <span class="number">80</span>, <span class="number">443</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncHttpClient</span><span class="params">(<span class="keyword">int</span> httpPort)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>, httpPort, <span class="number">443</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncHttpClient</span><span class="params">(<span class="keyword">int</span> httpPort, <span class="keyword">int</span> httpsPort)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>, httpPort, httpsPort);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncHttpClient</span><span class="params">(<span class="keyword">boolean</span> fixNoHttpResponseException, <span class="keyword">int</span> httpPort, <span class="keyword">int</span> httpsPort)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(getDefaultSchemeRegistry(fixNoHttpResponseException, httpPort, httpsPort));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>0~3个参数的构造函数实际上就是对应不同的默认值，如果都没有设置，默认情况下http请求使用80端口，https请求使用443端口；最终都会调用到public AsyncHttpClient(SchemeRegistry schemeRegistry)这个构造函数，首先看下默认传入的schemeRegistry是什么东西：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SchemeRegistry <span class="title">getDefaultSchemeRegistry</span><span class="params">(<span class="keyword">boolean</span> fixNoHttpResponseException, <span class="keyword">int</span> httpPort, <span class="keyword">int</span> httpsPort)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">    <span class="comment">// Fix to SSL flaw in API &lt; ICS</span></span><br><span class="line">    <span class="comment">// See https://code.google.com/p/android/issues/detail?id=13117</span></span><br><span class="line">    SSLSocketFactory sslSocketFactory;</span><br><span class="line">    <span class="keyword">if</span> (fixNoHttpResponseException) &#123;</span><br><span class="line">        sslSocketFactory = MySSLSocketFactory.getFixedSocketFactory();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sslSocketFactory = SSLSocketFactory.getSocketFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SchemeRegistry schemeRegistry = <span class="keyword">new</span> SchemeRegistry();</span><br><span class="line">    schemeRegistry.register(<span class="keyword">new</span> Scheme(<span class="string">&quot;http&quot;</span>, PlainSocketFactory.getSocketFactory(), httpPort));</span><br><span class="line">    schemeRegistry.register(<span class="keyword">new</span> Scheme(<span class="string">&quot;https&quot;</span>, sslSocketFactory, httpsPort));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> schemeRegistry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建出SchemeRegistry对象，并且把http和https对应的SocketFactory注册给SchemeRegistry对象，而SchemeRegistry对象的构造函数也很简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SchemeRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    registeredSchemes = <span class="keyword">new</span> ConcurrentHashMap&lt;String,Scheme&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>言归正传，继续回到AsyncHttpClient真正的构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncHttpClient</span><span class="params">(SchemeRegistry schemeRegistry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    BasicHttpParams httpParams = <span class="keyword">new</span> BasicHttpParams();</span><br><span class="line"></span><br><span class="line">    ConnManagerParams.setTimeout(httpParams, connectTimeout);</span><br><span class="line">    ConnManagerParams.setMaxConnectionsPerRoute(httpParams, <span class="keyword">new</span> ConnPerRouteBean(maxConnections));</span><br><span class="line">    ConnManagerParams.setMaxTotalConnections(httpParams, DEFAULT_MAX_CONNECTIONS);</span><br><span class="line"></span><br><span class="line">    HttpConnectionParams.setSoTimeout(httpParams, responseTimeout);</span><br><span class="line">    HttpConnectionParams.setConnectionTimeout(httpParams, connectTimeout);</span><br><span class="line">    HttpConnectionParams.setTcpNoDelay(httpParams, <span class="keyword">true</span>);</span><br><span class="line">    HttpConnectionParams.setSocketBufferSize(httpParams, DEFAULT_SOCKET_BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">    HttpProtocolParams.setVersion(httpParams, HttpVersion.HTTP_1_1);</span><br><span class="line"></span><br><span class="line">    ClientConnectionManager cm = createConnectionManager(schemeRegistry, httpParams);</span><br><span class="line">    Utils.asserts(cm != <span class="keyword">null</span>, <span class="string">&quot;Custom implementation of #createConnectionManager(SchemeRegistry, BasicHttpParams) returned null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    threadPool = getDefaultThreadPool();</span><br><span class="line">    requestMap = Collections.synchronizedMap(<span class="keyword">new</span> WeakHashMap&lt;Context, List&lt;RequestHandle&gt;&gt;());</span><br><span class="line">    clientHeaderMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">    httpContext = <span class="keyword">new</span> SyncBasicHttpContext(<span class="keyword">new</span> BasicHttpContext());</span><br><span class="line">    httpClient = <span class="keyword">new</span> DefaultHttpClient(cm, httpParams);</span><br><span class="line">    httpClient.addRequestInterceptor(<span class="keyword">new</span> HttpRequestInterceptor() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(HttpRequest request, HttpContext context)</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ……</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    httpClient.addResponseInterceptor(<span class="keyword">new</span> HttpResponseInterceptor() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(HttpResponse response, HttpContext context)</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ……</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    httpClient.addRequestInterceptor(<span class="keyword">new</span> HttpRequestInterceptor() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">final</span> HttpRequest request, <span class="keyword">final</span> HttpContext context)</span> <span class="keyword">throws</span> HttpException, IOException </span>&#123;</span><br><span class="line">            <span class="comment">// ……</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    httpClient.setHttpRequestRetryHandler(<span class="keyword">new</span> RetryHandler(DEFAULT_MAX_RETRIES, DEFAULT_RETRY_SLEEP_TIME_MILLIS));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要进行了以下几个操作：</p>
<ul>
<li>调用ConnManagerParams、HttpConnectionParams、HttpProtocolParams的静态方法进行参数设置</li>
<li>创建出了线程池</li>
<li>创建线程同步的Map记录request</li>
<li>创建出了HttpClient对象</li>
<li>为httpClient对象添加了多个requestInterceptor</li>
<li>为httpClient对象设置了请求重试的handler</li>
</ul>
<h3 id="2-get请求"><a href="#2-get请求" class="headerlink" title="2.get请求"></a>2.get请求</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequestHandle <span class="title">get</span><span class="params">(String url, RequestParams params, ResponseHandlerInterface responseHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(<span class="keyword">null</span>, url, params, responseHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequestHandle <span class="title">get</span><span class="params">(Context context, String url, RequestParams params, ResponseHandlerInterface responseHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendRequest(httpClient, httpContext, <span class="keyword">new</span> HttpGet(getUrlWithQueryString(isUrlEncodingEnabled, url, params)), <span class="keyword">null</span>, responseHandler, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequestHandle <span class="title">get</span><span class="params">(Context context, String url, RequestParams params, ResponseHandlerInterface responseHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendRequest(httpClient, httpContext, <span class="keyword">new</span> HttpGet(getUrlWithQueryString(isUrlEncodingEnabled, url, params)), <span class="keyword">null</span>, responseHandler, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后是转到sendRequest()方法进行请求发送</p>
<h3 id="3-sendRequest"><a href="#3-sendRequest" class="headerlink" title="3.sendRequest()"></a>3.sendRequest()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RequestHandle <span class="title">sendRequest</span><span class="params">(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, ResponseHandlerInterface responseHandler, Context context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">    <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (uriRequest <span class="keyword">instanceof</span> HttpEntityEnclosingRequestBase &amp;&amp; ((HttpEntityEnclosingRequestBase) uriRequest).getEntity() != <span class="keyword">null</span> &amp;&amp; uriRequest.containsHeader(HEADER_CONTENT_TYPE)) &#123;</span><br><span class="line">            log.w(LOG_TAG, <span class="string">&quot;Passed contentType will be ignored because HttpEntity sets content type&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            uriRequest.setHeader(HEADER_CONTENT_TYPE, contentType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    responseHandler.setRequestHeaders(uriRequest.getAllHeaders());</span><br><span class="line">    responseHandler.setRequestURI(uriRequest.getURI());</span><br><span class="line"></span><br><span class="line">    AsyncHttpRequest request = newAsyncHttpRequest(client, httpContext, uriRequest, contentType, responseHandler, context);</span><br><span class="line">    threadPool.submit(request);</span><br><span class="line">    RequestHandle requestHandle = <span class="keyword">new</span> RequestHandle(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">        List&lt;RequestHandle&gt; requestList;</span><br><span class="line">        <span class="comment">// Add request to request map</span></span><br><span class="line">        <span class="keyword">synchronized</span> (requestMap) &#123;</span><br><span class="line">            requestList = requestMap.get(context);</span><br><span class="line">            <span class="keyword">if</span> (requestList == <span class="keyword">null</span>) &#123;</span><br><span class="line">                requestList = Collections.synchronizedList(<span class="keyword">new</span> LinkedList&lt;RequestHandle&gt;());</span><br><span class="line">                requestMap.put(context, requestList);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        requestList.add(requestHandle);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;RequestHandle&gt; iterator = requestList.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (iterator.next().shouldBeGarbageCollected()) &#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> requestHandle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段函数中，最主要的工作是创建出了一个AsyncHttpRequest，然后submit到threadPool线程池中，由此可以推断这个AsyncHttpRequest是一个Runnable对象，因此转到AsyncHttpRequest的run()函数中。</p>
<h3 id="3-1-AsyncHttpRequest-run"><a href="#3-1-AsyncHttpRequest-run" class="headerlink" title="3.1 AsyncHttpRequest.run()"></a>3.1 AsyncHttpRequest.run()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Carry out pre-processing for this request only once.</span></span><br><span class="line">    <span class="keyword">if</span> (!isRequestPreProcessed) &#123;</span><br><span class="line">        isRequestPreProcessed = <span class="keyword">true</span>;</span><br><span class="line">        onPreProcessRequest(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    responseHandler.sendStartMessage();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        makeRequestWithRetries();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isCancelled()) &#123;</span><br><span class="line">            responseHandler.sendFailureMessage(<span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            AsyncHttpClient.log.e(<span class="string">&quot;AsyncHttpRequest&quot;</span>, <span class="string">&quot;makeRequestWithRetries returned error&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    responseHandler.sendFinishMessage();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Carry out post-processing for this request.</span></span><br><span class="line">    onPostProcessRequest(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    isFinished = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段函数中多次调用isCancelled()来检查请求有没有被取消，除去这些检查代码，就是对onPreProcessRequest()、onPostProcessRequest()的调用，以及对responseHandler在请求发送前和发送后调用sendStartMessage()和sendFinishMessage()来发送通知<br>而真正进行请求发送的操作是调用makeRequestWithRetries()函数</p>
<h3 id="3-1-1-makeRequestWithRetries"><a href="#3-1-1-makeRequestWithRetries" class="headerlink" title="3.1.1 makeRequestWithRetries()"></a>3.1.1 makeRequestWithRetries()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeRequestWithRetries</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> retry = <span class="keyword">true</span>;</span><br><span class="line">    IOException cause = <span class="keyword">null</span>;</span><br><span class="line">    HttpRequestRetryHandler retryHandler = client.getHttpRequestRetryHandler();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (retry) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                makeRequest();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">                <span class="comment">// switching between WI-FI and mobile data networks can cause a retry which then results in an UnknownHostException</span></span><br><span class="line">                <span class="comment">// while the WI-FI is initialising. The retry logic will be invoked here, if this is NOT the first retry</span></span><br><span class="line">                <span class="comment">// (to assist in genuine cases of unknown host) which seems better than outright failure</span></span><br><span class="line">                cause = <span class="keyword">new</span> IOException(<span class="string">&quot;UnknownHostException exception: &quot;</span> + e.getMessage(), e);</span><br><span class="line">                retry = (executionCount &gt; <span class="number">0</span>) &amp;&amp; retryHandler.retryRequest(e, ++executionCount, context);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">                <span class="comment">// there&#x27;s a bug in HttpClient 4.0.x that on some occasions causes</span></span><br><span class="line">                <span class="comment">// DefaultRequestExecutor to throw an NPE, see</span></span><br><span class="line">                <span class="comment">// https://code.google.com/p/android/issues/detail?id=5255</span></span><br><span class="line">                cause = <span class="keyword">new</span> IOException(<span class="string">&quot;NPE in HttpClient: &quot;</span> + e.getMessage());</span><br><span class="line">                retry = retryHandler.retryRequest(cause, ++executionCount, context);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">                    <span class="comment">// Eating exception, as the request was cancelled</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cause = e;</span><br><span class="line">                retry = retryHandler.retryRequest(cause, ++executionCount, context);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (retry) &#123;</span><br><span class="line">                responseHandler.sendRetryMessage(executionCount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// catch anything else to ensure failure message is propagated</span></span><br><span class="line">        AsyncHttpClient.log.e(<span class="string">&quot;AsyncHttpRequest&quot;</span>, <span class="string">&quot;Unhandled exception origin cause&quot;</span>, e);</span><br><span class="line">        cause = <span class="keyword">new</span> IOException(<span class="string">&quot;Unhandled exception: &quot;</span> + e.getMessage(), cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cleaned up to throw IOException</span></span><br><span class="line">    <span class="keyword">throw</span> (cause);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数里面其实是重试逻辑的实现：通过一个while循环搭配上try-catch代码块，如果请求没有异常，则跳出这个循环；有异常的话则在catch中进行重试的准备和通知操作，然后通过while的下一次循环完成重试<br>而真正发送请求的是makeRequest()函数</p>
<h3 id="3-1-1-1-makeRequest"><a href="#3-1-1-1-makeRequest" class="headerlink" title="3.1.1.1 makeRequest()"></a>3.1.1.1 makeRequest()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fixes #115</span></span><br><span class="line">    <span class="keyword">if</span> (request.getURI().getScheme() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// subclass of IOException so processed in the caller</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MalformedURLException(<span class="string">&quot;No valid URI scheme was provided&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (responseHandler <span class="keyword">instanceof</span> RangeFileAsyncHttpResponseHandler) &#123;</span><br><span class="line">        ((RangeFileAsyncHttpResponseHandler) responseHandler).updateRequestHeaders(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HttpResponse response = client.execute(request, context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Carry out pre-processing for this response.</span></span><br><span class="line">    responseHandler.onPreProcessResponse(responseHandler, response);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The response is ready, handle it.</span></span><br><span class="line">    responseHandler.sendResponseMessage(response);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Carry out post-processing for this response.</span></span><br><span class="line">    responseHandler.onPostProcessResponse(responseHandler, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和前面提到过的AsyncHttpRequest.run()方法是一样的，除去多次的isCancelled()检查以及请求前后的responseHandler通知方法回调以外，真正进行网络请求的代码是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpResponse response = client.execute(request, context);</span><br></pre></td></tr></table></figure>
<p>这里的client是HttpClient的实例，因此到这里就基本完成android-async-http的工作了，往后的真正网络请求发出是通过HttpClient进行的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>严格来说android-async-http是一个网络请求管理库，而不是网络请求库，因为最终网络请求的工作是交由HttpClient进行，android-async-http做的工作主要有以下这些：</p>
<ul>
<li>通过线程池进行并发请求的管理</li>
<li>通过responseHandler在请求发送的对应时机进行和主线程的消息传递，更加方便用户代码操作</li>
<li>通过while循环+try-catch实现了重试机制</li>
</ul>
]]></content>
      <tags>
        <tag>网络框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Retrofit之Call对象</title>
    <url>/2021/05/06/Retrofit%E4%B9%8BCall%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>在上一篇《Retrofit源码学习》中已经了解了Retrofit是如何将一个http请求通过java接口的形式提供Call对象给用户代码，接下来看下如何使用这个Call对象。</p>
<h3 id="Call的使用"><a href="#Call的使用" class="headerlink" title="Call的使用"></a>Call的使用</h3><p>在retrofit的项目里，作者提供了一些samples，其中SimpleService的用法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Retrofit retrofit =</span><br><span class="line">    <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">        .baseUrl(API_URL)</span><br><span class="line">        .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create an instance of our GitHub API interface.</span></span><br><span class="line">GitHub github = retrofit.create(GitHub.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a call instance for looking up Retrofit contributors.</span></span><br><span class="line">Call&lt;List&lt;Contributor&gt;&gt; call = github.contributors(<span class="string">&quot;square&quot;</span>, <span class="string">&quot;retrofit&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fetch and print a list of the contributors to the library.</span></span><br><span class="line">List&lt;Contributor&gt; contributors = call.execute().body();</span><br><span class="line"><span class="keyword">for</span> (Contributor contributor : contributors) &#123;</span><br><span class="line">  System.out.println(contributor.login + <span class="string">&quot; (&quot;</span> + contributor.contributions + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这里可以看到，Call&lt;T&gt;对象转变到T对象，是通过execute().body()这两个方法的连续调用，因此沿着这个调用链进行分析。</p>
<h3 id="1-Call-execute"><a href="#1-Call-execute" class="headerlink" title="1.Call.execute()"></a>1.Call.execute()</h3><p>Call是一个接口，从上一篇的分析中可以得知，最终得到的实现类是OkHttpCall</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  okhttp3.Call call;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Already executed.&quot;</span>);</span><br><span class="line">    executed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    call = getRawCall();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">    call.cancel();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> parseResponse(call.execute());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里实际上是对okhttp3里面的Call对象进行了一层封装，分成三步：</p>
<ul>
<li>通过getRawCall()方法得到okhttp3的Call对象</li>
<li>对okhttp3的call对象进行execute()方法</li>
<li>对execute的结果进行parseResponse()操作</li>
</ul>
<h3 id="1-1-getRawCall"><a href="#1-1-getRawCall" class="headerlink" title="1.1 getRawCall()"></a>1.1 getRawCall()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> okhttp3.<span class="function">Call <span class="title">getRawCall</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  okhttp3.Call call = rawCall;</span><br><span class="line">  <span class="keyword">if</span> (call != <span class="keyword">null</span>) <span class="keyword">return</span> call;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Re-throw previous failures if this isn&#x27;t the first attempt.</span></span><br><span class="line">  <span class="keyword">if</span> (creationFailure != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (creationFailure <span class="keyword">instanceof</span> IOException) &#123;</span><br><span class="line">      <span class="keyword">throw</span> (IOException) creationFailure;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (creationFailure <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">      <span class="keyword">throw</span> (RuntimeException) creationFailure;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> (Error) creationFailure;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create and remember either the success or the failure.</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rawCall = createRawCall();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RuntimeException | Error | IOException e) &#123;</span><br><span class="line">    throwIfFatal(e); <span class="comment">// Do not assign a fatal error to creationFailure.</span></span><br><span class="line">    creationFailure = e;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用到createRawCall()来进行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> okhttp3.<span class="function">Call <span class="title">createRawCall</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  okhttp3.Call call = callFactory.newCall(requestFactory.create(args));</span><br><span class="line">  <span class="keyword">if</span> (call == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;Call.Factory returned null.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> call;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Call对象的创建分成两步：</p>
<ul>
<li>requestFactory.create()创建出okhttp3.Request对象</li>
<li>callFactory.newCall()生产出Call对象</li>
</ul>
<h3 id="1-1-1-RequestFactory-create"><a href="#1-1-1-RequestFactory-create" class="headerlink" title="1.1.1 RequestFactory.create()"></a>1.1.1 RequestFactory.create()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">okhttp3.<span class="function">Request <span class="title">create</span><span class="params">(Object[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="comment">// It is an error to invoke a method with the wrong arg types.</span></span><br><span class="line">   ParameterHandler&lt;Object&gt;[] handlers = (ParameterHandler&lt;Object&gt;[]) parameterHandlers;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> argumentCount = args.length;</span><br><span class="line">   <span class="keyword">if</span> (argumentCount != handlers.length) &#123;</span><br><span class="line">       <span class="comment">// ……</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   RequestBuilder requestBuilder =</span><br><span class="line">       <span class="keyword">new</span> RequestBuilder(</span><br><span class="line">           httpMethod,</span><br><span class="line">           baseUrl,</span><br><span class="line">           relativeUrl,</span><br><span class="line">           headers,</span><br><span class="line">           contentType,</span><br><span class="line">           hasBody,</span><br><span class="line">           isFormEncoded,</span><br><span class="line">           isMultipart);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (isKotlinSuspendFunction) &#123;</span><br><span class="line">     <span class="comment">// The Continuation is the last parameter and the handlers array contains null at that index.</span></span><br><span class="line">     argumentCount--;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   List&lt;Object&gt; argumentList = <span class="keyword">new</span> ArrayList&lt;&gt;(argumentCount);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; argumentCount; p++) &#123;</span><br><span class="line">     argumentList.add(args[p]);</span><br><span class="line">     handlers[p].apply(requestBuilder, args[p]);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> requestBuilder.get().tag(Invocation.class, <span class="keyword">new</span> Invocation(method, argumentList)).build();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>创建了RequestBuilder，然后出现了上篇暂时略过的ParameterHandler对象，将RequestBuilder对象和参数传入对应的ParameterHandler的apply方法中，因此看一下这个方法的作用：<br>ParameterHandler是一个抽象类，不同的参数类型使用的是不一样的实现类，我们仍以最常用的Query参数为例，使用的是Query这个实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(RequestBuilder builder, <span class="meta">@Nullable</span> T value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) <span class="keyword">return</span>; <span class="comment">// Skip null values.</span></span><br><span class="line"></span><br><span class="line">    String queryValue = valueConverter.convert(value);</span><br><span class="line">    <span class="keyword">if</span> (queryValue == <span class="keyword">null</span>) <span class="keyword">return</span>; <span class="comment">// Skip converted but null values</span></span><br><span class="line"></span><br><span class="line">    builder.addQueryParam(name, queryValue, encoded);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>query参数的处理就是将这个参数添加到RequestBuilder的queryParam上，由此可知，ParameterHandler的作用就是为不同类型的参数进行不同的操作，构建到RequestBuilder上。</p>
<p>最后通过RequestBuilder的build()方法就得到了一个okhttp使用的Request</p>
<h3 id="1-1-2-CallFactory-newCall-Request-request"><a href="#1-1-2-CallFactory-newCall-Request-request" class="headerlink" title="1.1.2 CallFactory.newCall(Request request)"></a>1.1.2 CallFactory.newCall(Request request)</h3><p>CallFactory是一个接口，在Retrofit中默认使用的是OkHttpClient</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call <span class="title">newCall</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> RealCall.newRealCall(<span class="keyword">this</span>, request, <span class="keyword">false</span> <span class="comment">/* for web socket */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OkHttpClient的newCall实现很简单。</p>
<p><strong>得到OkHttp的Call对象之后进行execute()操作</strong></p>
<h3 id="1-2-okhttp3-Call-execute"><a href="#1-2-okhttp3-Call-execute" class="headerlink" title="1.2 okhttp3.Call.execute()"></a>1.2 okhttp3.Call.execute()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Already Executed&quot;</span>);</span><br><span class="line">    executed = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  transmitter.timeoutEnter();</span><br><span class="line">  transmitter.callStart();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    client.dispatcher().executed(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> getResponseWithInterceptorChain();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就走到了okhttp的源码部分了，前面也写过文章学习了okhttp，简单来说就是在这里完成了网络请求拿到了Response</p>
<h3 id="1-3-OkHttpCall-parseResponse"><a href="#1-3-OkHttpCall-parseResponse" class="headerlink" title="1.3 OkHttpCall.parseResponse"></a>1.3 OkHttpCall.parseResponse</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Response&lt;T&gt; <span class="title">parseResponse</span><span class="params">(okhttp3.Response rawResponse)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  ResponseBody rawBody = rawResponse.body();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove the body&#x27;s source (the only stateful object) so we can pass the response along.</span></span><br><span class="line">  rawResponse =</span><br><span class="line">      rawResponse</span><br><span class="line">          .newBuilder()</span><br><span class="line">          .body(<span class="keyword">new</span> NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))</span><br><span class="line">          .build();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> code = rawResponse.code();</span><br><span class="line">  <span class="keyword">if</span> (code &lt; <span class="number">200</span> || code &gt;= <span class="number">300</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Buffer the entire body to avoid future I/O.</span></span><br><span class="line">      ResponseBody bufferedBody = Utils.buffer(rawBody);</span><br><span class="line">      <span class="keyword">return</span> Response.error(bufferedBody, rawResponse);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      rawBody.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (code == <span class="number">204</span> || code == <span class="number">205</span>) &#123;</span><br><span class="line">    rawBody.close();</span><br><span class="line">    <span class="keyword">return</span> Response.success(<span class="keyword">null</span>, rawResponse);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ExceptionCatchingResponseBody catchingBody = <span class="keyword">new</span> ExceptionCatchingResponseBody(rawBody);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    T body = responseConverter.convert(catchingBody);</span><br><span class="line">    <span class="keyword">return</span> Response.success(body, rawResponse);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">    <span class="comment">// If the underlying source threw an exception, propagate that rather than indicating it was</span></span><br><span class="line">    <span class="comment">// a runtime exception.</span></span><br><span class="line">    catchingBody.throwIfCaught();</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将okhttp返回的Response进行处理，主要是调用responseConverter.convert()方法将Response类型转换成用户使用的数据类型，这里的responseConverter，是在创建OkHttpCall的时候传入的，一直往前追溯的话，responseConverter的创建代码在HttpServiceMethod的createResponseConverter()函数中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;ResponseT&gt; <span class="function">Converter&lt;ResponseBody, ResponseT&gt; <span class="title">createResponseConverter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Retrofit retrofit, Method method, Type responseType)</span> </span>&#123;</span><br><span class="line">  Annotation[] annotations = method.getAnnotations();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> retrofit.responseBodyConverter(responseType, annotations);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">    <span class="keyword">throw</span> methodError(method, e, <span class="string">&quot;Unable to create converter for %s&quot;</span>, responseType);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续追溯到retrofit的responseBodyConverter()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Converter&lt;ResponseBody, T&gt; <span class="title">responseBodyConverter</span><span class="params">(Type type, Annotation[] annotations)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> nextResponseBodyConverter(<span class="keyword">null</span>, type, annotations);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Converter&lt;ResponseBody, T&gt; <span class="title">nextResponseBodyConverter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@Nullable</span> Converter.Factory skipPast, Type type, Annotation[] annotations)</span> </span>&#123;</span><br><span class="line">  Objects.requireNonNull(type, <span class="string">&quot;type == null&quot;</span>);</span><br><span class="line">  Objects.requireNonNull(annotations, <span class="string">&quot;annotations == null&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> start = converterFactories.indexOf(skipPast) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = converterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">    Converter&lt;ResponseBody, ?&gt; converter =</span><br><span class="line">        converterFactories.get(i).responseBodyConverter(type, annotations, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (converter != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//noinspection unchecked</span></span><br><span class="line">      <span class="keyword">return</span> (Converter&lt;ResponseBody, T&gt;) converter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  StringBuilder builder =</span><br><span class="line">      <span class="keyword">new</span> StringBuilder(<span class="string">&quot;Could not locate ResponseBody converter for &quot;</span>)</span><br><span class="line">          .append(type)</span><br><span class="line">          .append(<span class="string">&quot;.\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (skipPast != <span class="keyword">null</span>) &#123;</span><br><span class="line">    builder.append(<span class="string">&quot;  Skipped:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; start; i++) &#123;</span><br><span class="line">      builder.append(<span class="string">&quot;\n   * &quot;</span>).append(converterFactories.get(i).getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    builder.append(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  builder.append(<span class="string">&quot;  Tried:&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = converterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">    builder.append(<span class="string">&quot;\n   * &quot;</span>).append(converterFactories.get(i).getClass().getName());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(builder.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是个一段关键代码，在创建converter的时候，是通过传入返回类型Type和Annotations，遍历convertFactorys中的converter，找到符合条件的converter来作为这个请求的converter；而在此前Retrofit的builid()方法中我们记得使用的默认的converterFactory是BuiltInConverters()；关于BuiltInConverters()的内容暂时不展开说</p>
<p><strong>总之，通过OkHttpCall.parseResponse()的方法，已经构建除了body为我们目标数据类型的Response</strong></p>
<h3 id="2-Response-body"><a href="#2-Response-body" class="headerlink" title="2.Response.body()"></a>2.Response.body()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">T <span class="title">body</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法其实很简单了，就是将保存在body字段的数据对象返回<br><strong>拿到数据对象之后我们就完成了从服务器获取所需数据的操作了，随后可以对对象进行本地的访问操作</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>通过触发Call对象的execute()方法，会通过okhttp进行网络请求，并且通过retrofit的converter将网络数据转换成用户需要的数据对象</li>
<li>通过Response的body()函数即可获取到前面说的数据对象</li>
</ul>
]]></content>
      <tags>
        <tag>网络框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Retrofit源码学习</title>
    <url>/2021/04/30/Retrofit%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>Retrofit是Square公司开源的一款android网络请求库，官方介绍是Retrofit turns your HTTP API into a Java interface；说明主要作用是将HTTP API转换成Java接口，更方便使用。Retrofit这个词的中文意思是”改装”。</p>
<h3 id="官方用法"><a href="#官方用法" class="headerlink" title="官方用法"></a>官方用法</h3><p>通过注解定义请求路径和参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@GET(&quot;users/&#123;user&#125;/repos&quot;)</span></span><br><span class="line">  Call&lt;List&lt;Repo&gt;&gt; listRepos(<span class="meta">@Path(&quot;user&quot;)</span> String user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建Retrofit实例并通过Retrofit创建service</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">&quot;https://api.github.com/&quot;</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">GitHubService service = retrofit.create(GitHubService.class);</span><br></pre></td></tr></table></figure>

<p>随后即可像调用本地接口一样来调用网络请求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(<span class="string">&quot;octocat&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>从用法中可以看出，对Retrofit的源码学习应该从build()方法开始</p>
<h3 id="1-Retrofit-Builder-build"><a href="#1-Retrofit-Builder-build" class="headerlink" title="1.Retrofit.Builder().build()"></a>1.Retrofit.Builder().build()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Retrofit <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (baseUrl == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Base URL required.&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     okhttp3.Call.Factory callFactory = <span class="keyword">this</span>.callFactory;</span><br><span class="line">     <span class="keyword">if</span> (callFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">       callFactory = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Executor callbackExecutor = <span class="keyword">this</span>.callbackExecutor;</span><br><span class="line">     <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">       callbackExecutor = platform.defaultCallbackExecutor();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Make a defensive copy of the adapters and add the default Call adapter.</span></span><br><span class="line">     List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.callAdapterFactories);</span><br><span class="line">     callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Make a defensive copy of the converters.</span></span><br><span class="line">     List&lt;Converter.Factory&gt; converterFactories =</span><br><span class="line">         <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">             <span class="number">1</span> + <span class="keyword">this</span>.converterFactories.size() + platform.defaultConverterFactoriesSize());</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Add the built-in converter factory first. This prevents overriding its behavior but also</span></span><br><span class="line">     <span class="comment">// ensures correct behavior when using converters that consume all types.</span></span><br><span class="line">     converterFactories.add(<span class="keyword">new</span> BuiltInConverters());</span><br><span class="line">     converterFactories.addAll(<span class="keyword">this</span>.converterFactories);</span><br><span class="line">     converterFactories.addAll(platform.defaultConverterFactories());</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> Retrofit(</span><br><span class="line">         callFactory,</span><br><span class="line">         baseUrl,</span><br><span class="line">         unmodifiableList(converterFactories),</span><br><span class="line">         unmodifiableList(callAdapterFactories),</span><br><span class="line">         callbackExecutor,</span><br><span class="line">         validateEagerly);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在调用Retrofit的构造函数之前，build()的方法做了一下准备：</p>
<ul>
<li>如果用户代码没有传入callFactory，则使用OkHttpClient()作为callFactory，由此看出最终承担发送网络请求这个操作是通过okhttp来实现的</li>
<li>创建CallAdapter.Factory的List，并将用户代码传入的callAdapterFactories加到List中，并将默认使用的CallAdapterFactory都加入到List</li>
<li>创建Converter.Factory的List，并添加默认的ConverterFactory，同时也加入用户代码设置的ConverterFactory</li>
</ul>
<p>然后调用Retrofit的构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Retrofit(</span><br><span class="line">    okhttp3.Call.Factory callFactory,</span><br><span class="line">    HttpUrl baseUrl,</span><br><span class="line">    List&lt;Converter.Factory&gt; converterFactories,</span><br><span class="line">    List&lt;CallAdapter.Factory&gt; callAdapterFactories,</span><br><span class="line">    <span class="meta">@Nullable</span> Executor callbackExecutor,</span><br><span class="line">    <span class="keyword">boolean</span> validateEagerly) &#123;</span><br><span class="line">  <span class="keyword">this</span>.callFactory = callFactory;</span><br><span class="line">  <span class="keyword">this</span>.baseUrl = baseUrl;</span><br><span class="line">  <span class="keyword">this</span>.converterFactories = converterFactories; <span class="comment">// Copy+unmodifiable at call site.</span></span><br><span class="line">  <span class="keyword">this</span>.callAdapterFactories = callAdapterFactories; <span class="comment">// Copy+unmodifiable at call site.</span></span><br><span class="line">  <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">  <span class="keyword">this</span>.validateEagerly = validateEagerly;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仅仅是对传入的字段进行设置</p>
<p>从使用文档上可以看到，创建了Retrofit实例之后就是调用其create()方法</p>
<h3 id="2-Retrofit-create-final-Class-lt-T-gt-service"><a href="#2-Retrofit-create-final-Class-lt-T-gt-service" class="headerlink" title="2.Retrofit.create(final Class&lt;T&gt; service)"></a>2.Retrofit.create(final Class&lt;T&gt; service)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">  validateServiceInterface(service);</span><br><span class="line">  <span class="keyword">return</span> (T)</span><br><span class="line">      Proxy.newProxyInstance(</span><br><span class="line">          service.getClassLoader(),</span><br><span class="line">          <span class="keyword">new</span> Class&lt;?&gt;[] &#123;service&#125;,</span><br><span class="line">          <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> Object[] emptyArgs = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">              <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></span><br><span class="line">              <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">                <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">              &#125;</span><br><span class="line">              args = args != <span class="keyword">null</span> ? args : emptyArgs;</span><br><span class="line">              <span class="keyword">return</span> platform.isDefaultMethod(method)</span><br><span class="line">                  ? platform.invokeDefaultMethod(method, service, proxy, args)</span><br><span class="line">                  : loadServiceMethod(method).invoke(args);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数是整个Retrofit的核心，将定义的网络请求接口转换可用的java接口，使用了Java的代理技术，关键在传入的InvocationHandler的invoke()方法中，完成了用户定义的接口的方法的实现，即调用service.listRepos(“octocat”)时，真正执行的方法就是这里。</p>
<p>最后的return语句中，会判断调用的方法是不是DefaultMethod，DefaultMethod是java8引入的概念，即接口中的非抽象方法；通常我们使用都不会在接口中定义非抽象方法， 因此直接看下loadServiceMethod(method)的实现</p>
<h3 id="2-1-Retrofit-loadServiceMethod-Method-method"><a href="#2-1-Retrofit-loadServiceMethod-Method-method" class="headerlink" title="2.1 Retrofit.loadServiceMethod(Method method)"></a>2.1 Retrofit.loadServiceMethod(Method method)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;</span><br><span class="line">  ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</span><br><span class="line">    result = serviceMethodCache.get(method);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">      result = ServiceMethod.parseAnnotations(<span class="keyword">this</span>, method);</span><br><span class="line">      serviceMethodCache.put(method, result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>缓存中如果有，直接返回</li>
<li>通过synchronized关键字锁住cache，然后调用ServiceMethod.parseAnnotations()创建出目标方法</li>
<li>加入到缓存，然后返回</li>
</ul>
<h3 id="2-2-ServiceMethod-parseAnnotations"><a href="#2-2-ServiceMethod-parseAnnotations" class="headerlink" title="2.2 ServiceMethod.parseAnnotations()"></a>2.2 ServiceMethod.parseAnnotations()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">ServiceMethod&lt;T&gt; <span class="title">parseAnnotations</span><span class="params">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class="line">  RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);</span><br><span class="line">  <span class="comment">// ……</span></span><br><span class="line">  <span class="keyword">return</span> HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要有两步：</p>
<ul>
<li>创建RequestFactory对象</li>
<li>调用HttpServiceMethod.parseAnnotations()创建ServiceMethod返回</li>
</ul>
<p>下面看下这两步的实现</p>
<h3 id="2-2-1-RequestFactory-parseAnnotations-retrofit-method"><a href="#2-2-1-RequestFactory-parseAnnotations-retrofit-method" class="headerlink" title="2.2.1 RequestFactory.parseAnnotations(retrofit, method)"></a>2.2.1 RequestFactory.parseAnnotations(retrofit, method)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> RequestFactory <span class="title">parseAnnotations</span><span class="params">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Builder(retrofit, method).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中Builder的构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Builder(Retrofit retrofit, Method method) &#123;</span><br><span class="line">  <span class="keyword">this</span>.retrofit = retrofit;</span><br><span class="line">  <span class="keyword">this</span>.method = method;</span><br><span class="line">  <span class="keyword">this</span>.methodAnnotations = method.getAnnotations();</span><br><span class="line">  <span class="keyword">this</span>.parameterTypes = method.getGenericParameterTypes();</span><br><span class="line">  <span class="keyword">this</span>.parameterAnnotationsArray = method.getParameterAnnotations();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会拿到方法的注解和参数类型以及参数的注解，这里就是我们用户代码的注解传递到retrofit的过程<br>然后是build()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">RequestFactory <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (Annotation annotation : methodAnnotations) &#123;</span><br><span class="line">    parseMethodAnnotation(annotation);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> parameterCount = parameterAnnotationsArray.length;</span><br><span class="line">  parameterHandlers = <span class="keyword">new</span> ParameterHandler&lt;?&gt;[parameterCount];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>, lastParameter = parameterCount - <span class="number">1</span>; p &lt; parameterCount; p++) &#123;</span><br><span class="line">    parameterHandlers[p] =</span><br><span class="line">        parseParameter(p, parameterTypes[p], parameterAnnotationsArray[p], p == lastParameter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RequestFactory(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删减掉前后的校验代码之后，就剩下这些核心代码，主要是两部分：</p>
<ul>
<li>通过parseMethodAnnotation()方法对每个此前得到的每个方法注解进行解析</li>
<li>通过parseParameter()方法对参数的注解进行解析</li>
<li>调用RequestFactory的构造函数<br>分别看下这三个部分的实现</li>
</ul>
<h3 id="2-2-1-1-parseMethodAnnotation"><a href="#2-2-1-1-parseMethodAnnotation" class="headerlink" title="2.2.1.1 parseMethodAnnotation()"></a>2.2.1.1 parseMethodAnnotation()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseMethodAnnotation</span><span class="params">(Annotation annotation)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> DELETE) &#123;</span><br><span class="line">    parseHttpMethodAndPath(<span class="string">&quot;DELETE&quot;</span>, ((DELETE) annotation).value(), <span class="keyword">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> GET) &#123;</span><br><span class="line">    parseHttpMethodAndPath(<span class="string">&quot;GET&quot;</span>, ((GET) annotation).value(), <span class="keyword">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> HEAD) &#123;</span><br><span class="line">    parseHttpMethodAndPath(<span class="string">&quot;HEAD&quot;</span>, ((HEAD) annotation).value(), <span class="keyword">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> PATCH) &#123;</span><br><span class="line">    parseHttpMethodAndPath(<span class="string">&quot;PATCH&quot;</span>, ((PATCH) annotation).value(), <span class="keyword">true</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> POST) &#123;</span><br><span class="line">    parseHttpMethodAndPath(<span class="string">&quot;POST&quot;</span>, ((POST) annotation).value(), <span class="keyword">true</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> PUT) &#123;</span><br><span class="line">    parseHttpMethodAndPath(<span class="string">&quot;PUT&quot;</span>, ((PUT) annotation).value(), <span class="keyword">true</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> OPTIONS) &#123;</span><br><span class="line">    parseHttpMethodAndPath(<span class="string">&quot;OPTIONS&quot;</span>, ((OPTIONS) annotation).value(), <span class="keyword">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> HTTP) &#123;</span><br><span class="line">    HTTP http = (HTTP) annotation;</span><br><span class="line">    parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> retrofit2.http.Headers) &#123;</span><br><span class="line">    String[] headersToParse = ((retrofit2.http.Headers) annotation).value();</span><br><span class="line">    <span class="keyword">if</span> (headersToParse.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(method, <span class="string">&quot;@Headers annotation is empty.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    headers = parseHeaders(headersToParse);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Multipart) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFormEncoded) &#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(method, <span class="string">&quot;Only one encoding annotation is allowed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    isMultipart = <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> FormUrlEncoded) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isMultipart) &#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(method, <span class="string">&quot;Only one encoding annotation is allowed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    isFormEncoded = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看到会调用parseHttpMethodAndPath()对Http的具体方法进行处理:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseHttpMethodAndPath</span><span class="params">(String httpMethod, String value, <span class="keyword">boolean</span> hasBody)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>.httpMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">// ……</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">this</span>.httpMethod = httpMethod;</span><br><span class="line">     <span class="keyword">this</span>.hasBody = hasBody;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (value.isEmpty()) &#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Get the relative URL path and existing query string, if present.</span></span><br><span class="line">     <span class="keyword">int</span> question = value.indexOf(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">     <span class="keyword">if</span> (question != -<span class="number">1</span> &amp;&amp; question &lt; value.length() - <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="comment">// ……</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">this</span>.relativeUrl = value;</span><br><span class="line">     <span class="keyword">this</span>.relativeUrlParamNames = parsePathParameters(value);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>除去一些异常处理，其实就是将httpMethod和relativeUrl等参数记录到RequestFactory中<br>上面这部分是对方法注解的处理</p>
<h3 id="2-2-1-2-parseParameter-int-p-Type-parameterType-Nullable-Annotation-annotations-boolean-allowContinuation"><a href="#2-2-1-2-parseParameter-int-p-Type-parameterType-Nullable-Annotation-annotations-boolean-allowContinuation" class="headerlink" title="2.2.1.2 parseParameter(int p, Type parameterType, @Nullable Annotation[] annotations, boolean allowContinuation)"></a>2.2.1.2 parseParameter(int p, Type parameterType, @Nullable Annotation[] annotations, boolean allowContinuation)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="meta">@Nullable</span> ParameterHandler&lt;?&gt; parseParameter(</span><br><span class="line">       <span class="keyword">int</span> p, Type parameterType, <span class="meta">@Nullable</span> Annotation[] annotations, <span class="keyword">boolean</span> allowContinuation) &#123;</span><br><span class="line">     ParameterHandler&lt;?&gt; result = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">if</span> (annotations != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">         ParameterHandler&lt;?&gt; annotationAction =</span><br><span class="line">             parseParameterAnnotation(p, parameterType, annotations, annotation);</span><br><span class="line">         <span class="comment">// ……</span></span><br><span class="line">         result = annotationAction;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// ……</span></span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>通过调用parseParameterAnnotation()方法来完成解析，这个方法的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ParameterHandler&lt;?&gt; parseParameterAnnotation(</span><br><span class="line">       <span class="keyword">int</span> p, Type type, Annotation[] annotations, Annotation annotation) &#123;</span><br><span class="line">     <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Url) &#123;</span><br><span class="line">       <span class="comment">// ……</span></span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Path) &#123;</span><br><span class="line">       <span class="comment">// ……</span></span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Query) &#123;</span><br><span class="line">       validateResolvableType(p, type);</span><br><span class="line">       Query query = (Query) annotation;</span><br><span class="line">       String name = query.value();</span><br><span class="line">       <span class="keyword">boolean</span> encoded = query.encoded();</span><br><span class="line"></span><br><span class="line">       Class&lt;?&gt; rawParameterType = Utils.getRawType(type);</span><br><span class="line">       gotQuery = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">if</span> (Iterable.class.isAssignableFrom(rawParameterType)) &#123;</span><br><span class="line">         <span class="keyword">if</span> (!(type <span class="keyword">instanceof</span> ParameterizedType)) &#123;</span><br><span class="line">           <span class="comment">// ……</span></span><br><span class="line">         &#125;</span><br><span class="line">         ParameterizedType parameterizedType = (ParameterizedType) type;</span><br><span class="line">         Type iterableType = Utils.getParameterUpperBound(<span class="number">0</span>, parameterizedType);</span><br><span class="line">         Converter&lt;?, String&gt; converter = retrofit.stringConverter(iterableType, annotations);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> ParameterHandler.Query&lt;&gt;(name, converter, encoded).iterable();</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rawParameterType.isArray()) &#123;</span><br><span class="line">         </span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         Converter&lt;?, String&gt; converter = retrofit.stringConverter(type, annotations);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> ParameterHandler.Query&lt;&gt;(name, converter, encoded);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// ……</span></span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> QueryName) &#123;</span><br><span class="line">       <span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> QueryMap) &#123;</span><br><span class="line">       <span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Header) &#123;</span><br><span class="line">       <span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> HeaderMap) &#123;</span><br><span class="line">       <span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> FieldMap) &#123;</span><br><span class="line">       <span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> PartMap) &#123;</span><br><span class="line">       <span class="comment">// ……</span></span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Tag) &#123;</span><br><span class="line">       <span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ParameterHandler.Tag&lt;&gt;(tagType);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// Not a Retrofit annotation.</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>原函数的实现非常长，因为要对参数的每一种可能的注解都进行解析，这里保留了比较常用的对@Query的解析代码，最终将会得到一个ParameterHandler.Query对象返回，这里的ParameterHandler.Query暂时略过，这里面记录了query的参数信息</p>
<p>对方法和参数的注解都解析完之后，会调用new RequestFactory(Builder builder)来进行RequestFactory的实际构建</p>
<h3 id="2-2-1-3-RequestFactory-Builder-builder"><a href="#2-2-1-3-RequestFactory-Builder-builder" class="headerlink" title="2.2.1.3 RequestFactory(Builder builder)"></a>2.2.1.3 RequestFactory(Builder builder)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RequestFactory(Builder builder) &#123;</span><br><span class="line">  method = builder.method;</span><br><span class="line">  baseUrl = builder.retrofit.baseUrl;</span><br><span class="line">  httpMethod = builder.httpMethod;</span><br><span class="line">  relativeUrl = builder.relativeUrl;</span><br><span class="line">  headers = builder.headers;</span><br><span class="line">  contentType = builder.contentType;</span><br><span class="line">  hasBody = builder.hasBody;</span><br><span class="line">  isFormEncoded = builder.isFormEncoded;</span><br><span class="line">  isMultipart = builder.isMultipart;</span><br><span class="line">  parameterHandlers = builder.parameterHandlers;</span><br><span class="line">  isKotlinSuspendFunction = builder.isKotlinSuspendFunction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常见的builder设计模式，把参数都记录到RequestFactory</p>
<p><strong>前面走得有点深，收一下：上面介绍的是创建RequestFactory对象的创建过程，在这个创建过程了完成了对方法的注解解析和对参数的注解解析，随后将进行ServiceMethod的创建，将一个网络请求封装成java的方法</strong></p>
<h3 id="2-2-2-HttpServiceMethod-lt-ResponseT-ReturnT-gt-parseAnnotations-Retrofit-retrofit-Method-method-RequestFactory-requestFactory"><a href="#2-2-2-HttpServiceMethod-lt-ResponseT-ReturnT-gt-parseAnnotations-Retrofit-retrofit-Method-method-RequestFactory-requestFactory" class="headerlink" title="2.2.2 HttpServiceMethod&lt;ResponseT, ReturnT&gt; parseAnnotations(Retrofit retrofit, Method method, RequestFactory requestFactory)"></a>2.2.2 HttpServiceMethod&lt;ResponseT, ReturnT&gt; parseAnnotations(Retrofit retrofit, Method method, RequestFactory requestFactory)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;ResponseT, ReturnT&gt; <span class="function">HttpServiceMethod&lt;ResponseT, ReturnT&gt; <span class="title">parseAnnotations</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Retrofit retrofit, Method method, RequestFactory requestFactory)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction;</span><br><span class="line">  <span class="keyword">boolean</span> continuationWantsResponse = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">boolean</span> continuationBodyNullable = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  Annotation[] annotations = method.getAnnotations();</span><br><span class="line">  Type adapterType;</span><br><span class="line">  <span class="keyword">if</span> (isKotlinSuspendFunction) &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    adapterType = method.getGenericReturnType();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter =</span><br><span class="line">      createCallAdapter(retrofit, method, adapterType, annotations);</span><br><span class="line">  Type responseType = callAdapter.responseType();</span><br><span class="line">  <span class="keyword">if</span> (responseType == okhttp3.Response.class) &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (responseType == Response.class) &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// TODO support Unit for Kotlin?</span></span><br><span class="line">  <span class="keyword">if</span> (requestFactory.httpMethod.equals(<span class="string">&quot;HEAD&quot;</span>) &amp;&amp; !Void.class.equals(responseType)) &#123;</span><br><span class="line">      <span class="comment">// ……</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Converter&lt;ResponseBody, ResponseT&gt; responseConverter =</span><br><span class="line">      createResponseConverter(retrofit, method, responseType);</span><br><span class="line"></span><br><span class="line">  okhttp3.Call.Factory callFactory = retrofit.callFactory;</span><br><span class="line">  <span class="keyword">if</span> (!isKotlinSuspendFunction) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (continuationWantsResponse) &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>略去一些异常处理的代码之后，可以看到最终返回的是一个CallAdapted，通过传入相应的requestFactory、callFactory、responseConverter、callAdapter进行创建：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CallAdapted(</span><br><span class="line">    RequestFactory requestFactory,</span><br><span class="line">    okhttp3.Call.Factory callFactory,</span><br><span class="line">    Converter&lt;ResponseBody, ResponseT&gt; responseConverter,</span><br><span class="line">    CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter) &#123;</span><br><span class="line">  <span class="keyword">super</span>(requestFactory, callFactory, responseConverter);</span><br><span class="line">  <span class="keyword">this</span>.callAdapter = callAdapter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用了超类的构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpServiceMethod(</span><br><span class="line">    RequestFactory requestFactory,</span><br><span class="line">    okhttp3.Call.Factory callFactory,</span><br><span class="line">    Converter&lt;ResponseBody, ResponseT&gt; responseConverter) &#123;</span><br><span class="line">  <span class="keyword">this</span>.requestFactory = requestFactory;</span><br><span class="line">  <span class="keyword">this</span>.callFactory = callFactory;</span><br><span class="line">  <span class="keyword">this</span>.responseConverter = responseConverter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里也就是把变量记录到HttpServiceMethod的类成员变量上</p>
<p><strong>到这里已经完成了Retrofit.loadServiceMethod(Method method)的操作，创建出了ServiceMethod，但从2的代码中可以看到，我们在调用java接口进行网络请求时，触发的是ServiceMethod的invoke(Object[] args)方法，因此接下来看下这个方法是如何实现的</strong></p>
<h3 id="3-ServiceMethod-invoke-Object-args"><a href="#3-ServiceMethod-invoke-Object-args" class="headerlink" title="3.ServiceMethod.invoke(Object[] args)"></a>3.ServiceMethod.invoke(Object[] args)</h3><p>从前述的分析已经可以看到，最终得到的实际上是ServiceMethod的派生类CallAdapted，但CallAdapted没有重写invoke()方法，调用的是其直接父类HttpServiceMethod的invoke()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="meta">@Nullable</span> <span class="function">ReturnT <span class="title">invoke</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">  Call&lt;ResponseT&gt; call = <span class="keyword">new</span> OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter);</span><br><span class="line">  <span class="keyword">return</span> adapt(call, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建出一个OkHttpCall，然后调用adapt(call, args)方法，在CallAdapted中重写了adapt()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ReturnT <span class="title">adapt</span><span class="params">(Call&lt;ResponseT&gt; call, Object[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> callAdapter.adapt(call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而这个callAdapter，就是前面分析里提到过的，retrofit传入的callAdapter，实现在DefaultCallAdapterFactory.java这个类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Type <span class="title">responseType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> responseType;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Call&lt;Object&gt; <span class="title">adapt</span><span class="params">(Call&lt;Object&gt; call)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> executor == <span class="keyword">null</span> ? call : <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(executor, call);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>在Android平台中得到的是ExecutorCallbackCall&lt;&gt;(executor, call)，继承自Call，这也就是业务代码最终能够得到的结果。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Retrofit的作用是将http请求封装成java接口，方便用户代码使用</li>
<li>http请求的信息，包括方法和参数，是通过java注解的形式定义的，Retrofit通过动态代理机制，解析注解的内容，生成java接口的实现类供用户代码使用</li>
<li>http请求最终通过Retrofit变成了一个Call&lt;T&gt;对象，用户代码随后可以对这个Call&lt;T&gt;进行操作</li>
<li>从源码解析上来看，得到Call对象时，并没有真正发出网络请求，网络请求的发出是对Call对象进行操作时才进行的</li>
</ul>
<p>官方的使用文档里面示例仅仅给出了如何获得一个Call对象，但没有给出Call对象要怎么使用，从这个Call对象到用户所需的数据对象还需要进一步操作，这部分放到下篇再继续。</p>
]]></content>
      <tags>
        <tag>网络框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Picasso图片加载库源码学习</title>
    <url>/2021/05/06/Picasso%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><blockquote>
<p>A powerful image downloading and caching library for Android. ——Picasso官方介绍</p>
</blockquote>
<p>Picasso是Square公司出品的一款图片加载框架，通过Picasso可以很容易地进行网络图片的加载。</p>
<h3 id="示例用法"><a href="#示例用法" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Picasso.build().load(<span class="string">&quot;http://i.imgur.com/DvpvklR.png&quot;</span>).into(imageView);</span><br></pre></td></tr></table></figure>
<p><strong>从示例用法的调用链出发对Picasso的源码进行学习</strong></p>
<h3 id="1-Picasso-build"><a href="#1-Picasso-build" class="headerlink" title="1.Picasso.build()"></a>1.Picasso.build()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> Picasso <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Context context = <span class="keyword">this</span>.context;</span><br><span class="line"></span><br><span class="line">    okhttp3.Cache unsharedCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (callFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">      File cacheDir = createDefaultCacheDir(context);</span><br><span class="line">      <span class="keyword">long</span> maxSize = calculateDiskCacheSize(cacheDir);</span><br><span class="line">      unsharedCache = <span class="keyword">new</span> okhttp3.Cache(cacheDir, maxSize);</span><br><span class="line">      callFactory = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">          .cache(unsharedCache)</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cache == <span class="keyword">null</span>) &#123;</span><br><span class="line">      cache = <span class="keyword">new</span> PlatformLruCache(Utils.calculateMemoryCacheSize(context));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;</span><br><span class="line">      service = <span class="keyword">new</span> PicassoExecutorService(<span class="keyword">new</span> PicassoThreadFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Dispatcher dispatcher = <span class="keyword">new</span> Dispatcher(context, service, HANDLER, cache);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Picasso(context, dispatcher, callFactory, unsharedCache, cache, listener,</span><br><span class="line">        requestTransformers, requestHandlers, eventListeners, defaultBitmapConfig,</span><br><span class="line">        indicatorsEnabled, loggingEnabled);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法有以下要点：</p>
<ul>
<li>使用了okHttp3.Cache作为缓存unsharedCache</li>
<li>使用okHttp3作为callFactory</li>
<li>如果没有手动设置cache，会使用PlatformLruCache作为cache</li>
<li>如果没有手动设置service，使用PicassoExecutorService</li>
<li>创建Dispatcher对象</li>
<li>返回Picasso实例</li>
</ul>
<h3 id="2-Picasso-load-String-path"><a href="#2-Picasso-load-String-path" class="headerlink" title="2.Picasso.load(String path)"></a>2.Picasso.load(String path)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestCreator <span class="title">load</span><span class="params">(<span class="meta">@Nullable</span> String path)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (path == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RequestCreator(<span class="keyword">this</span>, <span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (path.trim().length() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Path must not be empty.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> load(Uri.parse(path));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用的是同名函数load(Uri uri)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequestCreator <span class="title">load</span><span class="params">(<span class="meta">@Nullable</span> Uri uri)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RequestCreator(<span class="keyword">this</span>, uri, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回的是创建出来的RequestCreator对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RequestCreator(Picasso picasso, <span class="meta">@Nullable</span> Uri uri, <span class="keyword">int</span> resourceId) &#123;</span><br><span class="line">  <span class="keyword">if</span> (picasso.shutdown) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">        <span class="string">&quot;Picasso instance already shut down. Cannot submit new requests.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.picasso = picasso;</span><br><span class="line">  <span class="keyword">this</span>.data = <span class="keyword">new</span> Request.Builder(uri, resourceId, picasso.defaultBitmapConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-RequestCreator-into-ImageView-target"><a href="#3-RequestCreator-into-ImageView-target" class="headerlink" title="3.RequestCreator.into(ImageView target)"></a>3.RequestCreator.into(ImageView target)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">into</span><span class="params">(<span class="meta">@NonNull</span> ImageView target)</span> </span>&#123;</span><br><span class="line">  into(target, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">into</span><span class="params">(<span class="meta">@NonNull</span> ImageView target, <span class="meta">@Nullable</span> Callback callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> started = System.nanoTime();</span><br><span class="line">    checkMain();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Target must not be null.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!data.hasImage()) &#123;</span><br><span class="line">      picasso.cancelRequest(target);</span><br><span class="line">      <span class="keyword">if</span> (setPlaceholder) &#123;</span><br><span class="line">        setPlaceholder(target, getPlaceholderDrawable());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (deferred) &#123;</span><br><span class="line">      <span class="keyword">if</span> (data.hasSize()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Fit cannot be used with resize.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> width = target.getWidth();</span><br><span class="line">      <span class="keyword">int</span> height = target.getHeight();</span><br><span class="line">      <span class="keyword">if</span> (width == <span class="number">0</span> || height == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (setPlaceholder) &#123;</span><br><span class="line">          setPlaceholder(target, getPlaceholderDrawable());</span><br><span class="line">        &#125;</span><br><span class="line">        picasso.defer(target, <span class="keyword">new</span> DeferredRequestCreator(<span class="keyword">this</span>, target, callback));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      data.resize(width, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Request request = createRequest(started);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shouldReadFromMemoryCache(request.memoryPolicy)) &#123;</span><br><span class="line">      Bitmap bitmap = picasso.quickMemoryCacheCheck(request.key);</span><br><span class="line">      <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</span><br><span class="line">        picasso.cancelRequest(target);</span><br><span class="line">        Result result = <span class="keyword">new</span> Result.Bitmap(bitmap, MEMORY);</span><br><span class="line">        setResult(target, picasso.context, result, noFade, picasso.indicatorsEnabled);</span><br><span class="line">        <span class="keyword">if</span> (picasso.loggingEnabled) &#123;</span><br><span class="line">          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), <span class="string">&quot;from &quot;</span> + MEMORY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">          callback.onSuccess();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setPlaceholder) &#123;</span><br><span class="line">      setPlaceholder(target, getPlaceholderDrawable());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Action action = <span class="keyword">new</span> ImageViewAction(picasso, target, request, errorDrawable, errorResId, noFade,</span><br><span class="line">        callback);</span><br><span class="line">    picasso.enqueueAndSubmit(action);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>分成以下要点：</p>
<ul>
<li>进行线程检查、空判断等异常情况的处理</li>
<li>判断是否需要延迟处理</li>
<li>构造Request</li>
<li>检查是否命中内存缓存，命中则取消请求直接返回</li>
<li>通过picasso/target/request创建出Action对象</li>
<li>将创建出的action通过picasso的enqueueAndSubmit()方法进行提交</li>
</ul>
<h3 id="3-1-Action的创建"><a href="#3-1-Action的创建" class="headerlink" title="3.1 Action的创建"></a>3.1 Action的创建</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageViewAction</span></span>(</span><br><span class="line">        picasso: Picasso,</span><br><span class="line">        <span class="keyword">val</span> target: ImageView,</span><br><span class="line">        <span class="keyword">data</span>: Request,</span><br><span class="line">        <span class="keyword">val</span> errorDrawable: Drawable?,</span><br><span class="line">        <span class="meta">@DrawableRes</span> <span class="keyword">val</span> errorResId: <span class="built_in">Int</span>,</span><br><span class="line">        <span class="keyword">val</span> noFade: <span class="built_in">Boolean</span>,</span><br><span class="line">        <span class="keyword">var</span> callback: Callback?</span><br><span class="line">) : Action(picasso, <span class="keyword">data</span>) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">complete</span><span class="params">(result: <span class="type">Result</span>)</span></span> &#123;</span><br><span class="line">        PicassoDrawable.setResult(target, picasso.context, result, noFade, picasso.indicatorsEnabled)</span><br><span class="line">        callback?.onSuccess()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">error</span><span class="params">(e: <span class="type">Exception</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> placeholder = target.drawable</span><br><span class="line">        <span class="keyword">if</span> (placeholder <span class="keyword">is</span> Animatable) &#123;</span><br><span class="line">            (placeholder <span class="keyword">as</span> Animatable).stop()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (errorResId != <span class="number">0</span>) &#123;</span><br><span class="line">            target.setImageResource(errorResId)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (errorDrawable != <span class="literal">null</span>) &#123;</span><br><span class="line">            target.setImageDrawable(errorDrawable)</span><br><span class="line">        &#125;</span><br><span class="line">        callback?.onError(e)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getTarget</span><span class="params">()</span></span>: Any &#123;</span><br><span class="line">        <span class="keyword">return</span> target</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">cancel</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.cancel()</span><br><span class="line">        callback = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是有complete和error方法，两个方法的调用暂时略过。</p>
<h3 id="3-2-Picasso-enqueueAndSubmit-Action-action"><a href="#3-2-Picasso-enqueueAndSubmit-Action-action" class="headerlink" title="3.2 Picasso.enqueueAndSubmit(Action action)"></a>3.2 Picasso.enqueueAndSubmit(Action action)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueueAndSubmit</span><span class="params">(Action action)</span> </span>&#123;</span><br><span class="line">  Object target = action.getTarget();</span><br><span class="line">  <span class="keyword">if</span> (targetToAction.get(target) != action) &#123;</span><br><span class="line">    <span class="comment">// This will also check we are on the main thread.</span></span><br><span class="line">    cancelExistingRequest(target);</span><br><span class="line">    targetToAction.put(target, action);</span><br><span class="line">  &#125;</span><br><span class="line">  submit(action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">submit</span><span class="params">(Action action)</span> </span>&#123;</span><br><span class="line">  dispatcher.dispatchSubmit(action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上是分发到dispatcher.dispatchSubmit(action)方法来完成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchSubmit</span><span class="params">(Action action)</span> </span>&#123;</span><br><span class="line">  handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过handler切换到子线程处理，看下处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Dispatcher dispatcher;</span><br><span class="line"></span><br><span class="line">  DispatcherHandler(Looper looper, Dispatcher dispatcher) &#123;</span><br><span class="line">    <span class="keyword">super</span>(looper);</span><br><span class="line">    <span class="keyword">this</span>.dispatcher = dispatcher;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="keyword">final</span> Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">      <span class="keyword">case</span> REQUEST_SUBMIT: &#123;</span><br><span class="line">        Action action = (Action) msg.obj;</span><br><span class="line">        dispatcher.performSubmit(action);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ……</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续调用到dispatcher的performSubmit(Action action)方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performSubmit</span><span class="params">(Action action)</span> </span>&#123;</span><br><span class="line">  performSubmit(action, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performSubmit</span><span class="params">(Action action, <span class="keyword">boolean</span> dismissFailed)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (pausedTags.contains(action.getTag())) &#123;</span><br><span class="line">    pausedActions.put(action.getTarget(), action);</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  BitmapHunter hunter = hunterMap.get(action.request.key);</span><br><span class="line">  <span class="keyword">if</span> (hunter != <span class="keyword">null</span>) &#123;</span><br><span class="line">    hunter.attach(action);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">  hunter = forRequest(action.picasso, <span class="keyword">this</span>, cache, action);</span><br><span class="line">  hunter.future = service.submit(hunter);</span><br><span class="line">  hunterMap.put(action.request.key, hunter);</span><br><span class="line">  <span class="keyword">if</span> (dismissFailed) &#123;</span><br><span class="line">    failedActions.remove(action.getTarget());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先尝试从hunterMap中得到这个action.request.key对应的BitmapHunter，如果有则attach到这个action并返回</li>
<li>如果没有符合要求的BitmapHunter，则通过forRequest()方法创建出BitmapHunter</li>
<li>通过service.submit()来提交这个hunter，并把返回值设置到hunter的future字段上；这里的service是一个java的ExecutorService，由此可知BitmapHunter应该是一个Runnable</li>
</ul>
<h3 id="3-2-1-BitmapHunter-run"><a href="#3-2-1-BitmapHunter-run" class="headerlink" title="3.2.1 BitmapHunter.run()"></a>3.2.1 BitmapHunter.run()</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            updateThreadName(<span class="keyword">data</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (picasso.loggingEnabled) &#123;</span><br><span class="line">                log(OWNER_HUNTER, VERB_EXECUTING, getLogIdsForHunter(<span class="keyword">this</span>))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result = hunt()</span><br><span class="line">            dispatcher.dispatchComplete(<span class="keyword">this</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">            exception = e</span><br><span class="line">            <span class="keyword">if</span> (retryCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                dispatcher.dispatchRetry(<span class="keyword">this</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dispatcher.dispatchFailed(<span class="keyword">this</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            exception = e</span><br><span class="line">            dispatcher.dispatchFailed(<span class="keyword">this</span>)</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Thread.currentThread().name = THREAD_IDLE_NAME</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法中实际上是通过hunt()方法来获取图片：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">hunt</span><span class="params">()</span></span>: Bitmap? &#123;</span><br><span class="line">        <span class="comment">// a.</span></span><br><span class="line">        <span class="keyword">if</span> (shouldReadFromMemoryCache(<span class="keyword">data</span>.memoryPolicy)) &#123;</span><br><span class="line">            cache[key]?.let &#123; bitmap -&gt;</span><br><span class="line">                picasso.cacheHit()</span><br><span class="line">                <span class="keyword">if</span> (picasso.loggingEnabled) &#123;</span><br><span class="line">                    log(OWNER_HUNTER, VERB_DECODED, <span class="keyword">data</span>.logId(), <span class="string">&quot;from cache&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> Bitmap(bitmap, LoadedFrom.MEMORY)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// b.</span></span><br><span class="line">        <span class="keyword">if</span> (retryCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">data</span> = <span class="keyword">data</span>.newBuilder().networkPolicy(NetworkPolicy.OFFLINE).build()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// c.</span></span><br><span class="line">        <span class="keyword">val</span> resultReference = AtomicReference&lt;RequestHandler.Result?&gt;()</span><br><span class="line">        <span class="keyword">val</span> exceptionReference = AtomicReference&lt;Throwable?&gt;()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> latch = CountDownLatch(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            requestHandler.load(picasso, <span class="keyword">data</span>, <span class="keyword">object</span> : RequestHandler.Callback &#123;</span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(result: <span class="type">RequestHandler</span>.<span class="type">Result</span>?)</span></span> &#123;</span><br><span class="line">                    resultReference.<span class="keyword">set</span>(result)</span><br><span class="line">                    latch.countDown()</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(t: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">                    exceptionReference.<span class="keyword">set</span>(t)</span><br><span class="line">                    latch.countDown()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            latch.await()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ie: InterruptedException) &#123;</span><br><span class="line">            <span class="keyword">val</span> interruptedIoException = InterruptedIOException()</span><br><span class="line">            interruptedIoException.initCause(ie)</span><br><span class="line">            <span class="keyword">throw</span> interruptedIoException</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// d.</span></span><br><span class="line">        exceptionReference.<span class="keyword">get</span>()?.let &#123; throwable -&gt;</span><br><span class="line">            <span class="keyword">when</span> (throwable) &#123;</span><br><span class="line">                <span class="keyword">is</span> IOException, <span class="keyword">is</span> Error, <span class="keyword">is</span> RuntimeException -&gt; <span class="keyword">throw</span> throwable</span><br><span class="line">                <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> RuntimeException(throwable)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// e.</span></span><br><span class="line">        <span class="keyword">val</span> result = resultReference.<span class="keyword">get</span>() <span class="keyword">as</span>? Bitmap</span><br><span class="line">                ?: <span class="keyword">throw</span> AssertionError(<span class="string">&quot;Request handler neither returned a result nor an exception.&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> bitmap = result.bitmap</span><br><span class="line">        <span class="keyword">if</span> (picasso.loggingEnabled) &#123;</span><br><span class="line">            log(OWNER_HUNTER, VERB_DECODED, <span class="keyword">data</span>.logId())</span><br><span class="line">        &#125;</span><br><span class="line">        picasso.bitmapDecoded(bitmap)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> transformations = ArrayList&lt;Transformation&gt;(<span class="keyword">data</span>.transformations.size + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">data</span>.needsMatrixTransform() || result.exifRotation != <span class="number">0</span>) &#123;</span><br><span class="line">            transformations += MatrixTransformation(<span class="keyword">data</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        transformations += <span class="keyword">data</span>.transformations</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> transformedResult =</span><br><span class="line">                applyTransformations(picasso, <span class="keyword">data</span>, transformations, result) ?: <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        <span class="keyword">val</span> transformedBitmap = transformedResult.bitmap</span><br><span class="line">        picasso.bitmapTransformed(transformedBitmap)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> transformedResult</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的几部分作用分别是：</p>
<ul>
<li>a.检查内存缓存有没有图片可以直接返回</li>
<li>b.进行重试的计数操作</li>
<li>c.通过CountDownLatch，实现当前线程的阻塞，因为实际上图片加载的工作交给了request.load()方法去做，在load()方法里通过latch.countDown()将CountDownLatch减到0，下面的latch.await()就是要等待前面的load()回调执行完成</li>
<li>d.异常处理</li>
<li>e.对前面load()方法得到的Bitmap进行decode和trandsformations操作并返回结果<br>从这个函数执行过程可知，真正加载图片的操作在load()函数中：</li>
</ul>
<h3 id="3-2-1-2-RequestHandler-load"><a href="#3-2-1-2-RequestHandler-load" class="headerlink" title="3.2.1.2 RequestHandler.load()"></a>3.2.1.2 RequestHandler.load()</h3><p>在BitmapHunter中使用的requestHandler，是在BitmapHunter构建时传入的，往前追溯的话，是在前面的forRequest()函数函数中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">fun <span class="title">forRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                picasso: Picasso,</span></span></span><br><span class="line"><span class="function"><span class="params">                dispatcher: Dispatcher,</span></span></span><br><span class="line"><span class="function"><span class="params">                cache: PlatformLruCache,</span></span></span><br><span class="line"><span class="function"><span class="params">                action: Action</span></span></span><br><span class="line"><span class="function"><span class="params">        )</span>: BitmapHunter </span>&#123;</span><br><span class="line">            val request = action.request</span><br><span class="line">            val requestHandlers = picasso.getRequestHandlers()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Index-based loop to avoid allocating an iterator.</span></span><br><span class="line">            <span class="keyword">for</span> (i in requestHandlers.indices) &#123;</span><br><span class="line">                val requestHandler = requestHandlers[i]</span><br><span class="line">                <span class="keyword">if</span> (requestHandler.canHandleRequest(request)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> BitmapHunter(picasso, dispatcher, cache, requestHandler, action)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> BitmapHunter(picasso, dispatcher, cache, ERRORING_HANDLER, action)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这里遍历picasso的所有RequestHandlers，如果有可以处理当前request的RequestHandler，则直接使用；在picasso中具有以下Handler：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">allRequestHandlers.add(ResourceDrawableRequestHandler.create(context));</span><br><span class="line">allRequestHandlers.add(<span class="keyword">new</span> ResourceRequestHandler(context));</span><br><span class="line">allRequestHandlers.addAll(extraRequestHandlers);</span><br><span class="line">allRequestHandlers.add(<span class="keyword">new</span> ContactsPhotoRequestHandler(context));</span><br><span class="line">allRequestHandlers.add(<span class="keyword">new</span> MediaStoreRequestHandler(context));</span><br><span class="line">allRequestHandlers.add(<span class="keyword">new</span> ContentStreamRequestHandler(context));</span><br><span class="line">allRequestHandlers.add(<span class="keyword">new</span> AssetRequestHandler(context));</span><br><span class="line">allRequestHandlers.add(<span class="keyword">new</span> FileRequestHandler(context));</span><br><span class="line">allRequestHandlers.add(<span class="keyword">new</span> NetworkRequestHandler(callFactory));</span><br><span class="line">requestHandlers = Collections.unmodifiableList(allRequestHandlers);</span><br></pre></td></tr></table></figure>
<p>通过名字可知，是用于处理不同类型的图片加载；对于我们比较常用的网络图片，自然使用的是NetworkRequestHandler，其load()函数如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(<span class="meta">@NonNull</span> <span class="keyword">final</span> Picasso picasso, <span class="meta">@NonNull</span> <span class="keyword">final</span> Request request,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@NonNull</span> <span class="keyword">final</span> Callback callback)</span> </span>&#123;</span><br><span class="line">        okhttp3.Request callRequest = createRequest(request);</span><br><span class="line">        callFactory.newCall(callRequest).enqueue(<span class="keyword">new</span> okhttp3.Callback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!response.isSuccessful()) &#123;</span><br><span class="line">                    callback.onError(<span class="keyword">new</span> ResponseException(response.code(), request.networkPolicy));</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ResponseBody body = response.body();</span><br><span class="line">                <span class="keyword">if</span> (loadedFrom == DISK &amp;&amp; body.contentLength() == <span class="number">0</span>) &#123;</span><br><span class="line">                    body.close();</span><br><span class="line">                    callback.onError(</span><br><span class="line">                            <span class="keyword">new</span> ContentLengthException(</span><br><span class="line">                                    <span class="string">&quot;Received response with 0 content-length header.&quot;</span>));</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (loadedFrom == NETWORK &amp;&amp; body.contentLength() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    picasso.downloadFinished(body.contentLength());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Bitmap bitmap = decodeStream(body.source(), request);</span><br><span class="line">                    callback.onSuccess(<span class="keyword">new</span> Result.Bitmap(bitmap, loadedFrom));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    body.close();</span><br><span class="line">                    callback.onError(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line">                callback.onError(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>有以下两步：</p>
<ul>
<li>通过okhttp来触发网络请求</li>
<li>网络请求成功后通过decodeStream来将网络流decode成Bitmap</li>
</ul>
<p><strong>至此，就看到Picasso是怎样完成网络图片的请求加载了，后面就是通过线程通信把得到的bitmap给到主线程，然后设置到imageView中</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Picasso内置了okhttp来完成网络图片的请求</li>
<li>Picasso的缓存能力也是通过okhttp来完成的</li>
<li>Picasso的功能是很好地封装了加载图片的代码方便用户代码使用</li>
</ul>
]]></content>
      <tags>
        <tag>图片加载框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Glide图片加载库源码学习</title>
    <url>/2021/05/07/Glide%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><blockquote>
<p>Glide is a fast and efficient open source media management and image loading framework for Android that wraps media decoding, memory and disk caching, and resource pooling into a simple and easy to use interface. ——官方介绍</p>
</blockquote>
<p>Glide是Bump Technologies公司开源的一款图片加载框架。Glide这个单词的意思是”滑行“。</p>
<h3 id="示例用法"><a href="#示例用法" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Glide.with(<span class="keyword">this</span>).load(<span class="string">&quot;http://goo.gl/gEgYUd&quot;</span>).into(imageView);</span><br></pre></td></tr></table></figure>
<p><strong>依照示例用法的调用链学习一下Glide的源码</strong></p>
<h3 id="1-Glide-with-Activity-activity"><a href="#1-Glide-with-Activity-activity" class="headerlink" title="1.Glide.with(Activity activity)"></a>1.Glide.with(Activity activity)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(<span class="meta">@NonNull</span> FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getRetriever(activity).get(activity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-getRetriever-Activity-activity-的实现"><a href="#1-1-getRetriever-Activity-activity-的实现" class="headerlink" title="1.1 getRetriever(Activity activity)的实现:"></a>1.1 getRetriever(Activity activity)的实现:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> RequestManagerRetriever <span class="title">getRetriever</span><span class="params">(<span class="meta">@Nullable</span> Context context)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ……</span></span><br><span class="line">  <span class="keyword">return</span> Glide.get(context).getRequestManagerRetriever();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中调用Glide.get()完成了Glide的全局初始化，后面的getRequestManagerRetriever()方法返回Glide的requestManagerRetriever对象</p>
<h3 id="1-2-RequestManagerRetriever-get-Activity-activity"><a href="#1-2-RequestManagerRetriever-get-Activity-activity" class="headerlink" title="1.2 RequestManagerRetriever.get(Activity activity)"></a>1.2 RequestManagerRetriever.get(Activity activity)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(<span class="meta">@NonNull</span> FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">    <span class="keyword">return</span> get(activity.getApplicationContext());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    assertNotDestroyed(activity);</span><br><span class="line">    frameWaiter.registerSelf(activity);</span><br><span class="line">    FragmentManager fm = activity.getSupportFragmentManager();</span><br><span class="line">    <span class="keyword">return</span> supportFragmentGet(activity, fm, <span class="comment">/*parentHint=*/</span> <span class="keyword">null</span>, isActivityVisible(activity));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里判断了一下是不是后台线程，如果是后台线程，调用到同名方法，这里的原因暂时略过不谈；如果是主线程，会调用supportFragmentGet()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestManager <span class="title">supportFragmentGet</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@NonNull</span> Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@NonNull</span> FragmentManager fm,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@Nullable</span> Fragment parentHint,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isParentVisible)</span> </span>&#123;</span><br><span class="line">  SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint);</span><br><span class="line">  RequestManager requestManager = current.getRequestManager();</span><br><span class="line">  <span class="keyword">if</span> (requestManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">   <span class="comment">// TODO(b/27524013): Factor out this Glide.get() call.</span></span><br><span class="line">    Glide glide = Glide.get(context);</span><br><span class="line">    requestManager =</span><br><span class="line">        factory.build(</span><br><span class="line">            glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</span><br><span class="line">    <span class="keyword">if</span> (isParentVisible) &#123;</span><br><span class="line">      requestManager.onStart();</span><br><span class="line">    &#125;</span><br><span class="line">    current.setRequestManager(requestManager);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> requestManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里又调用了一次Glide.get()，是为了确保Glide有被初始化成功<br>关键的代码是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">requestManager =</span><br><span class="line">          factory.build(</span><br><span class="line">              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</span><br></pre></td></tr></table></figure>
<p>这里创建出了requestManager</p>
<p><strong>小结：示例用法的第一环调用Glide.with()，完成了Glide的初始化工作，返回一个RequestManager</strong></p>
<h3 id="2-RequestManager-load-String-string"><a href="#2-RequestManager-load-String-string" class="headerlink" title="2.RequestManager.load(String string)"></a>2.RequestManager.load(String string)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title">load</span><span class="params">(<span class="meta">@Nullable</span> String string)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> asDrawable().load(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用的是asDrawble()的load()方法</p>
<h3 id="2-1-RequestManager-asDrawable"><a href="#2-1-RequestManager-asDrawable" class="headerlink" title="2.1 RequestManager.asDrawable()"></a>2.1 RequestManager.asDrawable()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title">asDrawable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> as(Drawable.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换成RequestBuilder，实现是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;ResourceType&gt; <span class="function">RequestBuilder&lt;ResourceType&gt; <span class="title">as</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@NonNull</span> Class&lt;ResourceType&gt; resourceClass)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RequestBuilder&lt;&gt;(glide, <span class="keyword">this</span>, resourceClass, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里构造RequestBuilder对象时传入的resourceClass就是Drawable.class</p>
<h3 id="2-2-RequestBuilder-load-String-string"><a href="#2-2-RequestBuilder-load-String-string" class="headerlink" title="2.2 RequestBuilder.load(String string)"></a>2.2 RequestBuilder.load(String string)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="title">load</span><span class="params">(<span class="meta">@Nullable</span> String string)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> loadGeneric(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用loadGeneric()方法来实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestBuilder&lt;TranscodeType&gt; <span class="title">loadGeneric</span><span class="params">(<span class="meta">@Nullable</span> Object model)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isAutoCloneEnabled()) &#123;</span><br><span class="line">    <span class="keyword">return</span> clone().loadGeneric(model);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.model = model;</span><br><span class="line">  isModelSet = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">return</span> selfOrThrowIfLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>往下调用selfOrThrowIfLocked()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> T <span class="title">selfOrThrowIfLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isLocked) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;You cannot modify locked T, consider clone()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> self();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续看self()的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">self</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (T) <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如方法名所说，就真的是拿到自身对象</p>
<p><strong>小结，RequestManager.load()方法并没有完成图片加载的工作，在这一步仅仅是构建出了RequestBuilder对象</strong></p>
<h3 id="3-RequestBuilder-into-ImageView-view"><a href="#3-RequestBuilder-into-ImageView-view" class="headerlink" title="3.RequestBuilder.into(ImageView view)"></a>3.RequestBuilder.into(ImageView view)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ViewTarget&lt;ImageView, TranscodeType&gt; <span class="title">into</span><span class="params">(<span class="meta">@NonNull</span> ImageView view)</span> </span>&#123;</span><br><span class="line">  Util.assertMainThread();</span><br><span class="line">  Preconditions.checkNotNull(view);</span><br><span class="line"></span><br><span class="line">  BaseRequestOptions&lt;?&gt; requestOptions = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">if</span> (!requestOptions.isTransformationSet()</span><br><span class="line">      &amp;&amp; requestOptions.isTransformationAllowed()</span><br><span class="line">      &amp;&amp; view.getScaleType() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Clone in this method so that if we use this RequestBuilder to load into a View and then</span></span><br><span class="line">    <span class="comment">// into a different target, we don&#x27;t retain the transformation applied based on the previous</span></span><br><span class="line">    <span class="comment">// View&#x27;s scale type.</span></span><br><span class="line">    <span class="keyword">switch</span> (view.getScaleType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> CENTER_CROP:</span><br><span class="line">        requestOptions = requestOptions.clone().optionalCenterCrop();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> CENTER_INSIDE:</span><br><span class="line">        requestOptions = requestOptions.clone().optionalCenterInside();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FIT_CENTER:</span><br><span class="line">      <span class="keyword">case</span> FIT_START:</span><br><span class="line">      <span class="keyword">case</span> FIT_END:</span><br><span class="line">        requestOptions = requestOptions.clone().optionalFitCenter();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FIT_XY:</span><br><span class="line">        requestOptions = requestOptions.clone().optionalCenterInside();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> CENTER:</span><br><span class="line">      <span class="keyword">case</span> MATRIX:</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// Do nothing.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> into(</span><br><span class="line">      glideContext.buildImageViewTarget(view, transcodeClass),</span><br><span class="line">      <span class="comment">/*targetListener=*/</span> <span class="keyword">null</span>,</span><br><span class="line">      requestOptions,</span><br><span class="line">      Executors.mainThreadExecutor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查线程，然后对进行裁剪设置，最后调用同名的into()方法来进行后续操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class="function">Y <span class="title">into</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@NonNull</span> Y target,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@Nullable</span> RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class="line"><span class="function"><span class="params">    Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> into(target, targetListener, <span class="comment">/*options=*/</span> <span class="keyword">this</span>, callbackExecutor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续向下调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class="function">Y <span class="title">into</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@NonNull</span> Y target,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@Nullable</span> RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class="line"><span class="function"><span class="params">    BaseRequestOptions&lt;?&gt; options,</span></span></span><br><span class="line"><span class="function"><span class="params">    Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">  Preconditions.checkNotNull(target);</span><br><span class="line">  <span class="keyword">if</span> (!isModelSet) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;You must call #load() before calling #into()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Request request = buildRequest(target, targetListener, options, callbackExecutor);</span><br><span class="line"></span><br><span class="line">  Request previous = target.getRequest();</span><br><span class="line">  <span class="keyword">if</span> (request.isEquivalentTo(previous)</span><br><span class="line">      &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!Preconditions.checkNotNull(previous).isRunning()) &#123;</span><br><span class="line">      previous.begin();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  requestManager.clear(target);</span><br><span class="line">  target.setRequest(request);</span><br><span class="line">  requestManager.track(target, request);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法有以下要点：</p>
<ul>
<li>调用buildRequest方法创建Request</li>
<li>对比新创建出来的Request和target本来就有的Request是否一致并且isSkipMemoryCacheWithCompletePreviousRequest为假，<br>isSkipMemoryCacheWithCompletePreviousRequest的实现为：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> !options.isMemoryCacheable() &amp;&amp; previous.isComplete();</span><br></pre></td></tr></table></figure>
这种情况下直接使用previous这个Request</li>
<li>否则，将新创建出来的request设置到target的request上，并且requestManager开始track这个target和request</li>
</ul>
<h3 id="3-1-RequestManager-track-NonNull-Target-lt-gt-target-NonNull-Request-request"><a href="#3-1-RequestManager-track-NonNull-Target-lt-gt-target-NonNull-Request-request" class="headerlink" title="3.1 RequestManager.track(@NonNull Target&lt;?&gt; target, @NonNull Request request)"></a>3.1 RequestManager.track(@NonNull Target&lt;?&gt; target, @NonNull Request request)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">track</span><span class="params">(<span class="meta">@NonNull</span> Target&lt;?&gt; target, <span class="meta">@NonNull</span> Request request)</span> </span>&#123;</span><br><span class="line">  targetTracker.track(target);</span><br><span class="line">  requestTracker.runRequest(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分成了两个tracker，主要关注下面的runRequest()函数的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runRequest</span><span class="params">(<span class="meta">@NonNull</span> Request request)</span> </span>&#123;</span><br><span class="line">  requests.add(request);</span><br><span class="line">  <span class="keyword">if</span> (!isPaused) &#123;</span><br><span class="line">    request.begin();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    request.clear();</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">      Log.v(TAG, <span class="string">&quot;Paused, delaying request&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pendingRequests.add(request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里会调用request的begin()方法真正开启一个请求，Request其实是一个接口，这里的实现类是ThumbnailRequestCoordinator</p>
<h3 id="3-2-ThumbnailRequestCoordinator"><a href="#3-2-ThumbnailRequestCoordinator" class="headerlink" title="3.2 ThumbnailRequestCoordinator"></a>3.2 ThumbnailRequestCoordinator</h3><p>首先看下这个类的结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThumbnailRequestCoordinator</span> <span class="keyword">implements</span> <span class="title">RequestCoordinator</span>, <span class="title">Request</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Nullable</span> <span class="keyword">private</span> <span class="keyword">final</span> RequestCoordinator parent;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object requestLock;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> Request full;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> Request thumb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上包含了两个Request的类成员，full和thumb，从命名可以猜测分别是缩略图和大图对应的Request</p>
<p>接下来看下它的begin()方法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (requestLock) &#123;</span><br><span class="line">    isRunningDuringBegin = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// If the request has completed previously, there&#x27;s no need to restart both the full and the</span></span><br><span class="line">      <span class="comment">// thumb, we can just restart the full.</span></span><br><span class="line">      <span class="keyword">if</span> (fullState != RequestState.SUCCESS &amp;&amp; thumbState != RequestState.RUNNING) &#123;</span><br><span class="line">        thumbState = RequestState.RUNNING;</span><br><span class="line">        thumb.begin();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isRunningDuringBegin &amp;&amp; fullState != RequestState.RUNNING) &#123;</span><br><span class="line">        fullState = RequestState.RUNNING;</span><br><span class="line">        full.begin();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      isRunningDuringBegin = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会分别调用thumb和full的begin()方法；full的实现类是SingleRequest，接下来看下SingleRequest的begin()方法</p>
<h3 id="3-3-SingleRequest-begin"><a href="#3-3-SingleRequest-begin" class="headerlink" title="3.3 SingleRequest.begin()"></a>3.3 SingleRequest.begin()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (requestLock) &#123;</span><br><span class="line">    assertNotCallingCallbacks();</span><br><span class="line">    stateVerifier.throwIfRecycled();</span><br><span class="line">    startTime = LogTime.getLogTime();</span><br><span class="line">    <span class="keyword">if</span> (model == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class="line">        width = overrideWidth;</span><br><span class="line">        height = overrideHeight;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> logLevel = getFallbackDrawable() == <span class="keyword">null</span> ? Log.WARN : Log.DEBUG;</span><br><span class="line">      onLoadFailed(<span class="keyword">new</span> GlideException(<span class="string">&quot;Received null model&quot;</span>), logLevel);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status == Status.RUNNING) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Cannot restart a running request&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status == Status.COMPLETE) &#123;</span><br><span class="line">      onResourceReady(</span><br><span class="line">          resource, DataSource.MEMORY_CACHE, <span class="comment">/* isLoadedFromAlternateCacheKey= */</span> <span class="keyword">false</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status = Status.WAITING_FOR_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class="line">      onSizeReady(overrideWidth, overrideHeight);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      target.getSize(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)</span><br><span class="line">        &amp;&amp; canNotifyStatusChanged()) &#123;</span><br><span class="line">      target.onLoadStarted(getPlaceholderDrawable());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (IS_VERBOSE_LOGGABLE) &#123;</span><br><span class="line">      logV(<span class="string">&quot;finished run method in &quot;</span> + LogTime.getElapsedMillis(startTime));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个函数中会对当前状态进行判断，当处于COMPLETE时直接调用onResourceReady()方法并返回；正常来说会调用到onSizeReady()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSizeReady</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">  stateVerifier.throwIfRecycled();</span><br><span class="line">  <span class="keyword">synchronized</span> (requestLock) &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">    <span class="keyword">if</span> (status != Status.WAITING_FOR_SIZE) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    status = Status.RUNNING;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> sizeMultiplier = requestOptions.getSizeMultiplier();</span><br><span class="line">    <span class="keyword">this</span>.width = maybeApplySizeMultiplier(width, sizeMultiplier);</span><br><span class="line">    <span class="keyword">this</span>.height = maybeApplySizeMultiplier(height, sizeMultiplier);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">    loadStatus =</span><br><span class="line">        engine.load(</span><br><span class="line">            glideContext,</span><br><span class="line">            model,</span><br><span class="line">            requestOptions.getSignature(),</span><br><span class="line">            <span class="keyword">this</span>.width,</span><br><span class="line">            <span class="keyword">this</span>.height,</span><br><span class="line">            requestOptions.getResourceClass(),</span><br><span class="line">            transcodeClass,</span><br><span class="line">            priority,</span><br><span class="line">            requestOptions.getDiskCacheStrategy(),</span><br><span class="line">            requestOptions.getTransformations(),</span><br><span class="line">            requestOptions.isTransformationRequired(),</span><br><span class="line">            requestOptions.isScaleOnlyOrNoTransform(),</span><br><span class="line">            requestOptions.getOptions(),</span><br><span class="line">            requestOptions.isMemoryCacheable(),</span><br><span class="line">            requestOptions.getUseUnlimitedSourceGeneratorsPool(),</span><br><span class="line">            requestOptions.getUseAnimationPool(),</span><br><span class="line">            requestOptions.getOnlyRetrieveFromCache(),</span><br><span class="line">            <span class="keyword">this</span>,</span><br><span class="line">            callbackExecutor);</span><br><span class="line">    <span class="keyword">if</span> (status != Status.RUNNING) &#123;</span><br><span class="line">      loadStatus = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>交给Engine的load()方法来进行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">LoadStatus <span class="title">load</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    GlideContext glideContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    Object model,</span></span></span><br><span class="line"><span class="function"><span class="params">    Key signature,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;?&gt; resourceClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;R&gt; transcodeClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">    DiskCacheStrategy diskCacheStrategy,</span></span></span><br><span class="line"><span class="function"><span class="params">    Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isTransformationRequired,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isScaleOnlyOrNoTransform,</span></span></span><br><span class="line"><span class="function"><span class="params">    Options options,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isMemoryCacheable,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> useUnlimitedSourceExecutorPool,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> useAnimationPool,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> onlyRetrieveFromCache,</span></span></span><br><span class="line"><span class="function"><span class="params">    ResourceCallback cb,</span></span></span><br><span class="line"><span class="function"><span class="params">    Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> startTime = VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  EngineKey key =</span><br><span class="line">      keyFactory.buildKey(</span><br><span class="line">          model,</span><br><span class="line">          signature,</span><br><span class="line">          width,</span><br><span class="line">          height,</span><br><span class="line">          transformations,</span><br><span class="line">          resourceClass,</span><br><span class="line">          transcodeClass,</span><br><span class="line">          options);</span><br><span class="line"></span><br><span class="line">  EngineResource&lt;?&gt; memoryResource;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    memoryResource = loadFromMemory(key, isMemoryCacheable, startTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (memoryResource == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> waitForExistingOrStartNewJob(</span><br><span class="line">          glideContext,</span><br><span class="line">          model,</span><br><span class="line">          signature,</span><br><span class="line">          width,</span><br><span class="line">          height,</span><br><span class="line">          resourceClass,</span><br><span class="line">          transcodeClass,</span><br><span class="line">          priority,</span><br><span class="line">          diskCacheStrategy,</span><br><span class="line">          transformations,</span><br><span class="line">          isTransformationRequired,</span><br><span class="line">          isScaleOnlyOrNoTransform,</span><br><span class="line">          options,</span><br><span class="line">          isMemoryCacheable,</span><br><span class="line">          useUnlimitedSourceExecutorPool,</span><br><span class="line">          useAnimationPool,</span><br><span class="line">          onlyRetrieveFromCache,</span><br><span class="line">          cb,</span><br><span class="line">          callbackExecutor,</span><br><span class="line">          key,</span><br><span class="line">          startTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cb.onResourceReady(</span><br><span class="line">      memoryResource, DataSource.MEMORY_CACHE, <span class="comment">/* isLoadedFromAlternateCacheKey= */</span> <span class="keyword">false</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先会尝试从内存缓存中取图片，如果取不到，将调用waitForExistingOrStartNewJob()方法来获取图片</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;R&gt; <span class="function">LoadStatus <span class="title">waitForExistingOrStartNewJob</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    GlideContext glideContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    Object model,</span></span></span><br><span class="line"><span class="function"><span class="params">    Key signature,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;?&gt; resourceClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;R&gt; transcodeClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">    DiskCacheStrategy diskCacheStrategy,</span></span></span><br><span class="line"><span class="function"><span class="params">    Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isTransformationRequired,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isScaleOnlyOrNoTransform,</span></span></span><br><span class="line"><span class="function"><span class="params">    Options options,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isMemoryCacheable,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> useUnlimitedSourceExecutorPool,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> useAnimationPool,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> onlyRetrieveFromCache,</span></span></span><br><span class="line"><span class="function"><span class="params">    ResourceCallback cb,</span></span></span><br><span class="line"><span class="function"><span class="params">    Executor callbackExecutor,</span></span></span><br><span class="line"><span class="function"><span class="params">    EngineKey key,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">long</span> startTime)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);</span><br><span class="line">  <span class="keyword">if</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">    current.addCallback(cb, callbackExecutor);</span><br><span class="line">    <span class="keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">      logWithTimeAndKey(<span class="string">&quot;Added to existing load&quot;</span>, startTime, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, current);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  EngineJob&lt;R&gt; engineJob =</span><br><span class="line">      engineJobFactory.build(</span><br><span class="line">          key,</span><br><span class="line">          isMemoryCacheable,</span><br><span class="line">          useUnlimitedSourceExecutorPool,</span><br><span class="line">          useAnimationPool,</span><br><span class="line">          onlyRetrieveFromCache);</span><br><span class="line"></span><br><span class="line">  DecodeJob&lt;R&gt; decodeJob =</span><br><span class="line">      decodeJobFactory.build(</span><br><span class="line">          glideContext,</span><br><span class="line">          model,</span><br><span class="line">          key,</span><br><span class="line">          signature,</span><br><span class="line">          width,</span><br><span class="line">          height,</span><br><span class="line">          resourceClass,</span><br><span class="line">          transcodeClass,</span><br><span class="line">          priority,</span><br><span class="line">          diskCacheStrategy,</span><br><span class="line">          transformations,</span><br><span class="line">          isTransformationRequired,</span><br><span class="line">          isScaleOnlyOrNoTransform,</span><br><span class="line">          onlyRetrieveFromCache,</span><br><span class="line">          options,</span><br><span class="line">          engineJob);</span><br><span class="line"></span><br><span class="line">  jobs.put(key, engineJob);</span><br><span class="line"></span><br><span class="line">  engineJob.addCallback(cb, callbackExecutor);</span><br><span class="line">  engineJob.start(decodeJob);</span><br><span class="line">  <span class="comment">// ……</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, engineJob);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建了两个job，一个engineJob一个decodeJob，engineJob的作用是通过start()方法来执行这个decodeJob</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(DecodeJob&lt;R&gt; decodeJob)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.decodeJob = decodeJob;</span><br><span class="line">  GlideExecutor executor =</span><br><span class="line">      decodeJob.willDecodeFromCache() ? diskCacheExecutor : getActiveSourceExecutor();</span><br><span class="line">  executor.execute(decodeJob);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会进行判断decodeJob是否是从磁盘缓存拿到的资源，从而使用不同的GlideExecutor；随后调用executor来execute这个decodeJob：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="meta">@NonNull</span> Runnable command)</span> </span>&#123;</span><br><span class="line">  delegate.execute(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里delegate的实现类是ThreadPoolExecutor；因此关注下传入的decodeJob的run()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  DataFetcher&lt;?&gt; localFetcher = currentFetcher;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">    runWrapped();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (CallbackException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">      <span class="comment">// ……</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stage != Stage.ENCODE) &#123;</span><br><span class="line">      throwables.add(t);</span><br><span class="line">      notifyFailed();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isCancelled) &#123;</span><br><span class="line">      <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> t;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (localFetcher != <span class="keyword">null</span>) &#123;</span><br><span class="line">      localFetcher.cleanup();</span><br><span class="line">    &#125;</span><br><span class="line">    GlideTrace.endSection();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真正的工作在runWrapped()函数中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runWrapped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (runReason) &#123;</span><br><span class="line">    <span class="keyword">case</span> INITIALIZE:</span><br><span class="line">      stage = getNextStage(Stage.INITIALIZE);</span><br><span class="line">      currentGenerator = getNextGenerator();</span><br><span class="line">      runGenerators();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SWITCH_TO_SOURCE_SERVICE:</span><br><span class="line">      runGenerators();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DECODE_DATA:</span><br><span class="line">      decodeFromRetrievedData();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unrecognized run reason: &quot;</span> + runReason);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要分两步：</p>
<ul>
<li>getNextGenerator()</li>
<li>runGenerators()</li>
</ul>
<h3 id="3-3-1-getNextGenerator"><a href="#3-3-1-getNextGenerator" class="headerlink" title="3.3.1 getNextGenerator()"></a>3.3.1 getNextGenerator()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> DataFetcherGenerator <span class="title">getNextGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (stage) &#123;</span><br><span class="line">    <span class="keyword">case</span> RESOURCE_CACHE:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ResourceCacheGenerator(decodeHelper, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">case</span> DATA_CACHE:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DataCacheGenerator(decodeHelper, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">case</span> SOURCE:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> SourceGenerator(decodeHelper, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">case</span> FINISHED:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unrecognized stage: &quot;</span> + stage);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的作用是根据当前不同的阶段，获取不同的Generator()</p>
<h3 id="3-3-2-runGenerators"><a href="#3-3-2-runGenerators" class="headerlink" title="3.3.2 runGenerators()"></a>3.3.2 runGenerators()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runGenerators</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    currentThread = Thread.currentThread();</span><br><span class="line">    startFetchTime = LogTime.getLogTime();</span><br><span class="line">    <span class="keyword">boolean</span> isStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isCancelled</span><br><span class="line">        &amp;&amp; currentGenerator != <span class="keyword">null</span></span><br><span class="line">        &amp;&amp; !(isStarted = currentGenerator.startNext())) &#123;</span><br><span class="line">      stage = getNextStage(stage);</span><br><span class="line">      currentGenerator = getNextGenerator();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (stage == Stage.SOURCE) &#123;</span><br><span class="line">        reschedule();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((stage == Stage.FINISHED || isCancelled) &amp;&amp; !isStarted) &#123;</span><br><span class="line">      notifyFailed();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里会触发到currentGenerator的startNext()函数，以上面出现的SourceGenerator为例，看下这个startNext()的内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (dataToCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">     Object data = dataToCache;</span><br><span class="line">     dataToCache = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">boolean</span> isDataInCache = cacheData(data);</span><br><span class="line">       <span class="keyword">if</span> (!isDataInCache) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       <span class="comment">// ……</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (sourceCacheGenerator != <span class="keyword">null</span> &amp;&amp; sourceCacheGenerator.startNext()) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   sourceCacheGenerator = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">   loadData = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) &#123;</span><br><span class="line">     loadData = helper.getLoadData().get(loadDataListIndex++);</span><br><span class="line">     <span class="keyword">if</span> (loadData != <span class="keyword">null</span></span><br><span class="line">         &amp;&amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())</span><br><span class="line">             || helper.hasLoadPath(loadData.fetcher.getDataClass()))) &#123;</span><br><span class="line">       started = <span class="keyword">true</span>;</span><br><span class="line">       startNextLoad(loadData);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> started;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>首先会判断是否命中缓存，命中则直接返回，否则最后会调用到startNextLoad()函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startNextLoad</span><span class="params">(<span class="keyword">final</span> LoadData&lt;?&gt; toStart)</span> </span>&#123;</span><br><span class="line">  loadData.fetcher.loadData(</span><br><span class="line">      helper.getPriority(),</span><br><span class="line">      <span class="keyword">new</span> DataCallback&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataReady</span><span class="params">(<span class="meta">@Nullable</span> Object data)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (isCurrentRequest(toStart)) &#123;</span><br><span class="line">            onDataReadyInternal(toStart, data);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadFailed</span><span class="params">(<span class="meta">@NonNull</span> Exception e)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (isCurrentRequest(toStart)) &#123;</span><br><span class="line">            onLoadFailedInternal(toStart, e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在startNextLoad()函数中，使用loadData.fetcher.loadData()进行了图片加载操作；对于网络图片而言，使用的fetcher就是HttpUrlFetcher</p>
<h3 id="HttpUrlFetcher-loadData"><a href="#HttpUrlFetcher-loadData" class="headerlink" title="HttpUrlFetcher.loadData()"></a>HttpUrlFetcher.loadData()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@NonNull</span> Priority priority, <span class="meta">@NonNull</span> DataCallback&lt;? <span class="keyword">super</span> InputStream&gt; callback)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    InputStream result = loadDataWithRedirects(glideUrl.toURL(), <span class="number">0</span>, <span class="keyword">null</span>, glideUrl.getHeaders());</span><br><span class="line">    callback.onDataReady(result);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">    callback.onLoadFailed(e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用loadDataWithRedirects()方法来进行图片请求，得到InputStream</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> InputStream <span class="title">loadDataWithRedirects</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    URL url, <span class="keyword">int</span> redirects, URL lastUrl, Map&lt;String, String&gt; headers)</span> <span class="keyword">throws</span> HttpException </span>&#123;</span><br><span class="line">  <span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">  urlConnection = buildAndConfigureConnection(url, headers);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    stream = urlConnection.getInputStream();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isCancelled) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> statusCode = getHttpStatusCodeOrInvalid(urlConnection);</span><br><span class="line">  <span class="keyword">if</span> (isHttpOk(statusCode)) &#123;</span><br><span class="line">    <span class="keyword">return</span> getStreamForSuccessfulRequest(urlConnection);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isHttpRedirect(statusCode)) &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusCode == INVALID_STATUS_CODE) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(statusCode);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这个方法能看出，对于网络图片，Glide是通过HttpUrlConnection来进行请求的，最后会返回HttpUrlConnection得到的InputStream。</p>
<p><strong>通过HttpUrlConnection得到图片的InputStream知道，就是图片的解码操作，最终把图片加载到控件上</strong></p>
]]></content>
      <tags>
        <tag>图片加载框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Fresco图片加载库源码学习</title>
    <url>/2021/05/07/Fresco%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><blockquote>
<p>Fresco is a powerful system for displaying images in Android applications. ——官方说明</p>
</blockquote>
<p>Fresco是Facebook公司开源的一款图片加载框架。Fresco一词的含义是“壁画”。</p>
<h3 id="示例用法"><a href="#示例用法" class="headerlink" title="示例用法"></a>示例用法</h3><p>进行全局初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate();</span><br><span class="line">		Fresco.initialize(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作为控件使用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;com.facebook.drawee.view.SimpleDraweeView</span><br><span class="line">    android:id=&quot;@+id/my_image_view&quot;</span><br><span class="line">    android:layout_width=&quot;130dp&quot;</span><br><span class="line">    android:layout_height=&quot;130dp&quot;</span><br><span class="line">    fresco:placeholderImage=&quot;@drawable/my_drawable&quot;</span><br><span class="line">  /&gt;</span><br></pre></td></tr></table></figure>
<p>设置网络图片源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Uri uri = Uri.parse(<span class="string">&quot;https://raw.githubusercontent.com/facebook/fresco/gh-pages/static/logo.png&quot;</span>);</span><br><span class="line">SimpleDraweeView draweeView = (SimpleDraweeView) findViewById(R.id.my_image_view);</span><br><span class="line">draweeView.setImageURI(uri);</span><br></pre></td></tr></table></figure>

<p>从初始化开始进行源码的学习</p>
<h3 id="1-Fresco-initialize-Context-context"><a href="#1-Fresco-initialize-Context-context" class="headerlink" title="1.Fresco.initialize(Context context)"></a>1.Fresco.initialize(Context context)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">  initialize(context, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@Nullable</span> ImagePipelineConfig imagePipelineConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@Nullable</span> DraweeConfig draweeConfig)</span> </span>&#123;</span><br><span class="line">  initialize(context, imagePipelineConfig, draweeConfig, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@Nullable</span> ImagePipelineConfig imagePipelineConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@Nullable</span> DraweeConfig draweeConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> useNativeCode)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (FrescoSystrace.isTracing()) &#123;</span><br><span class="line">    FrescoSystrace.beginSection(<span class="string">&quot;Fresco#initialize&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (sIsInitialized) &#123;</span><br><span class="line">    FLog.w(</span><br><span class="line">        TAG,</span><br><span class="line">        <span class="string">&quot;Fresco has already been initialized! `Fresco.initialize(...)` should only be called &quot;</span></span><br><span class="line">            + <span class="string">&quot;1 single time to avoid memory leaks!&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sIsInitialized = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  NativeCodeSetup.setUseNativeCode(useNativeCode);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!NativeLoader.isInitialized()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (FrescoSystrace.isTracing()) &#123;</span><br><span class="line">      FrescoSystrace.beginSection(<span class="string">&quot;Fresco.initialize-&gt;SoLoader.init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Class&lt;?&gt; clazz =</span><br><span class="line">          Class.forName(<span class="string">&quot;com.facebook.imagepipeline.nativecode.NativeCodeInitializer&quot;</span>);</span><br><span class="line">      clazz.getMethod(<span class="string">&quot;init&quot;</span>, Context.class).invoke(<span class="keyword">null</span>, context);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">      <span class="comment">// Failed to initialize SoLoader</span></span><br><span class="line">      NativeLoader.initIfUninitialized(<span class="keyword">new</span> SystemDelegate());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">      <span class="comment">// Failed to initialize SoLoader</span></span><br><span class="line">      NativeLoader.initIfUninitialized(<span class="keyword">new</span> SystemDelegate());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">      <span class="comment">// Failed to initialize SoLoader</span></span><br><span class="line">      NativeLoader.initIfUninitialized(<span class="keyword">new</span> SystemDelegate());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">      <span class="comment">// Failed to initialize SoLoader</span></span><br><span class="line">      NativeLoader.initIfUninitialized(<span class="keyword">new</span> SystemDelegate());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (FrescoSystrace.isTracing()) &#123;</span><br><span class="line">        FrescoSystrace.endSection();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// we should always use the application context to avoid memory leaks</span></span><br><span class="line">  context = context.getApplicationContext();</span><br><span class="line">  <span class="keyword">if</span> (imagePipelineConfig == <span class="keyword">null</span>) &#123;</span><br><span class="line">    ImagePipelineFactory.initialize(context);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ImagePipelineFactory.initialize(imagePipelineConfig);</span><br><span class="line">  &#125;</span><br><span class="line">  initializeDrawee(context, draweeConfig);</span><br><span class="line">  <span class="keyword">if</span> (FrescoSystrace.isTracing()) &#123;</span><br><span class="line">    FrescoSystrace.endSection();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Fresco的init()中，主要有以下部分：</p>
<ul>
<li>通过Class.forName()将com.facebook.imagepipeline.nativecode.NativeCodeInitializer加载进来</li>
<li>调用ImagePipelineFactory.initialize()进行初始化</li>
<li>调用initializeDrawee()进行初始化</li>
</ul>
<h3 id="1-1-ImagePipelineFactory-initialize"><a href="#1-1-ImagePipelineFactory-initialize" class="headerlink" title="1.1 ImagePipelineFactory.initialize()"></a>1.1 ImagePipelineFactory.initialize()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (FrescoSystrace.isTracing()) &#123;</span><br><span class="line">    FrescoSystrace.beginSection(<span class="string">&quot;ImagePipelineFactory#initialize&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  initialize(ImagePipelineConfig.newBuilder(context).build());</span><br><span class="line">  <span class="keyword">if</span> (FrescoSystrace.isTracing()) &#123;</span><br><span class="line">    FrescoSystrace.endSection();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用的是同名函数:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ImagePipelineConfigInterface imagePipelineConfig)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (sInstance != <span class="keyword">null</span>) &#123;</span><br><span class="line">    FLog.w(</span><br><span class="line">        TAG,</span><br><span class="line">        <span class="string">&quot;ImagePipelineFactory has already been initialized! `ImagePipelineFactory.initialize(...)` should only be called once to avoid unexpected behavior.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sInstance = <span class="keyword">new</span> ImagePipelineFactory(imagePipelineConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是个单例模式，创建出ImagePipelineFactory的实例</p>
<h3 id="1-2-Fresco-initializeDrawee"><a href="#1-2-Fresco-initializeDrawee" class="headerlink" title="1.2 Fresco.initializeDrawee()"></a>1.2 Fresco.initializeDrawee()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initializeDrawee</span><span class="params">(Context context, <span class="meta">@Nullable</span> DraweeConfig draweeConfig)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (FrescoSystrace.isTracing()) &#123;</span><br><span class="line">    FrescoSystrace.beginSection(<span class="string">&quot;Fresco.initializeDrawee&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  sDraweeControllerBuilderSupplier =</span><br><span class="line">      <span class="keyword">new</span> PipelineDraweeControllerBuilderSupplier(context, draweeConfig);</span><br><span class="line">  SimpleDraweeView.initialize(sDraweeControllerBuilderSupplier);</span><br><span class="line">  <span class="keyword">if</span> (FrescoSystrace.isTracing()) &#123;</span><br><span class="line">    FrescoSystrace.endSection();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建出PipelineDraweeControllerBuilderSupplier实例，随后调用SimpleDraweeView的initialize()函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Supplier&lt;? extends AbstractDraweeControllerBuilder&gt; draweeControllerBuilderSupplier)</span> </span>&#123;</span><br><span class="line">  sDraweecontrollerbuildersupplier = draweeControllerBuilderSupplier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将传入的draweeControllerBuilderSupplier赋值给成员变量</p>
<p><strong>上面就是Fresco的初始化过程，接下来看下使用时调用draweeView.setImageURI(uri)是如何完成网络图片的加载的</strong></p>
<h3 id="2-SimpleDraweeView-setImageURI-uri"><a href="#2-SimpleDraweeView-setImageURI-uri" class="headerlink" title="2. SimpleDraweeView.setImageURI(uri)"></a>2. SimpleDraweeView.setImageURI(uri)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImageURI</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">  setImageURI(uri, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImageURI</span><span class="params">(Uri uri, <span class="meta">@Nullable</span> Object callerContext)</span> </span>&#123;</span><br><span class="line">  DraweeController controller =</span><br><span class="line">      mControllerBuilder</span><br><span class="line">          .setCallerContext(callerContext)</span><br><span class="line">          .setUri(uri)</span><br><span class="line">          .setOldController(getController())</span><br><span class="line">          .build();</span><br><span class="line">  setController(controller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是通过builder模式构造出一个DraweeController，然后调用setController()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setController</span><span class="params">(<span class="meta">@Nullable</span> DraweeController draweeController)</span> </span>&#123;</span><br><span class="line">  mDraweeHolder.setController(draweeController);</span><br><span class="line">  <span class="keyword">super</span>.setImageDrawable(mDraweeHolder.getTopLevelDrawable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有两部分：</p>
<ul>
<li>DraweeHolder.setController()</li>
<li>这里的super就是原生的ImageView，因此关注的应该是后面mDraweeHolder.getTopLevelDrawable()的实现</li>
</ul>
<h3 id="2-1-DraweeHolder-setController"><a href="#2-1-DraweeHolder-setController" class="headerlink" title="2.1 DraweeHolder.setController()"></a>2.1 DraweeHolder.setController()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setController</span><span class="params">(<span class="meta">@Nullable</span> DraweeController draweeController)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> wasAttached = mIsControllerAttached;</span><br><span class="line">  <span class="keyword">if</span> (wasAttached) &#123;</span><br><span class="line">    detachController();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Clear the old controller</span></span><br><span class="line">  <span class="keyword">if</span> (isControllerValid()) &#123;</span><br><span class="line">    mEventTracker.recordEvent(Event.ON_CLEAR_OLD_CONTROLLER);</span><br><span class="line">    mController.setHierarchy(<span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  mController = draweeController;</span><br><span class="line">  <span class="keyword">if</span> (mController != <span class="keyword">null</span>) &#123;</span><br><span class="line">    mEventTracker.recordEvent(Event.ON_SET_CONTROLLER);</span><br><span class="line">    mController.setHierarchy(mHierarchy);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mEventTracker.recordEvent(Event.ON_CLEAR_CONTROLLER);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (wasAttached) &#123;</span><br><span class="line">    attachController();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要的工作是调用attchController():</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attachController</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (mIsControllerAttached) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  mEventTracker.recordEvent(Event.ON_ATTACH_CONTROLLER);</span><br><span class="line">  mIsControllerAttached = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (mController != <span class="keyword">null</span> &amp;&amp; mController.getHierarchy() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    mController.onAttach();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>触发的是mController的onAttach()回调，这里的mController实现类是PipelineDraweeController，但PipelineDraweeController没有重写onAttach()，看下PipelineDraweeController父类AbstractDraweeController的onAttach()函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (FrescoSystrace.isTracing()) &#123;</span><br><span class="line">    FrescoSystrace.beginSection(<span class="string">&quot;AbstractDraweeController#onAttach&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (FLog.isLoggable(FLog.VERBOSE)) &#123;</span><br><span class="line">    FLog.v(</span><br><span class="line">        TAG,</span><br><span class="line">        <span class="string">&quot;controller %x %s: onAttach: %s&quot;</span>,</span><br><span class="line">        System.identityHashCode(<span class="keyword">this</span>),</span><br><span class="line">        mId,</span><br><span class="line">        mIsRequestSubmitted ? <span class="string">&quot;request already submitted&quot;</span> : <span class="string">&quot;request needs submit&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  mEventTracker.recordEvent(Event.ON_ATTACH_CONTROLLER);</span><br><span class="line">  Preconditions.checkNotNull(mSettableDraweeHierarchy);</span><br><span class="line">  mDeferredReleaser.cancelDeferredRelease(<span class="keyword">this</span>);</span><br><span class="line">  mIsAttached = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (!mIsRequestSubmitted) &#123;</span><br><span class="line">    submitRequest();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (FrescoSystrace.isTracing()) &#123;</span><br><span class="line">    FrescoSystrace.endSection();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在onAttach()中会调用submitRequest()方法，从方法名中可以猜测这个方法的作用是用来发起图片请求的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">submitRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (FrescoSystrace.isTracing()) &#123;</span><br><span class="line">    FrescoSystrace.beginSection(<span class="string">&quot;AbstractDraweeController#submitRequest&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> T closeableImage = getCachedImage();</span><br><span class="line">  <span class="keyword">if</span> (closeableImage != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (FrescoSystrace.isTracing()) &#123;</span><br><span class="line">      FrescoSystrace.beginSection(<span class="string">&quot;AbstractDraweeController#submitRequest-&gt;cache&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mDataSource = <span class="keyword">null</span>;</span><br><span class="line">    mIsRequestSubmitted = <span class="keyword">true</span>;</span><br><span class="line">    mHasFetchFailed = <span class="keyword">false</span>;</span><br><span class="line">    mEventTracker.recordEvent(Event.ON_SUBMIT_CACHE_HIT);</span><br><span class="line">    reportSubmit(mDataSource, getImageInfo(closeableImage));</span><br><span class="line">    onImageLoadedFromCacheImmediately(mId, closeableImage);</span><br><span class="line">    onNewResultInternal(mId, mDataSource, closeableImage, <span class="number">1.0f</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (FrescoSystrace.isTracing()) &#123;</span><br><span class="line">      FrescoSystrace.endSection();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (FrescoSystrace.isTracing()) &#123;</span><br><span class="line">      FrescoSystrace.endSection();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  mEventTracker.recordEvent(Event.ON_DATASOURCE_SUBMIT);</span><br><span class="line">  mSettableDraweeHierarchy.setProgress(<span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">  mIsRequestSubmitted = <span class="keyword">true</span>;</span><br><span class="line">  mHasFetchFailed = <span class="keyword">false</span>;</span><br><span class="line">  mDataSource = getDataSource();</span><br><span class="line">  reportSubmit(mDataSource, <span class="keyword">null</span>);</span><br><span class="line">  <span class="comment">// ……</span></span><br><span class="line">  <span class="keyword">final</span> String id = mId;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">boolean</span> wasImmediate = mDataSource.hasResult();</span><br><span class="line">  <span class="keyword">final</span> DataSubscriber&lt;T&gt; dataSubscriber =</span><br><span class="line">      <span class="keyword">new</span> BaseDataSubscriber&lt;T&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNewResultImpl</span><span class="params">(DataSource&lt;T&gt; dataSource)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">boolean</span> isFinished = dataSource.isFinished();</span><br><span class="line">          <span class="keyword">boolean</span> hasMultipleResults = dataSource.hasMultipleResults();</span><br><span class="line">          <span class="keyword">float</span> progress = dataSource.getProgress();</span><br><span class="line">          T image = dataSource.getResult();</span><br><span class="line">          <span class="keyword">if</span> (image != <span class="keyword">null</span>) &#123;</span><br><span class="line">            onNewResultInternal(</span><br><span class="line">                id, dataSource, image, progress, isFinished, wasImmediate, hasMultipleResults);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isFinished) &#123;</span><br><span class="line">            onFailureInternal(id, dataSource, <span class="keyword">new</span> NullPointerException(), <span class="comment">/* isFinished */</span> <span class="keyword">true</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailureImpl</span><span class="params">(DataSource&lt;T&gt; dataSource)</span> </span>&#123;</span><br><span class="line">          onFailureInternal(id, dataSource, dataSource.getFailureCause(), <span class="comment">/* isFinished */</span> <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(DataSource&lt;T&gt; dataSource)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">boolean</span> isFinished = dataSource.isFinished();</span><br><span class="line">          <span class="keyword">float</span> progress = dataSource.getProgress();</span><br><span class="line">          onProgressUpdateInternal(id, dataSource, progress, isFinished);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">  mDataSource.subscribe(dataSubscriber, mUiThreadImmediateExecutor);</span><br><span class="line">  <span class="keyword">if</span> (FrescoSystrace.isTracing()) &#123;</span><br><span class="line">    FrescoSystrace.endSection();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数略长，分成以下几个部分：</p>
<ul>
<li>1.通过getCachedImage()方法尝试从内存缓存中读取图片，如果能拿到，则调用相关回调后直接返回</li>
<li>2.如果通过getCachedImage()拿不到缓存的图片，则调用getDataSource()方法获取数据源mDataSource</li>
<li>3.定义DataSubscriber，随后通过mDataSource.subscribe()传入DataSubscriber进行数据的订阅操作<br>下面具体看下这3部分的实现：</li>
</ul>
<h3 id="2-1-1-PipelineDraweeController-getCachedImage"><a href="#2-1-1-PipelineDraweeController-getCachedImage" class="headerlink" title="2.1.1 PipelineDraweeController.getCachedImage()"></a>2.1.1 PipelineDraweeController.getCachedImage()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="meta">@Nullable</span> <span class="function">CloseableReference&lt;CloseableImage&gt; <span class="title">getCachedImage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (FrescoSystrace.isTracing()) &#123;</span><br><span class="line">    FrescoSystrace.beginSection(<span class="string">&quot;PipelineDraweeController#getCachedImage&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mMemoryCache == <span class="keyword">null</span> || mCacheKey == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We get the CacheKey</span></span><br><span class="line">    CloseableReference&lt;CloseableImage&gt; closeableImage = mMemoryCache.get(mCacheKey);</span><br><span class="line">    <span class="keyword">if</span> (closeableImage != <span class="keyword">null</span> &amp;&amp; !closeableImage.get().getQualityInfo().isOfFullQuality()) &#123;</span><br><span class="line">      closeableImage.close();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> closeableImage;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (FrescoSystrace.isTracing()) &#123;</span><br><span class="line">      FrescoSystrace.endSection();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的CloseableImage是对Bitmap的一个封装，通过它可以获得我们需要的Bitmap；这里内存缓存实现的策略是常见的LRU策略，底层是LinkedHashMap实现</p>
<h3 id="2-1-2-PipelineDraweeController-getDataSource"><a href="#2-1-2-PipelineDraweeController-getDataSource" class="headerlink" title="2.1.2 PipelineDraweeController.getDataSource()"></a>2.1.2 PipelineDraweeController.getDataSource()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> DataSource&lt;CloseableReference&lt;CloseableImage&gt;&gt; getDataSource() &#123;</span><br><span class="line">  <span class="keyword">if</span> (FrescoSystrace.isTracing()) &#123;</span><br><span class="line">    FrescoSystrace.beginSection(<span class="string">&quot;PipelineDraweeController#getDataSource&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (FLog.isLoggable(FLog.VERBOSE)) &#123;</span><br><span class="line">    FLog.v(TAG, <span class="string">&quot;controller %x: getDataSource&quot;</span>, System.identityHashCode(<span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  DataSource&lt;CloseableReference&lt;CloseableImage&gt;&gt; result = mDataSourceSupplier.get();</span><br><span class="line">  <span class="keyword">if</span> (FrescoSystrace.isTracing()) &#123;</span><br><span class="line">    FrescoSystrace.endSection();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的mDataSourceSupplier的实现类是一个匿名类，实现在AbstractDraweeControllerBuilder中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Supplier&lt;DataSource&lt;IMAGE&gt;&gt; getDataSourceSupplierForRequest(</span><br><span class="line">    <span class="keyword">final</span> DraweeController controller,</span><br><span class="line">    <span class="keyword">final</span> String controllerId,</span><br><span class="line">    <span class="keyword">final</span> REQUEST imageRequest,</span><br><span class="line">    <span class="keyword">final</span> CacheLevel cacheLevel) &#123;</span><br><span class="line">  <span class="keyword">final</span> Object callerContext = getCallerContext();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Supplier&lt;DataSource&lt;IMAGE&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource&lt;IMAGE&gt; <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> getDataSourceForRequest(</span><br><span class="line">          controller, controllerId, imageRequest, callerContext, cacheLevel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Objects.toStringHelper(<span class="keyword">this</span>).add(<span class="string">&quot;request&quot;</span>, imageRequest.toString()).toString();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这里可以看出，对mDataSourceSupplier调用get()方法，实际上是调用到getDataSourceForRequest()方法，而这个方法是一个抽象方法，在PipelineDraweeController使用的实现是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> DataSource&lt;CloseableReference&lt;CloseableImage&gt;&gt; getDataSourceForRequest(</span><br><span class="line">    DraweeController controller,</span><br><span class="line">    String controllerId,</span><br><span class="line">    ImageRequest imageRequest,</span><br><span class="line">    Object callerContext,</span><br><span class="line">    AbstractDraweeControllerBuilder.CacheLevel cacheLevel) &#123;</span><br><span class="line">  <span class="keyword">return</span> mImagePipeline.fetchDecodedImage(</span><br><span class="line">      imageRequest,</span><br><span class="line">      callerContext,</span><br><span class="line">      convertCacheLevelToRequestLevel(cacheLevel),</span><br><span class="line">      getRequestListener(controller),</span><br><span class="line">      controllerId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-2-1-ImagePipeline-fetchDecodedImage"><a href="#2-1-2-1-ImagePipeline-fetchDecodedImage" class="headerlink" title="2.1.2.1 ImagePipeline.fetchDecodedImage()"></a>2.1.2.1 ImagePipeline.fetchDecodedImage()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DataSource&lt;CloseableReference&lt;CloseableImage&gt;&gt; fetchDecodedImage(</span><br><span class="line">    ImageRequest imageRequest,</span><br><span class="line">    Object callerContext,</span><br><span class="line">    ImageRequest.RequestLevel lowestPermittedRequestLevelOnSubmit,</span><br><span class="line">    <span class="meta">@Nullable</span> RequestListener requestListener,</span><br><span class="line">    <span class="meta">@Nullable</span> String uiComponentId) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Producer&lt;CloseableReference&lt;CloseableImage&gt;&gt; producerSequence =</span><br><span class="line">        mProducerSequenceFactory.getDecodedImageProducerSequence(imageRequest);</span><br><span class="line">    <span class="keyword">return</span> submitFetchRequest(</span><br><span class="line">        producerSequence,</span><br><span class="line">        imageRequest,</span><br><span class="line">        lowestPermittedRequestLevelOnSubmit,</span><br><span class="line">        callerContext,</span><br><span class="line">        requestListener,</span><br><span class="line">        uiComponentId);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">    <span class="keyword">return</span> DataSources.immediateFailedDataSource(exception);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中，创建出了一个Producer&lt;CloseableReference<CloseableImage>&gt;对象，调用submitFetchRequest方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; DataSource&lt;CloseableReference&lt;T&gt;&gt; submitFetchRequest(</span><br><span class="line">    Producer&lt;CloseableReference&lt;T&gt;&gt; producerSequence,</span><br><span class="line">    ImageRequest imageRequest,</span><br><span class="line">    ImageRequest.RequestLevel lowestPermittedRequestLevelOnSubmit,</span><br><span class="line">    Object callerContext,</span><br><span class="line">    <span class="meta">@Nullable</span> RequestListener requestListener,</span><br><span class="line">    <span class="meta">@Nullable</span> String uiComponentId) &#123;</span><br><span class="line">  <span class="keyword">if</span> (FrescoSystrace.isTracing()) &#123;</span><br><span class="line">    FrescoSystrace.beginSection(<span class="string">&quot;ImagePipeline#submitFetchRequest&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> RequestListener2 requestListener2 =</span><br><span class="line">      <span class="keyword">new</span> InternalRequestListener(</span><br><span class="line">          getRequestListenerForRequest(imageRequest, requestListener), mRequestListener2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mCallerContextVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">    mCallerContextVerifier.verifyCallerContext(callerContext, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    ImageRequest.RequestLevel lowestPermittedRequestLevel =</span><br><span class="line">        ImageRequest.RequestLevel.getMax(</span><br><span class="line">            imageRequest.getLowestPermittedRequestLevel(), lowestPermittedRequestLevelOnSubmit);</span><br><span class="line">    SettableProducerContext settableProducerContext =</span><br><span class="line">        <span class="keyword">new</span> SettableProducerContext(</span><br><span class="line">            imageRequest,</span><br><span class="line">            generateUniqueFutureId(),</span><br><span class="line">            uiComponentId,</span><br><span class="line">            requestListener2,</span><br><span class="line">            callerContext,</span><br><span class="line">            lowestPermittedRequestLevel,</span><br><span class="line">            <span class="comment">/* isPrefetch */</span> <span class="keyword">false</span>,</span><br><span class="line">            imageRequest.getProgressiveRenderingEnabled()</span><br><span class="line">                || !UriUtil.isNetworkUri(imageRequest.getSourceUri()),</span><br><span class="line">            imageRequest.getPriority(),</span><br><span class="line">            mConfig);</span><br><span class="line">    <span class="keyword">return</span> CloseableProducerToDataSourceAdapter.create(</span><br><span class="line">        producerSequence, settableProducerContext, requestListener2);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">    <span class="keyword">return</span> DataSources.immediateFailedDataSource(exception);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (FrescoSystrace.isTracing()) &#123;</span><br><span class="line">      FrescoSystrace.endSection();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法里实际上没有执行图片的请求操作，从方法名里的submit也可以看出只是”提交这”个请求，接下来会调用CloseableProducerToDataSourceAdapter.create()返回：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; DataSource&lt;CloseableReference&lt;T&gt;&gt; create(</span><br><span class="line">    Producer&lt;CloseableReference&lt;T&gt;&gt; producer,</span><br><span class="line">    SettableProducerContext settableProducerContext,</span><br><span class="line">    RequestListener2 listener) &#123;</span><br><span class="line">  <span class="keyword">if</span> (FrescoSystrace.isTracing()) &#123;</span><br><span class="line">    FrescoSystrace.beginSection(<span class="string">&quot;CloseableProducerToDataSourceAdapter#create&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  CloseableProducerToDataSourceAdapter&lt;T&gt; result =</span><br><span class="line">      <span class="keyword">new</span> CloseableProducerToDataSourceAdapter&lt;T&gt;(producer, settableProducerContext, listener);</span><br><span class="line">  <span class="keyword">if</span> (FrescoSystrace.isTracing()) &#123;</span><br><span class="line">    FrescoSystrace.endSection();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造CloseableProducerToDataSourceAdapter实例作为结果返回，看下CloseableProducerToDataSourceAdapter的构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">CloseableProducerToDataSourceAdapter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Producer&lt;CloseableReference&lt;T&gt;&gt; producer,</span></span></span><br><span class="line"><span class="function"><span class="params">    SettableProducerContext settableProducerContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    RequestListener2 listener)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(producer, settableProducerContext, listener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用的是超类的构造函数，超类是AbstractProducerToDataSourceAdapter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractProducerToDataSourceAdapter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Producer&lt;T&gt; producer,</span></span></span><br><span class="line"><span class="function"><span class="params">    SettableProducerContext settableProducerContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    RequestListener2 requestListener)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (FrescoSystrace.isTracing()) &#123;</span><br><span class="line">    FrescoSystrace.beginSection(<span class="string">&quot;AbstractProducerToDataSourceAdapter()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  mSettableProducerContext = settableProducerContext;</span><br><span class="line">  mRequestListener = requestListener;</span><br><span class="line">  setInitialExtras();</span><br><span class="line">  <span class="keyword">if</span> (FrescoSystrace.isTracing()) &#123;</span><br><span class="line">    FrescoSystrace.beginSection(<span class="string">&quot;AbstractProducerToDataSourceAdapter()-&gt;onRequestStart&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  mRequestListener.onRequestStart(mSettableProducerContext);</span><br><span class="line">  <span class="keyword">if</span> (FrescoSystrace.isTracing()) &#123;</span><br><span class="line">    FrescoSystrace.endSection();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (FrescoSystrace.isTracing()) &#123;</span><br><span class="line">    FrescoSystrace.beginSection(<span class="string">&quot;AbstractProducerToDataSourceAdapter()-&gt;produceResult&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  producer.produceResults(createConsumer(), settableProducerContext);</span><br><span class="line">  <span class="keyword">if</span> (FrescoSystrace.isTracing()) &#123;</span><br><span class="line">    FrescoSystrace.endSection();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (FrescoSystrace.isTracing()) &#123;</span><br><span class="line">    FrescoSystrace.endSection();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractProducerToDataSourceAdapter的构造函数中多数是日志记录的代码，最关键的代码其实是这一行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">producer.produceResults(createConsumer(), settableProducerContext);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面有两个点分别说一下：</p>
<ul>
<li>producer.produceResults()</li>
<li>createConsumer()</li>
</ul>
<h3 id="2-1-2-2-Producer-produceResults"><a href="#2-1-2-2-Producer-produceResults" class="headerlink" title="2.1.2.2 Producer.produceResults()"></a>2.1.2.2 Producer.produceResults()</h3><p>在Fresco中，Producer是一个接口，负责真正的获取图片的工作，对于网络图片而言，实现类是NetworkFetchProducer：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produceResults</span><span class="params">(Consumer&lt;EncodedImage&gt; consumer, ProducerContext context)</span> </span>&#123;</span><br><span class="line">  context.getProducerListener().onProducerStart(context, PRODUCER_NAME);</span><br><span class="line">  <span class="keyword">final</span> FetchState fetchState = mNetworkFetcher.createFetchState(consumer, context);</span><br><span class="line">  mNetworkFetcher.fetch(</span><br><span class="line">      fetchState,</span><br><span class="line">      <span class="keyword">new</span> NetworkFetcher.Callback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(InputStream response, <span class="keyword">int</span> responseLength)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (FrescoSystrace.isTracing()) &#123;</span><br><span class="line">            FrescoSystrace.beginSection(<span class="string">&quot;NetworkFetcher-&gt;onResponse&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          NetworkFetchProducer.<span class="keyword">this</span>.onResponse(fetchState, response, responseLength);</span><br><span class="line">          <span class="keyword">if</span> (FrescoSystrace.isTracing()) &#123;</span><br><span class="line">            FrescoSystrace.endSection();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">          NetworkFetchProducer.<span class="keyword">this</span>.onFailure(fetchState, throwable);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCancellation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          NetworkFetchProducer.<span class="keyword">this</span>.onCancellation(fetchState);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，是交给mNetworkFetcher.fetch()方法完成网络请求，mNetworkFetcher是NetworkFetcher类型，NetworkFetcher是一个接口，在工程中能够找到以下实现类：</p>
<ul>
<li>BaseNetworkFetcher</li>
<li>HttpUrlConnectionNetworkFetcher</li>
<li>OkHttpNetworkFetcher</li>
<li>PriorityNetworkFetcher</li>
<li>RecordingNetworkFetcher</li>
<li>VolleyNetworkFetcher</li>
</ul>
<p>从命名也可以看出，他们是通过OkHttp/Volley等不同的网络请求框架实现的网络请求；这里我们不再关注内部的网络请求是如何实现的，只需要知道最后能够得到网络图片对应的InputStream<br>拿到InputStream之后，会调用onResponse()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    FetchState fetchState, InputStream responseData, <span class="keyword">int</span> responseContentLength)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> PooledByteBufferOutputStream pooledOutputStream;</span><br><span class="line">  <span class="keyword">if</span> (responseContentLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    pooledOutputStream = mPooledByteBufferFactory.newOutputStream(responseContentLength);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pooledOutputStream = mPooledByteBufferFactory.newOutputStream();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">byte</span>[] ioArray = mByteArrayPool.get(READ_SIZE);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">while</span> ((length = responseData.read(ioArray)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        pooledOutputStream.write(ioArray, <span class="number">0</span>, length);</span><br><span class="line">        maybeHandleIntermediateResult(pooledOutputStream, fetchState);</span><br><span class="line">        <span class="keyword">float</span> progress = calculateProgress(pooledOutputStream.size(), responseContentLength);</span><br><span class="line">        fetchState.getConsumer().onProgressUpdate(progress);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mNetworkFetcher.onFetchCompletion(fetchState, pooledOutputStream.size());</span><br><span class="line">    handleFinalResult(pooledOutputStream, fetchState);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    mByteArrayPool.release(ioArray);</span><br><span class="line">    pooledOutputStream.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法有以下几个要点：</p>
<ul>
<li>通过calculateProgress()方法计算出进度并通知给Consumer</li>
<li>当流数据读取完毕，调用handleFinalResult()方法<br>下面看下handleFinalResult()的实现：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleFinalResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    PooledByteBufferOutputStream pooledOutputStream, FetchState fetchState)</span> </span>&#123;</span><br><span class="line">  Map&lt;String, String&gt; extraMap = getExtraMap(fetchState, pooledOutputStream.size());</span><br><span class="line">  ProducerListener2 listener = fetchState.getListener();</span><br><span class="line">  listener.onProducerFinishWithSuccess(fetchState.getContext(), PRODUCER_NAME, extraMap);</span><br><span class="line">  listener.onUltimateProducerReached(fetchState.getContext(), PRODUCER_NAME, <span class="keyword">true</span>);</span><br><span class="line">  fetchState.getContext().putOriginExtra(<span class="string">&quot;network&quot;</span>);</span><br><span class="line">  notifyConsumer(</span><br><span class="line">      pooledOutputStream,</span><br><span class="line">      Consumer.IS_LAST | fetchState.getOnNewResultStatusFlags(),</span><br><span class="line">      fetchState.getResponseBytesRange(),</span><br><span class="line">      fetchState.getConsumer(),</span><br><span class="line">      fetchState.getContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里会完成最重要的工作：调用notifyConsumer()来对数据进行消费</li>
</ul>
<p><strong>小结，至此，已经从远端网络请求得到图片的数据流，后面是Consumer对这个流的处理工作，这就是前面createConsumer()方法的内容</strong></p>
<h3 id="2-1-2-3-AbstractProducerToDataSourceAdapter-createConsumer"><a href="#2-1-2-3-AbstractProducerToDataSourceAdapter-createConsumer" class="headerlink" title="2.1.2.3 AbstractProducerToDataSourceAdapter.createConsumer()"></a>2.1.2.3 AbstractProducerToDataSourceAdapter.createConsumer()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Consumer&lt;T&gt; <span class="title">createConsumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> BaseConsumer&lt;T&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onNewResultImpl</span><span class="params">(<span class="meta">@Nullable</span> T newResult, <span class="meta">@Status</span> <span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">      AbstractProducerToDataSourceAdapter.<span class="keyword">this</span>.onNewResultImpl(</span><br><span class="line">          newResult, status, mSettableProducerContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onFailureImpl</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">      AbstractProducerToDataSourceAdapter.<span class="keyword">this</span>.onFailureImpl(throwable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCancellationImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      AbstractProducerToDataSourceAdapter.<span class="keyword">this</span>.onCancellationImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdateImpl</span><span class="params">(<span class="keyword">float</span> progress)</span> </span>&#123;</span><br><span class="line">      AbstractProducerToDataSourceAdapter.<span class="keyword">this</span>.setProgress(progress);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在onNewResultImpl()中回调AbstractProducerToDataSourceAdapter的onNewResultImpl()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onNewResultImpl</span><span class="params">(<span class="meta">@Nullable</span> T result, <span class="keyword">int</span> status, ProducerContext producerContext)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> isLast = BaseConsumer.isLast(status);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">super</span>.setResult(result, isLast, getExtras(producerContext))) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isLast) &#123;</span><br><span class="line">      mRequestListener.onRequestSuccess(mSettableProducerContext);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会调用父类的setResult()方法，如果是最终结果，还会触发mRequestListener的回调；看下父类的setResult()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">setResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@Nullable</span> T value, <span class="keyword">boolean</span> isLast, <span class="meta">@Nullable</span> Map&lt;String, Object&gt; extras)</span> </span>&#123;</span><br><span class="line">    setExtras(extras);</span><br><span class="line">    <span class="keyword">boolean</span> result = setResultInternal(value, isLast);</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">      notifyDataSubscribers();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>这里很关键的一点，会调用notifyDataSubscribers()来通知观察者</strong></p>
<p><strong>小结上面就是PipelineDraweeController.getDataSource()部分的内容最终会拿到CloseableProducerToDataSourceAdapter这个DataSource；并且在获取构造DataSource的过程中已经完成了图片请求，接下来关注的是对DataSource的subscribe()方法调用</strong></p>
<h3 id="2-1-3-DataSource-subscribe-final-DataSubscriber-lt-T-gt-dataSubscriber-final-Executor-executor"><a href="#2-1-3-DataSource-subscribe-final-DataSubscriber-lt-T-gt-dataSubscriber-final-Executor-executor" class="headerlink" title="2.1.3   DataSource.subscribe(final DataSubscriber&lt;T&gt; dataSubscriber, final Executor executor)"></a>2.1.3   DataSource.subscribe(final DataSubscriber&lt;T&gt; dataSubscriber, final Executor executor)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(<span class="keyword">final</span> DataSubscriber&lt;T&gt; dataSubscriber, <span class="keyword">final</span> Executor executor)</span> </span>&#123;</span><br><span class="line">  Preconditions.checkNotNull(dataSubscriber);</span><br><span class="line">  Preconditions.checkNotNull(executor);</span><br><span class="line">  <span class="keyword">boolean</span> shouldNotify;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mIsClosed) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDataSourceStatus == DataSourceStatus.IN_PROGRESS) &#123;</span><br><span class="line">      mSubscribers.add(Pair.create(dataSubscriber, executor));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shouldNotify = hasResult() || isFinished() || wasCancelled();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shouldNotify) &#123;</span><br><span class="line">    notifyDataSubscriber(dataSubscriber, executor, hasFailed(), wasCancelled());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会调用到notifyDataSubscriber()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">notifyDataSubscriber</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> DataSubscriber&lt;T&gt; dataSubscriber,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> Executor executor,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">boolean</span> isFailure,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">boolean</span> isCancellation)</span> </span>&#123;</span><br><span class="line">  Runnable runnable =</span><br><span class="line">      <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (isFailure) &#123;</span><br><span class="line">            dataSubscriber.onFailure(AbstractDataSource.<span class="keyword">this</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isCancellation) &#123;</span><br><span class="line">            dataSubscriber.onCancellation(AbstractDataSource.<span class="keyword">this</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dataSubscriber.onNewResult(AbstractDataSource.<span class="keyword">this</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">  <span class="keyword">final</span> DataSourceInstrumenter instrumenter = getDataSourceInstrumenter();</span><br><span class="line">  <span class="keyword">if</span> (instrumenter != <span class="keyword">null</span>) &#123;</span><br><span class="line">    runnable = instrumenter.decorateRunnable(runnable, <span class="string">&quot;AbstractDataSource_notifyDataSubscriber&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  executor.execute(runnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先是调用getDataSourceInstrumenter()方法尝试获取实现类的DataSourceInstrumenter</li>
<li>如果获得的DataSourceInstrumenter不为空，则对runnable进行decorateRunnable操作</li>
<li>使用传入的Executor执行runnable</li>
</ul>
<p>在源码中看了一下getDataSourceInstrumenter()如果用户代码没有介入，默认拿到的应该是空，在execute()执行的，其实就是传入的dataSubscriber的各个回调方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> DataSubscriber&lt;T&gt; dataSubscriber =</span><br><span class="line">        <span class="keyword">new</span> BaseDataSubscriber&lt;T&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNewResultImpl</span><span class="params">(DataSource&lt;T&gt; dataSource)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// isFinished must be obtained before image, otherwise we might set intermediate result</span></span><br><span class="line">            <span class="comment">// as final image.</span></span><br><span class="line">            <span class="keyword">boolean</span> isFinished = dataSource.isFinished();</span><br><span class="line">            <span class="keyword">boolean</span> hasMultipleResults = dataSource.hasMultipleResults();</span><br><span class="line">            <span class="keyword">float</span> progress = dataSource.getProgress();</span><br><span class="line">            T image = dataSource.getResult();</span><br><span class="line">            <span class="keyword">if</span> (image != <span class="keyword">null</span>) &#123;</span><br><span class="line">              onNewResultInternal(</span><br><span class="line">                  id, dataSource, image, progress, isFinished, wasImmediate, hasMultipleResults);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isFinished) &#123;</span><br><span class="line">              onFailureInternal(id, dataSource, <span class="keyword">new</span> NullPointerException(), <span class="comment">/* isFinished */</span> <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailureImpl</span><span class="params">(DataSource&lt;T&gt; dataSource)</span> </span>&#123;</span><br><span class="line">            onFailureInternal(id, dataSource, dataSource.getFailureCause(), <span class="comment">/* isFinished */</span> <span class="keyword">true</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(DataSource&lt;T&gt; dataSource)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">boolean</span> isFinished = dataSource.isFinished();</span><br><span class="line">            <span class="keyword">float</span> progress = dataSource.getProgress();</span><br><span class="line">            onProgressUpdateInternal(id, dataSource, progress, isFinished);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
<p>在onNewResultImpl()的回调中，通过dataSource.getResult()在主线程得到了图片，然后通过触发onNewResultInternal()回调：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onNewResultInternal</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String id,</span></span></span><br><span class="line"><span class="function"><span class="params">    DataSource&lt;T&gt; dataSource,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@Nullable</span> T image,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">float</span> progress,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isFinished,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> wasImmediate,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> deliverTempResult)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">    mEventTracker.recordEvent(</span><br><span class="line">        isFinished ? Event.ON_DATASOURCE_RESULT : Event.ON_DATASOURCE_RESULT_INT);</span><br><span class="line">    <span class="comment">// create drawable</span></span><br><span class="line">    Drawable drawable;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      drawable = createDrawable(image);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">      <span class="comment">// ……</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T previousImage = mFetchedImage;</span><br><span class="line">    Drawable previousDrawable = mDrawable;</span><br><span class="line">    mFetchedImage = image;</span><br><span class="line">    mDrawable = drawable;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// set the new image</span></span><br><span class="line">      <span class="keyword">if</span> (isFinished) &#123;</span><br><span class="line">        logMessageAndImage(<span class="string">&quot;set_final_result @ onNewResult&quot;</span>, image);</span><br><span class="line">        mDataSource = <span class="keyword">null</span>;</span><br><span class="line">        mSettableDraweeHierarchy.setImage(drawable, <span class="number">1f</span>, wasImmediate);</span><br><span class="line">        reportSuccess(id, image, dataSource);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deliverTempResult) &#123;</span><br><span class="line">        logMessageAndImage(<span class="string">&quot;set_temporary_result @ onNewResult&quot;</span>, image);</span><br><span class="line">        mSettableDraweeHierarchy.setImage(drawable, <span class="number">1f</span>, wasImmediate);</span><br><span class="line">        reportSuccess(id, image, dataSource);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logMessageAndImage(<span class="string">&quot;set_intermediate_result @ onNewResult&quot;</span>, image);</span><br><span class="line">        mSettableDraweeHierarchy.setImage(drawable, progress, wasImmediate);</span><br><span class="line">        reportIntermediateSet(id, image);</span><br><span class="line">        <span class="comment">// IMPORTANT: do not execute any instance-specific code after this point</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (previousDrawable != <span class="keyword">null</span> &amp;&amp; previousDrawable != drawable) &#123;</span><br><span class="line">        releaseDrawable(previousDrawable);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (previousImage != <span class="keyword">null</span> &amp;&amp; previousImage != image) &#123;</span><br><span class="line">        logMessageAndImage(<span class="string">&quot;release_previous_result @ onNewResult&quot;</span>, previousImage);</span><br><span class="line">        releaseImage(previousImage);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// ……</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原函数较长，删掉注释和一些异常处理的代码之后，有如下要点：</p>
<ul>
<li>将得到的image，转换成Drawable对象</li>
<li>调用mSettableDraweeHierarchy的setImage()方法把这个Drawable对象设置进去，这里的mSettableDraweeHierarchy是GenericDraweeHierarchy类型<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImage</span><span class="params">(Drawable drawable, <span class="keyword">float</span> progress, <span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">  drawable = WrappingUtils.maybeApplyLeafRounding(drawable, mRoundingParams, mResources);</span><br><span class="line">  drawable.mutate();</span><br><span class="line">  mActualImageWrapper.setDrawable(drawable);</span><br><span class="line">  mFadeDrawable.beginBatchMode();</span><br><span class="line">  fadeOutBranches();</span><br><span class="line">  fadeInLayer(ACTUAL_IMAGE_INDEX);</span><br><span class="line">  setProgress(progress);</span><br><span class="line">  <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">    mFadeDrawable.finishTransitionImmediately();</span><br><span class="line">  &#125;</span><br><span class="line">  mFadeDrawable.endBatchMode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里关键的代码是调用mActualImageWrapper.setDrawable(drawable);把得到的图片对应的drawable设置到mActualImageWrapper这个成员变量上</li>
</ul>
<p><strong>至此，我们完成了DraweeHolder.setController()的这一部分操作，接下来看下mDraweeHolder.getTopLevelDrawable()的实现：</strong></p>
<h3 id="2-2-DraweeHolder-getTopLevelDrawable"><a href="#2-2-DraweeHolder-getTopLevelDrawable" class="headerlink" title="2.2 DraweeHolder.getTopLevelDrawable()"></a>2.2 DraweeHolder.getTopLevelDrawable()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">Drawable <span class="title">getTopLevelDrawable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mHierarchy == <span class="keyword">null</span> ? <span class="keyword">null</span> : mHierarchy.getTopLevelDrawable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里mHierarchy是SettableDraweeHierarchy接口类型，实现类是GenericDraweeHierarchy，看下它的getTopLevelDrawable()实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Drawable <span class="title">getTopLevelDrawable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mTopLevelDrawable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上就只是返回mTopLevelDrawable，而mTopLevelDrawable是在GenericDraweeHierarchy构造方法中创建的，看下构造方法的整个创建过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GenericDraweeHierarchy(GenericDraweeHierarchyBuilder builder) &#123;</span><br><span class="line">  <span class="keyword">if</span> (FrescoSystrace.isTracing()) &#123;</span><br><span class="line">    FrescoSystrace.beginSection(<span class="string">&quot;GenericDraweeHierarchy()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  mResources = builder.getResources();</span><br><span class="line">  mRoundingParams = builder.getRoundingParams();</span><br><span class="line"></span><br><span class="line">  mActualImageWrapper = <span class="keyword">new</span> ForwardingDrawable(mEmptyActualImageDrawable);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> numOverlays = (builder.getOverlays() != <span class="keyword">null</span>) ? builder.getOverlays().size() : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// make sure there is at least one overlay to make setOverlayImage(Drawable)</span></span><br><span class="line">  <span class="comment">// method work.</span></span><br><span class="line">  <span class="keyword">if</span> (numOverlays == <span class="number">0</span>) &#123;</span><br><span class="line">    numOverlays = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  numOverlays += (builder.getPressedStateOverlay() != <span class="keyword">null</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// layer indices and count</span></span><br><span class="line">  <span class="keyword">int</span> numLayers = OVERLAY_IMAGES_INDEX + numOverlays;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// array of layers</span></span><br><span class="line">  Drawable[] layers = <span class="keyword">new</span> Drawable[numLayers];</span><br><span class="line">  layers[BACKGROUND_IMAGE_INDEX] = buildBranch(builder.getBackground(), <span class="keyword">null</span>);</span><br><span class="line">  layers[PLACEHOLDER_IMAGE_INDEX] =</span><br><span class="line">      buildBranch(builder.getPlaceholderImage(), builder.getPlaceholderImageScaleType());</span><br><span class="line">  layers[ACTUAL_IMAGE_INDEX] =</span><br><span class="line">      buildActualImageBranch(</span><br><span class="line">          mActualImageWrapper,</span><br><span class="line">          builder.getActualImageScaleType(),</span><br><span class="line">          builder.getActualImageFocusPoint(),</span><br><span class="line">          builder.getActualImageColorFilter());</span><br><span class="line">  layers[PROGRESS_BAR_IMAGE_INDEX] =</span><br><span class="line">      buildBranch(builder.getProgressBarImage(), builder.getProgressBarImageScaleType());</span><br><span class="line">  layers[RETRY_IMAGE_INDEX] =</span><br><span class="line">      buildBranch(builder.getRetryImage(), builder.getRetryImageScaleType());</span><br><span class="line">  layers[FAILURE_IMAGE_INDEX] =</span><br><span class="line">      buildBranch(builder.getFailureImage(), builder.getFailureImageScaleType());</span><br><span class="line">  <span class="keyword">if</span> (numOverlays &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (builder.getOverlays() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Drawable overlay : builder.getOverlays()) &#123;</span><br><span class="line">        layers[OVERLAY_IMAGES_INDEX + index++] = buildBranch(overlay, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      index = <span class="number">1</span>; <span class="comment">// reserve space for one overlay</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (builder.getPressedStateOverlay() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      layers[OVERLAY_IMAGES_INDEX + index] = buildBranch(builder.getPressedStateOverlay(), <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// fade drawable composed of layers</span></span><br><span class="line">  mFadeDrawable = <span class="keyword">new</span> FadeDrawable(layers, <span class="keyword">false</span>, ACTUAL_IMAGE_INDEX);</span><br><span class="line">  mFadeDrawable.setTransitionDuration(builder.getFadeDuration());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// rounded corners drawable (optional)</span></span><br><span class="line">  Drawable maybeRoundedDrawable =</span><br><span class="line">      WrappingUtils.maybeWrapWithRoundedOverlayColor(mFadeDrawable, mRoundingParams);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// top-level drawable</span></span><br><span class="line">  mTopLevelDrawable = <span class="keyword">new</span> RootDrawable(maybeRoundedDrawable);</span><br><span class="line">  mTopLevelDrawable.mutate();</span><br><span class="line"></span><br><span class="line">  resetFade();</span><br><span class="line">  <span class="keyword">if</span> (FrescoSystrace.isTracing()) &#123;</span><br><span class="line">    FrescoSystrace.endSection();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个构造方法看起来有点长，实际上分成以下几个部分比较好了解：</p>
<ul>
<li>创建一个名为layers的Drawable数组，在对应下标构建对应图层的Drawable，其中ACTUAL_IMAGE_INDEX这个常量对应的位置，是上面看到过的mActualImageWrapper</li>
<li>其余图层分别是背景图、placeholder等等</li>
<li>通过layers数组，构建出FadeDrawable的对象mFadeDrawable</li>
<li>通过mFadeDrawable构建出maybeRoundedDrawable</li>
<li>通过maybeRoundedDrawable构建出了mTopLevelDrawable<br>这个mTopLevelDrawable就是我们最终设置到图片控件ImageView的Drawble，它包含了多个图层，当我们把网络图片的uri设置进去的时候，取到真正网络图片时，会更新真实图片的图层，来实现UI的更新</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Fresco提供了直接可用的UI控件</li>
<li>Fresco的UI控件展示的实际上是一个多图层的Drawable，通过更新Drawble的图层来实现图片加载</li>
</ul>
]]></content>
      <tags>
        <tag>图片加载框架</tag>
      </tags>
  </entry>
  <entry>
    <title>LeakCanary源码学习（基于LeakCanary2.7）</title>
    <url>/2021/05/08/LeakCanary%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><blockquote>
<p>LeakCanary is a memory leak detection library for Android.</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/SysuCodeMan/PicBed/main/20210508173009.png"><br>                                                        ——官方文档</p>
<p>官方介绍言简意赅，LeakCanary是Android平台的一款内存泄漏检测工具，可以检测出应用当前存在内存泄漏的地方。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">  <span class="comment">// debugImplementation because LeakCanary should only run in debug builds.</span></span><br><span class="line">  debugImplementation <span class="string">&#x27;com.squareup.leakcanary:leakcanary-android:2.7&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只需要在工程的依赖中加上这么一行即可，这里需要注意的是，添加依赖使用的API是<strong>debugImplementation</strong>——仅对debug包生效。<br>看到LeakCanary的用法时感觉很强大，仅仅引入依赖，没有添加任何java代码，即可以完成整个应用的内存泄漏检测。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>在学习LeakCanary进行内存泄漏检测的原理前，首先明确内存泄露的含义：不再使用的对象没有被正确销毁，导致内存不能被释放。<br>在java世界中，通常发生内存泄漏的原因是长声明周期的对象持有了短声明周期对象的引用。</p>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>从LeakCanary的官方文档中可以总结出其工作原理：LeakCanary在Activity/Fragment/View/ViewModel这些对象生命周期终点时，会弱引用这些对象，然后等待5秒并进行垃圾回收，如果此后弱引用的对象仍然存在，则说明这些对象可能发生了内存泄漏；此时需要进行一次heap dump，分析出这些对象的被引用情况，并将结果呈现给用户。</p>
<h3 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h3><p>LeakCanary2.7这个版本将初始化从显示的用户代码调用，改成了在ContentProvider的onCreate()中执行，这是一个很巧妙的设计，避免了对用户代码的侵入；当用户app依赖了LeakCanary之后，应用的application初始化之后自动执行LeakCanary里的ContentProvider会在onCreate()，从而触发LeakCanary的初始化操作。<br>负责初始化的ContentProvider在leakcanary-object-watcher-android这个库内，实现为AppWatcherInstaller</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">AppWatcherInstaller</span> : <span class="type">ContentProvider</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**`</span></span><br><span class="line"><span class="comment">   * [MainProcess] automatically sets up the LeakCanary code that runs in the main app process.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">MainProcess</span> : <span class="type">AppWatcherInstaller</span></span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * When using the `leakcanary-android-process` artifact instead of `leakcanary-android`,</span></span><br><span class="line"><span class="comment">   * [LeakCanaryProcess] automatically sets up the LeakCanary code</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">LeakCanaryProcess</span> : <span class="type">AppWatcherInstaller</span></span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> application = context!!.applicationContext <span class="keyword">as</span> Application</span><br><span class="line">    AppWatcher.manualInstall(application)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">query</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    uri: <span class="type">Uri</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    strings: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;?,</span></span></span><br><span class="line"><span class="function"><span class="params">    s: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">    strings1: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;?,</span></span></span><br><span class="line"><span class="function"><span class="params">    s1: <span class="type">String</span>?</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span>: Cursor? &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getType</span><span class="params">(uri: <span class="type">Uri</span>)</span></span>: String? &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">insert</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    uri: <span class="type">Uri</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    contentValues: <span class="type">ContentValues</span>?</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span>: Uri? &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">delete</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    uri: <span class="type">Uri</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    s: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">    strings: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;?</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">update</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    uri: <span class="type">Uri</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    contentValues: <span class="type">ContentValues</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">    s: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">    strings: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;?</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个ContentProvider的实现里，query/getType/insert/delete/update方法都是空实现，因为本来也不是真正的ContentProvider，仅仅是利用了ContentProvider的onCreate()机制来自动触发我们库的初始化，这个思路很巧妙，我们在进行debug工具开发的时候也可以借鉴这个写法。<br>在onCreate()中拿到了用户应用的application，然后调用AppWatcher的manualInstall()方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JvmOverloads</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">manualInstall</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  application: <span class="type">Application</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  retainedDelayMillis: <span class="type">Long</span> = TimeUnit.SECONDS.toMillis(<span class="number">5</span>)</span></span>,</span><br><span class="line">  watchersToInstall: List&lt;InstallableWatcher&gt; = appDefaultWatchers(application)</span><br><span class="line">) &#123;</span><br><span class="line">  checkMainThread()</span><br><span class="line">  <span class="keyword">if</span> (isInstalled) &#123;</span><br><span class="line">    <span class="keyword">throw</span> IllegalStateException(</span><br><span class="line">      <span class="string">&quot;AppWatcher already installed, see exception cause for prior install call&quot;</span>, installCause</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  check(retainedDelayMillis &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="string">&quot;retainedDelayMillis <span class="variable">$retainedDelayMillis</span> must be at least 0 ms&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  installCause = RuntimeException(<span class="string">&quot;manualInstall() first called here&quot;</span>)</span><br><span class="line">  <span class="keyword">this</span>.retainedDelayMillis = retainedDelayMillis</span><br><span class="line">  <span class="keyword">if</span> (application.isDebuggableBuild) &#123;</span><br><span class="line">    LogcatSharkLog.install()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Requires AppWatcher.objectWatcher to be set</span></span><br><span class="line">  LeakCanaryDelegate.loadLeakCanary(application)</span><br><span class="line"></span><br><span class="line">  watchersToInstall.forEach &#123;</span><br><span class="line">    it.install()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法分成以下部分：</p>
<ul>
<li>1.调用appDefaultWatchers()获得watchersToInstall对象集合</li>
<li>2.调用LeakCanaryDelegate.loadLeakCanary(application)</li>
<li>3.触发所有watchersToInstall的install()函数</li>
</ul>
<h3 id="1-1-AppWatcher-appDefaultWatchers"><a href="#1-1-AppWatcher-appDefaultWatchers" class="headerlink" title="1.1 AppWatcher.appDefaultWatchers()"></a>1.1 AppWatcher.appDefaultWatchers()</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">appDefaultWatchers</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  application: <span class="type">Application</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  reachabilityWatcher: <span class="type">ReachabilityWatcher</span> = objectWatcher</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: List&lt;InstallableWatcher&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> listOf(</span><br><span class="line">    ActivityWatcher(application, reachabilityWatcher),</span><br><span class="line">    FragmentAndViewModelWatcher(application, reachabilityWatcher),</span><br><span class="line">    RootViewWatcher(reachabilityWatcher),</span><br><span class="line">    ServiceWatcher(reachabilityWatcher)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认的Watcher是以上4个。</p>
<h3 id="1-2-LeakCanaryDelegate-loadLeakCanary-application"><a href="#1-2-LeakCanaryDelegate-loadLeakCanary-application" class="headerlink" title="1.2 LeakCanaryDelegate.loadLeakCanary(application)"></a>1.2 LeakCanaryDelegate.loadLeakCanary(application)</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> loadLeakCanary <span class="keyword">by</span> lazy &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> leakCanaryListener = Class.forName(<span class="string">&quot;leakcanary.internal.InternalLeakCanary&quot;</span>)</span><br><span class="line">    leakCanaryListener.getDeclaredField(<span class="string">&quot;INSTANCE&quot;</span>)</span><br><span class="line">      .<span class="keyword">get</span>(<span class="literal">null</span>) <span class="keyword">as</span> (Application) -&gt; <span class="built_in">Unit</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (ignored: Throwable) &#123;</span><br><span class="line">    NoLeakCanary</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成InternalLeakCanary类的加载</p>
<h3 id="1-3-触发所有watchersToInstall的install-函数，以ActivityWatcher为例："><a href="#1-3-触发所有watchersToInstall的install-函数，以ActivityWatcher为例：" class="headerlink" title="1.3 触发所有watchersToInstall的install()函数，以ActivityWatcher为例："></a>1.3 触发所有watchersToInstall的install()函数，以ActivityWatcher为例：</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">install</span><span class="params">()</span></span> &#123;</span><br><span class="line">  application.registerActivityLifecycleCallbacks(lifecycleCallbacks)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用Application的registerActivityLifecycleCallbacks，监听Activity的生命周期，回调函数的实现是：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> lifecycleCallbacks =</span><br><span class="line">    <span class="keyword">object</span> : Application.ActivityLifecycleCallbacks <span class="keyword">by</span> noOpDelegate() &#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityDestroyed</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">        reachabilityWatcher.expectWeaklyReachable(</span><br><span class="line">          activity, <span class="string">&quot;<span class="subst">$&#123;activity::class.java.name&#125;</span> received Activity#onDestroy() callback&quot;</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在Activity执行onDestroy()时执行调用reachabilityWatcher的expectWeaklyReachable()方法，这里使用的reachabilityWatcher实现类是ObjectWatcher，expectWeaklyReachable()的实现如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Synchronized</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">expectWeaklyReachable</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  watchedObject: <span class="type">Any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  description: <span class="type">String</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isEnabled()) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  removeWeaklyReachableObjects()</span><br><span class="line">  <span class="keyword">val</span> key = UUID.randomUUID()</span><br><span class="line">    .toString()</span><br><span class="line">  <span class="keyword">val</span> watchUptimeMillis = clock.uptimeMillis()</span><br><span class="line">  <span class="keyword">val</span> reference =</span><br><span class="line">    KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue)</span><br><span class="line">  SharkLog.d &#123;</span><br><span class="line">    <span class="string">&quot;Watching &quot;</span> +</span><br><span class="line">      (<span class="keyword">if</span> (watchedObject <span class="keyword">is</span> Class&lt;*&gt;) watchedObject.toString() <span class="keyword">else</span> <span class="string">&quot;instance of <span class="subst">$&#123;watchedObject.javaClass.name&#125;</span>&quot;</span>) +</span><br><span class="line">      (<span class="keyword">if</span> (description.isNotEmpty()) <span class="string">&quot; (<span class="variable">$description</span>)&quot;</span> <span class="keyword">else</span> <span class="string">&quot;&quot;</span>) +</span><br><span class="line">      <span class="string">&quot; with key <span class="variable">$key</span>&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  watchedObjects[key] = reference</span><br><span class="line">  checkRetainedExecutor.execute &#123;</span><br><span class="line">    moveToRetained(key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法有以下3部分组成：</p>
<ul>
<li>1.调用removeWeaklyReachableObjects()进行一次可达性检查</li>
<li>2.将当前需要被观察的watchedObject记录到watchedObjects这个集合里</li>
<li>3.调用checkRetainedExecutor触发moveToRetained()<br>下面分别展开看下removeWeaklyReachableObjects()和moveToRetained()的实现：</li>
</ul>
<h3 id="1-3-1-removeWeaklyReachableObjects"><a href="#1-3-1-removeWeaklyReachableObjects" class="headerlink" title="1.3.1 removeWeaklyReachableObjects()"></a>1.3.1 removeWeaklyReachableObjects()</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">removeWeaklyReachableObjects</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// WeakReferences are enqueued as soon as the object to which they point to becomes weakly</span></span><br><span class="line">  <span class="comment">// reachable. This is before finalization or garbage collection has actually happened.</span></span><br><span class="line">  <span class="keyword">var</span> ref: KeyedWeakReference?</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    ref = queue.poll() <span class="keyword">as</span> KeyedWeakReference?</span><br><span class="line">    <span class="keyword">if</span> (ref != <span class="literal">null</span>) &#123;</span><br><span class="line">      watchedObjects.remove(ref.key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (ref != <span class="literal">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的queue是ReferenceQueue<Any>()，在构建弱引用时，是通过WeakReference<Any>(referent, referenceQueue)的方式构建的，传入的第二个参数referenceQueue就是这个queue对象<br><strong>构建WeakReference时，如果referent的可达性更改成只有弱引用，则会将这个referent添加到传入的referenceQueue中</strong><br>理解了上面的这个referenceQueue的作用，便不难理解这段方法的作用：<br>不断从queue中取出对象，因为这些对象是只剩弱引用的，在下次GC必然会被回收，因此我们没有必要再继续观察它们，所以把它们从watchedObjects中移除</p>
<h3 id="1-3-2-moveToRetained"><a href="#1-3-2-moveToRetained" class="headerlink" title="1.3.2 moveToRetained()"></a>1.3.2 moveToRetained()</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Synchronized</span> <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">moveToRetained</span><span class="params">(key: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">  removeWeaklyReachableObjects()</span><br><span class="line">  <span class="keyword">val</span> retainedRef = watchedObjects[key]</span><br><span class="line">  <span class="keyword">if</span> (retainedRef != <span class="literal">null</span>) &#123;</span><br><span class="line">    retainedRef.retainedUptimeMillis = clock.uptimeMillis()</span><br><span class="line">    onObjectRetainedListeners.forEach &#123; it.onObjectRetained() &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里再一次调用了removeWeaklyReachableObjects()检查当前这个对象是否真的处于Retained状态，如果是的话，则触发onObjectRetainedListeners的onObjectRetained()方法；这里比较重要的<br>onObjectRetainedListener是InternalLeakCanary中的实现：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onObjectRetained</span><span class="params">()</span></span> = scheduleRetainedObjectCheck()</span><br></pre></td></tr></table></figure>
<p>会调用到scheduleRetainedObjectCheck()</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">scheduleRetainedObjectCheck</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>::heapDumpTrigger.isInitialized) &#123;</span><br><span class="line">    heapDumpTrigger.scheduleRetainedObjectCheck()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转到HeapDumpTrigger的scheduleRetainedObjectCheck()方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">scheduleRetainedObjectCheck</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    delayMillis: <span class="type">Long</span> = <span class="number">0</span>L</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> checkCurrentlyScheduledAt = checkScheduledAt</span><br><span class="line">    <span class="keyword">if</span> (checkCurrentlyScheduledAt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    checkScheduledAt = SystemClock.uptimeMillis() + delayMillis</span><br><span class="line">    backgroundHandler.postDelayed(&#123;</span><br><span class="line">      checkScheduledAt = <span class="number">0</span></span><br><span class="line">      checkRetainedObjects()</span><br><span class="line">    &#125;, delayMillis)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>然后执行checkRetainedObjects()方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkRetainedObjects</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> iCanHasHeap = HeapDumpControl.iCanHasHeap()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> config = configProvider()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个条件语句是用于判断能否进行DumpHeap，正常情况不会走进去，暂时略过这里面的细节</span></span><br><span class="line">  <span class="keyword">if</span> (iCanHasHeap <span class="keyword">is</span> Nope) &#123;</span><br><span class="line">    <span class="keyword">if</span> (iCanHasHeap <span class="keyword">is</span> NotifyingNope) &#123;</span><br><span class="line">      <span class="comment">// Before notifying that we can&#x27;t dump heap, let&#x27;s check if we still have retained object.</span></span><br><span class="line">      <span class="keyword">var</span> retainedReferenceCount = objectWatcher.retainedObjectCount</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (retainedReferenceCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        gcTrigger.runGc()</span><br><span class="line">        retainedReferenceCount = objectWatcher.retainedObjectCount</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> nopeReason = iCanHasHeap.reason()</span><br><span class="line">      <span class="keyword">val</span> wouldDump = !checkRetainedCount(</span><br><span class="line">        retainedReferenceCount, config.retainedVisibleThreshold, nopeReason</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (wouldDump) &#123;</span><br><span class="line">        <span class="keyword">val</span> uppercaseReason = nopeReason[<span class="number">0</span>].toUpperCase() + nopeReason.substring(<span class="number">1</span>)</span><br><span class="line">        onRetainInstanceListener.onEvent(DumpingDisabled(uppercaseReason))</span><br><span class="line">        showRetainedCountNotification(</span><br><span class="line">          objectCount = retainedReferenceCount,</span><br><span class="line">          contentText = uppercaseReason</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      SharkLog.d &#123;</span><br><span class="line">        application.getString(</span><br><span class="line">          R.string.leak_canary_heap_dump_disabled_text, iCanHasHeap.reason()</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> retainedReferenceCount = objectWatcher.retainedObjectCount</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (retainedReferenceCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果此时的retained的对象大于0，主动触发一次gc</span></span><br><span class="line">    gcTrigger.runGc()</span><br><span class="line">    retainedReferenceCount = objectWatcher.retainedObjectCount</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold)) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> now = SystemClock.uptimeMillis()</span><br><span class="line">  <span class="keyword">val</span> elapsedSinceLastDumpMillis = now - lastHeapDumpUptimeMillis</span><br><span class="line">  <span class="comment">// 这个条件语句作用是判断当前时间和上一次进行dump操作隔了多久，如果在WAIT_BETWEEN_HEAP_DUMPS_MILLIS区间内，则这时候不会马上进行dump操作，而是延迟一段时间再操作</span></span><br><span class="line">  <span class="keyword">if</span> (elapsedSinceLastDumpMillis &lt; WAIT_BETWEEN_HEAP_DUMPS_MILLIS) &#123;</span><br><span class="line">    onRetainInstanceListener.onEvent(DumpHappenedRecently)</span><br><span class="line">    showRetainedCountNotification(</span><br><span class="line">      objectCount = retainedReferenceCount,</span><br><span class="line">      contentText = application.getString(R.string.leak_canary_notification_retained_dump_wait)</span><br><span class="line">    )</span><br><span class="line">    scheduleRetainedObjectCheck(</span><br><span class="line">      delayMillis = WAIT_BETWEEN_HEAP_DUMPS_MILLIS - elapsedSinceLastDumpMillis</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dismissRetainedCountNotification()</span><br><span class="line">  <span class="keyword">val</span> visibility = <span class="keyword">if</span> (applicationVisible) <span class="string">&quot;visible&quot;</span> <span class="keyword">else</span> <span class="string">&quot;not visible&quot;</span></span><br><span class="line">  <span class="comment">// 触发dumpHeap()方法进行dump操作</span></span><br><span class="line">  dumpHeap(</span><br><span class="line">    retainedReferenceCount = retainedReferenceCount,</span><br><span class="line">    retry = <span class="literal">true</span>,</span><br><span class="line">    reason = <span class="string">&quot;<span class="variable">$retainedReferenceCount</span> retained objects, app is <span class="variable">$visibility</span>&quot;</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法乍一看还有点长，但实际上正常情况下里面的一些条件语句都是不用走进去的，已经在注释中说明，简单来说，就是判断当前是不是真的需要进行dumpHeap操作<br>下面看下dumpHeap()操作的具体实现：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dumpHeap</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  retainedReferenceCount: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  retry: <span class="type">Boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  reason: <span class="type">String</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">  saveResourceIdNamesToMemory()</span><br><span class="line">  <span class="keyword">val</span> heapDumpUptimeMillis = SystemClock.uptimeMillis()</span><br><span class="line">  KeyedWeakReference.heapDumpUptimeMillis = heapDumpUptimeMillis</span><br><span class="line">  <span class="keyword">when</span> (<span class="keyword">val</span> heapDumpResult = heapDumper.dumpHeap()) &#123;</span><br><span class="line">    <span class="keyword">is</span> NoHeapDump -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (retry) &#123;</span><br><span class="line">        SharkLog.d &#123; <span class="string">&quot;Failed to dump heap, will retry in <span class="variable">$WAIT_AFTER_DUMP_FAILED_MILLIS</span> ms&quot;</span> &#125;</span><br><span class="line">        scheduleRetainedObjectCheck(</span><br><span class="line">          delayMillis = WAIT_AFTER_DUMP_FAILED_MILLIS</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        SharkLog.d &#123; <span class="string">&quot;Failed to dump heap, will not automatically retry&quot;</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      showRetainedCountNotification(</span><br><span class="line">        objectCount = retainedReferenceCount,</span><br><span class="line">        contentText = application.getString(</span><br><span class="line">          R.string.leak_canary_notification_retained_dump_failed</span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">is</span> HeapDump -&gt; &#123;</span><br><span class="line">      lastDisplayedRetainedObjectCount = <span class="number">0</span></span><br><span class="line">      lastHeapDumpUptimeMillis = SystemClock.uptimeMillis()</span><br><span class="line">      objectWatcher.clearObjectsWatchedBefore(heapDumpUptimeMillis)</span><br><span class="line">      HeapAnalyzerService.runAnalysis(</span><br><span class="line">        context = application,</span><br><span class="line">        heapDumpFile = heapDumpResult.file,</span><br><span class="line">        heapDumpDurationMillis = heapDumpResult.durationMillis,</span><br><span class="line">        heapDumpReason = reason</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分成两步：</p>
<ul>
<li>调用heapDumper.dumpHeap()对堆栈进行真正的dump操作，得到当前堆栈情况，最重要的产物是heapDumpFile</li>
<li>通过HeapAnalyzerService.runAnalysis()来对当前堆栈情况heapDumpFile进行分析<br>再往后的操作就是通过shark分析heapDumpFile，找出完成的引用链并展示。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>LeakCanary2.7版本已经不需要用户代码再显式初始化，而是通过ContentProvider的机制</li>
<li>LeakCanary对Activity进行内存泄漏检测的原理是，通过application来监听应用所有Activity的生命周期，在onDestory()执行时开始观察它；假如onDestory()执行一段时间后这个对象仍然存活，则处于retained状态；当retained状态的对象数量达到阈值（默认为5），则会进行一次dumpHeap操作</li>
<li>通过dumpHeap操作得到的heapDumpFile，调用shark进行引用链的分析</li>
</ul>
]]></content>
      <tags>
        <tag>内存泄漏检测工具</tag>
      </tags>
  </entry>
</search>
